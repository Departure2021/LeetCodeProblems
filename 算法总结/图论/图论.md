图论

![image-20220428183001277](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220428183001277.png)

![image-20220428183016566](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220428183016566.png)

## 概念：

![image-20220427151706849](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220427151706849.png)

一个有 V 个 顶点的图 G 是一棵树，条件是当且仅当它满足以下4个条件中的任何一个条件：

1. G 有 V - 1 条边，且无环。
2. G 的 V - 1 条边，且是连通的。
3. G 中仅有一条简单路径使每一对顶点相连接。
4. G 是连通的，从中取出任意一条边都会使其不连通。

​		这些条件中的任意一个都是证明另外3个的充要条件，而且由它们可以建立有关树的其他条件组合。

**图的密度**定义未平均顶点度，即 $$2E/V$$。

**二部图**是一种特殊的图，可以将其顶点划分为两个集合，从而使每条边所连接的顶点均处于不同的集合中。一个二部图的任何子图都是二部图。

![image-20220427141802802](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220427141802802.png)

## 简单路径搜索

​		给定两个顶点，图中是否有一条将它们连接起来的简单路径。

​		这个类使用了一个递归的深度优先搜索函数 searchR，以找到一条连接图中两个给定顶点的简单路径，并提高了一个成员函数 exists，从而允许客户程序检车路径是否存在。给定两个顶点 v 和 w，searchR 会检查与 v 邻接的各条边 v - t，以查看它是否为到 w 的路径中的第一条边。顶点索引相邻 visited 可避免函数对任意顶点做重复访问，因此只能遍历得到一条简单路径。

**C++图算法代码：**

```c++
template <class Graph>
class sPATH
{
private:
	const Graph& G;
	vector<bool> visited;
	bool found;
	bool searchR(int v, int w) {
		if (v == w) return true;
		visited[v] = true;
		typename Graph::adjIterator A(G, v);
		for (int t = A.beg(); !A.end(); t = A.nxt()) {
			if (!visited[t]) {
				if (searchR(t, w)) return true;
			}
		}
		return false;
	}

public:
	sPATH(const Graph& G, int v, int w) : G(G), visited(G.V(), false) {
		found = searchR(v, w);
	}
	bool exists() const { return found; }
}; // 2022.4.27
```

#### [1971. 寻找图中是否存在路径](https://leetcode.cn/problems/find-if-path-exists-in-graph/)

难度简单31收藏分享切换为英文接收动态反馈

有一个具有 `n`个顶点的 **双向** 图，其中每个顶点标记从 `0` 到 `n - 1`（包含 `0` 和 `n - 1`）。图中的边用一个二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和顶点 `vi` 之间的双向边。 每个顶点对由 **最多一条** 边连接，并且没有顶点存在与自身相连的边。

请你确定是否存在从顶点 `start` 开始，到顶点 `end` 结束的 **有效路径** 。

给你数组 `edges` 和整数 `n`、`start`和`end`，如果从 `start` 到 `end` 存在 **有效路径** ，则返回 `true`，否则返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex1.png)

```
输入：n = 3, edges = [[0,1],[1,2],[2,0]], start = 0, end = 2
输出：true
解释：存在由顶点 0 到顶点 2 的路径:
- 0 → 1 → 2 
- 0 → 2
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/08/14/validpath-ex2.png)

```
输入：n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], start = 0, end = 5
输出：false
解释：不存在由顶点 0 到顶点 5 的路径.
```

 

**提示:**

- `1 <= n <= 2 * 105`
- `0 <= edges.length <= 2 * 105`
- `edges[i].length == 2`
- `0 <= ui, vi <= n - 1`
- `ui != vi`
- `0 <= start, end <= n - 1`
- 不存在双向边
- 不存在指向顶点自身的边

**C++版代码：**

```c++
class Solution {
private:
    vector<vector<int>> graph;
    vector<bool> visited;
    bool search(const int v, const int w) {
        if (v == w) return true;
        visited[v] = true;
        for (auto u : graph[v]) {
            if (!visited[u]) {
                if (search(u, w)) return true;
            }
        }
        return false;
    }
public:
    bool validPath(int n, vector<vector<int>>& edges, int source, int destination) {
        graph = vector<vector<int>>(n);
        visited = vector<bool>(n, false);
        for (auto edge : edges) {
            graph[edge[0]].push_back(edge[1]);
            graph[edge[1]].push_back(edge[0]);
        }
        return search(source, destination);
    }
}; // 2022.4.27
```

## 哈密顿路径

![image-20220428152217938](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220428152217938.png)

![image-20220428132910031](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220428132910031.png)

## 欧拉路径

欧拉路径：**由某个顶点出发经过图的每一条边且仅经过一次**（顶点可能被访问多次）。

**推论：一个图有一条欧拉路径，条件是当且仅当它是连通的，而且只有两个顶点有奇数度数。**

程序1.18 欧拉路径存在性（C++代码）：

```c++
#pragma once
template <class Graph>
class ePATH
{
private:
	Graph G;
	int v, w;
	bool found;
	stack <int> S;
	int tour(int v);
public:
	ePATH(const Graph& G, int v, int w) : G(G), v(v), w(w) {
		DEGREE<Graph> deg(G);
		int t = deg[v] + deg[w];
		if ((t % 2) != 0) { found = false; return; }
		for (t = 0; t < G.v(); t++) {
			if ((t != v) and (t != w)) {
				if ((deg[t] % 2) != 0) {
					found = false;
					return;
				}
			}
		}
		found = true;
	}
	bool exists() const { return found; }
	void show();
};
```

![image-20220428135849136](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220428135849136.png)

![image-20220428140658692](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220428140658692.png)

## 欧拉回路

欧拉回路：由某个顶点出发经过图中的每一条边且仅经过一次并回到该顶点。

​	如果欧拉路径的**起点和终点相同**，则称“**欧拉回路**”。具有欧拉回路的图称“**欧拉图**”。

在一个图中，如果存在一条通过图中每条边一次且仅一次行遍图中每个顶点的通路且不存在通过图中每条边一次且仅一次行遍图中每个顶点的回路，则称G是**半欧拉图**。

属性：一个图有一条欧拉周游路径（欧拉回路），条件是当且仅当它是**连通的**，而且**所有顶点都有偶数度数**。

![image-20220428133951173](C:\Users\yb\AppData\Roaming\Typora\typora-user-images\image-20220428133951173.png)

C++代码：

```c++
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 200005;

vector<pair<int, int>> graph[MAXN*2];
vector<int> ans[MAXN];
map<int, int> M;
int sid[MAXN*2];    // 用于记录枚举到以这个点为起点的哪条边了

void dfs(int X, int flag)
{
    int u=X;
    while (sid[u]) {
        sid[u]--;
        int v=graph[u][sid[u]].first;
        int pos=graph[u][sid[u]].second;
        if (ans[min(u, v)][pos]<0) {

            ans[min(u, v)][pos]=flag;

            dfs(v, flag^1);
        }
    }
}

void solve()
{
    int mxid=MAXN, m;
    scanf("%d",&m);
    for (int i=1, len, v; i<=m; i++) {
        scanf("%d",&len);
        ans[i].resize(len+1, -1);
        for (int j=1; j<=len; j++) {
            scanf("%d",&v);
            if (M[v]==0)
                v=M[v]=++mxid;
            else
                v=M[v];
            graph[i].push_back(make_pair(v, j));
            graph[v].push_back(make_pair(i, j));
            sid[i]++;
            sid[v]++;
        }
    }

    for (int i=MAXN*2; i>MAXN; i--) {
        if (sid[i]&1) {
            puts("NO");
            return;
        }
    }

    for (int i=1; i<=mxid; i++) {
        dfs(i, 0);
    }

    puts("YES");
    for (int i=1; i<=m; i++) {
        for (int j=1; j<ans[i].size(); j++)
            putchar(ans[i][j] ? 'L' : 'R');
        puts("");
    }
}



int main()
{
    solve();
    return 0;
}
```

### Hierholzer 算法

**问题简述**：现给出一个有向图，且为欧拉图。求欧拉回路。

**Hierholzer 算法过程**：

1. 选择任一顶点为起点，遍历所有相邻边。
2. 深度搜索，访问相邻顶点。将经过的边都删除。
3. 如果当前顶点没有相邻边，则将顶点入栈。
4. 栈中的顶点倒序输出，就是从起点出发的欧拉回路。

为了证明该算法的有效性，下说明两条性质。

**性质一**：

如果该图为欧拉图，则栈底的必定为起点。如果该图为半欧拉图，则栈底部存储的是与起点不同的另外一个奇度数顶点。

**证明**：

当顶点入栈时，说明当前所在顶点没有相邻边。

考虑到从起点出发到当前结点的路径中，除了起点和当前顶点外，其他的顶点都失去了偶数度数(入度与出度一一对应)。

如果起点和当前顶点不同，那么两者都失去了奇数度数。

如果图中包含欧拉回路，意味着所有顶点的初始度数都是偶数，而当前顶点的当前度数为0，表示当前顶点的初始度数必定是奇数，产生矛盾，因此假设不成立。当前顶点就是起点。

同样地，对于欧拉路径，当前顶点不可能是起点，否则起点的度数就是偶数，而欧拉路径中起点和终点的度数一定是奇数。因此，当前顶点不是起点，但是度数也是奇数，所以一定是终点。

**性质二**：

如果该图为欧拉图(/半欧拉图)，则栈中的自底到顶第 ![[公式]](https://www.zhihu.com/equation?tex=n) 个顶点就是欧拉回路(/欧拉路径)上的第 ![[公式]](https://www.zhihu.com/equation?tex=n+) 个顶点。

**证明**：

在此只证明栈中相邻顶点在图中也为相邻顶点。因为模拟 Hierholzer 算法过程，可知该算法实际上就是在模拟“一笔画”过程，并且沿着画完的轨迹，从终点倒着逐一添加顶点到栈中。

并且主要以 ![[公式]](https://www.zhihu.com/equation?tex=n%3D2) 的情况为例，后面的情况可以此类推。并且为了不用纠结于区分欧拉回路和欧拉路径，不妨以半欧拉图为例。

假设图中存在相邻的两顶点 ![[公式]](https://www.zhihu.com/equation?tex=V_1%2CV_2) ，并且深度搜索过程中，先访问 ![[公式]](https://www.zhihu.com/equation?tex=V_2) 随后访问了 ![[公式]](https://www.zhihu.com/equation?tex=V_1) ，并且 ![[公式]](https://www.zhihu.com/equation?tex=V_1) 成为第一个入栈的顶点。由**性质一**可知， ![[公式]](https://www.zhihu.com/equation?tex=V_1) 就是欧拉路径上的起点(两个奇度数顶点任一可看作起点)。

根据 **Hierholzer 算法**，在遍历过程中，删除了途径的边，所以此时所有顶点的度数都为偶数。当然 ![[公式]](https://www.zhihu.com/equation?tex=%5Cdeg%28V_2%29) 也是偶数，接下来就分类讨论。

如果 ![[公式]](https://www.zhihu.com/equation?tex=%5Cdeg%28V_2%29%3D0) ，也就是说当前顶点 ![[公式]](https://www.zhihu.com/equation?tex=V_2) 成为第二个入栈的顶点，那么 ![[公式]](https://www.zhihu.com/equation?tex=n%3D2) 的情况就证毕了。

如果 ![[公式]](https://www.zhihu.com/equation?tex=%5Cdeg%28V_2%29%3E0) ，那么考虑当前包含 ![[公式]](https://www.zhihu.com/equation?tex=V_2) 的子图 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbf%7BG%7D) ，显然 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbf%7BG%7D) 是一个欧拉图，那么当前以 ![[公式]](https://www.zhihu.com/equation?tex=V_2) 为起点继续实施 Hierholzer 算法遍历剩下的相邻边，根据**性质一**， ![[公式]](https://www.zhihu.com/equation?tex=V_2) 将会是 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathbf%7BG%7D) 中第一个入栈的顶点。也就是， ![[公式]](https://www.zhihu.com/equation?tex=V_2) 是原图中第二个入栈的顶点。

综上所述，以此类推， ![[公式]](https://www.zhihu.com/equation?tex=V_%7Bn-1%7D) 入栈前最后接触过的 ![[公式]](https://www.zhihu.com/equation?tex=V_n) 将会是第 ![[公式]](https://www.zhihu.com/equation?tex=n) 个入栈的顶点，再结合直观理解， ![[公式]](https://www.zhihu.com/equation?tex=V_n) 就是路径上的第 ![[公式]](https://www.zhihu.com/equation?tex=n) 个顶点。

### 例题：

#### [2097. 合法重新排列数对](https://leetcode.cn/problems/valid-arrangement-of-pairs/)(不会)

难度困难31

给你一个下标从 **0** 开始的二维整数数组 `pairs` ，其中 `pairs[i] = [starti, endi]` 。如果 `pairs` 的一个重新排列，满足对每一个下标 `i` （ `1 <= i < pairs.length` ）都有 `endi-1 == starti` ，那么我们就认为这个重新排列是 `pairs` 的一个 **合法重新排列** 。

请你返回 **任意一个** `pairs` 的合法重新排列。

**注意：**数据保证至少存在一个 `pairs` 的合法重新排列。

 

**示例 1：**

```
输入：pairs = [[5,1],[4,5],[11,9],[9,4]]
输出：[[11,9],[9,4],[4,5],[5,1]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 9 == 9 = start1 
end1 = 4 == 4 = start2
end2 = 5 == 5 = start3
```

**示例 2：**

```
输入：pairs = [[1,3],[3,2],[2,1]]
输出：[[1,3],[3,2],[2,1]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 3 == 3 = start1
end1 = 2 == 2 = start2
重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。
```

**示例 3：**

```
输入：pairs = [[1,2],[1,3],[2,1]]
输出：[[1,2],[2,1],[1,3]]
解释：
输出的是一个合法重新排列，因为每一个 endi-1 都等于 starti 。
end0 = 2 == 2 = start1
end1 = 1 == 1 = start2
```

 

**提示：**

- `1 <= pairs.length <= 105`
- `pairs[i].length == 2`
- `0 <= starti, endi <= 109`
- `starti != endi`
- `pairs` 中不存在一模一样的数对。
- 至少 **存在** 一个合法的 `pairs` 重新排列。

方法：有向图的欧拉通路

思路与算法

如果我们把数组 $$pairs$$ 中出现的每个数看成一个节点，$$(\textit{start}_i, \textit{end}_i) $$看成从 $$\textit{start}$$ 到 $$\textit{end}$$ 的一条有向边，那么 $$pairs$$ 的一个合法排列就对应着：

- 从节点 $$\textit{pairs}[0][0]$$ 开始；

- 依次经过 $$\textit{pairs}[0][1], \textit{pairs}[1][1], \cdots, \textit{pairs}[n-1][1]$$；


的一条路径，其中 $$n$$ 是数组 $$\textit{pairs}$$ 的长度。这条路径经过了图上的每一条边恰好一次，是一条「欧拉通路」，因此我们的目标就是找出图上的任意一条欧拉通路。

对于本题而言，我们首先需要找到欧拉通路的起始节点：如果图中所有节点的入度和出度都相等，那么从任意节点开始都存在欧拉通路；如果图中存在一个节点的出度比入度恰好多 1，另一个节点的入度恰好比出度多 1，那么欧拉通路必须从前一个节点开始，到后一个节点结束。除此之外的有向图都不存在欧拉通路，本体保证了至少存在一个合法排列，因此图已经是上述的两种情况之一。

当我们确定起始节点后，就可以使用深度优先搜索求解欧拉通路了。如果我们得到的欧拉通路为：

$$
v_1, v_2, v_3, \cdots, v_n, v_{n+1}
$$
那么 $$[[v_1, v_2], [v_2, v_3], \cdots, [v_n, v_{n+1}]]$$ 就是一个合法排列。

C++代码：

```c++
class Solution {
public:
    vector<vector<int>> validArrangement(vector<vector<int>>& pairs) {
        // 存储图
        unordered_map<int, vector<int>> edges;
        // 存储入度和出度
        unordered_map<int, int> indeg, outdeg;
        for (const auto& p: pairs) {
            int x = p[0], y = p[1];
            edges[x].push_back(y);
            ++indeg[y];
            ++outdeg[x];
        }
        
        // 寻找起始节点
        int start = pairs[0][0];
        for (const auto& [x, occ]: outdeg) {
            // 如果有节点出度比入度恰好多 1，那么只有它才能是起始节点
            if (occ == indeg[x] + 1) {
                start = x;
                break;
            }
        }
        
        vector<vector<int>> ans;
        
        // 深度优先搜索（Hierholzer 算法）求解欧拉通路
        function<void(int)> dfs = [&](int u) {
            while (!edges[u].empty()) {
                int v = edges[u].back();
                edges[u].pop_back();
                dfs(v);
                ans.push_back({u, v});
            }
        };
        
        dfs(start);
        reverse(ans.begin(), ans.end());
        return ans;
    }
}; // 2022.4.28
```



## 最短路径

### Dijkstra 算法

**Dijkstra 算法**，是由荷兰计算机科学家 Edsger Wybe Dijkstra 在1956年发现的算法，戴克斯特拉算法使用类似广度优先搜索的方法解决**赋权图的单源最短路径问题**。Dijkstra 算法原始版本仅适用于找到两个顶点之间的最短路径，后来更常见的变体固定了一个顶点作为源结点然后找到该顶点到图中所有其它结点的最短路径，产生一个最短路径树。本算法每次取出未访问结点中距离最小的，用该结点更新其他结点的距离。需要注意的是绝大多数的Dijkstra 算法不能有效处理带有**负权边**的图。

下面，我们就从一个赋权的有向图为例开始解释Dijkstra 算法。

设一个赋权有向图 ![[公式]](https://www.zhihu.com/equation?tex=G%3D%28V%2C%5C%2CE%2C%5C%2CW%29) 。其中的每条边 ![[公式]](https://www.zhihu.com/equation?tex=e_%7Bi%2Cj%7D%3A%3D%5Cleft%5C%7Bv_i%2C%5C%2Cv_j%5Cright%5C%7D) 的权值为一个非负的实数 ![[公式]](https://www.zhihu.com/equation?tex=w_%7Bi%2Cj%7D%28e_%7Bi%2Cj%7D%29) ，**该权值表示从顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_j) 的距离**。并设一单源点 ![[公式]](https://www.zhihu.com/equation?tex=s%5Cin+V) 。现在我们的任务是：找出从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 出发，到 ![[公式]](https://www.zhihu.com/equation?tex=V%5Csetminus%5C%7Bs%5C%7D) 中所有的节点的最短路径。

我们来看一个具体的例子：

![img](https://pic2.zhimg.com/80/v2-739504182d99cf3dc5fcf98eee75d029_720w.jpg)

​																										图片1：例图。

这是一个具有 ![[公式]](https://www.zhihu.com/equation?tex=6) 个顶点的赋权有向图，其顶点集合为 ![[公式]](https://www.zhihu.com/equation?tex=V%3D%5Cleft%5C%7Bv_1%2Cv_2%2Cv_3%2Cv_4%2Cv_5%2Cv_6%5Cright%5C%7D) ，其权值分别为：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bmatrix%7D+w_%7B1%2C2%7D%5Cleft%28e_%7B1%2C2%7D%5Cright%29%3D10%26+w_%7B2%2C3%7D%5Cleft%28e_%7B2%2C3%7D%5Cright%29%3D7%5C%5C+w_%7B4%2C3%7D%5Cleft%28e_%7B4%2C3%7D%5Cright%29%3D4%26+w_%7B4%2C5%7D%5Cleft%28e_%7B4%2C5%7D%5Cright%29%3D7%5C%5C++w_%7B6%2C5%7D%5Cleft%28e_%7B6%2C5%7D%5Cright%29%3D1%26++w_%7B1%2C6%7D%5Cleft%28e_%7B1%2C6%7D%5Cright%29%3D3%5C%5C++w_%7B6%2C2%7D%5Cleft%28e_%7B6%2C2%7D%5Cright%29%3D2%26++w_%7B4%2C1%7D%5Cleft%28e_%7B4%2C1%7D%5Cright%29%3D3%5C%5C++w_%7B2%2C4%7D%5Cleft%28e_%7B2%2C4%7D%5Cright%29%3D5%26++w_%7B6%2C4%7D%5Cleft%28e_%7B6%2C4%7D%5Cright%29%3D6+%5Cend%7Bmatrix%7D%5Ctag%7B1%7D)

现在我们选定 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) 为原点 ![[公式]](https://www.zhihu.com/equation?tex=s) ：

![img](https://pic3.zhimg.com/80/v2-3efe1805d5487018b65b470643f463de_720w.jpg)

​																							图片2：选择v_1作为原点s。

则从源点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) 出发，到 ![[公式]](https://www.zhihu.com/equation?tex=V%5Csetminus+%5Cleft%5C%7B%5Ccolor%7Bred%7D%7Bv_1%7D%5Cright%5C%7D) 中所有顶点的最短路径分别为：

![img](https://pic2.zhimg.com/80/v2-f065fe99f3a8884e025fa1feb5dfd391_720w.jpg)

​															图片3：V中的源点s(v_1)到V中其余点的最短路径。

即：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Balign%2A%7D++%26%5Cmathrm%7Bshort%7D%5Cleft%5B2%5Cright%5D%3A%5Ccolor%7Bred%7D%7Bv_1%7D%5Cto+v_6%5Cto+v_2%5CRightarrow+%5Cmathrm%7Bshort%7D%5Cleft%5B2%5Cright%5D%3Dw_%7B1%2C6%7D%2Bw_%7B6%2C2%7D%3D5%5Ctag%7B2%7D%5C%5C+%26%5Cmathrm%7Bshort%7D%5Cleft%5B3%5Cright%5D%3A%5Ccolor%7Bred%7D%7Bv_1%7D%5Cto+v_6%5Cto+v_2%5Cto+v_3%5CRightarrow+%5Cmathrm%7Bshort%7D%5Cleft%5B3%5Cright%5D%3Dw_%7B1%2C6%7D%2Bw_%7B6%2C2%7D%2Bw_%7B2%2C3%7D%3D12%5Ctag%7B3%7D%5C%5C+%26%5Cmathrm%7Bshort%7D%5Cleft%5B4%5Cright%5D%3A%5Ccolor%7Bred%7D%7Bv_1%7D%5Cto+v_6%5Cto+v_4%5CRightarrow+%5Cmathrm%7Bshort%7D%5Cleft%5B4%5Cright%5D%3Dw_%7B1%2C6%7D%2Bw_%7B6%2C4%7D%3D9%5Ctag%7B4%7D%5C%5C+%26%5Cmathrm%7Bshort%7D%5Cleft%5B5%5Cright%5D%3A%5Ccolor%7Bred%7D%7Bv_1%7D%5Cto+v_6%5Cto+v_5%5CRightarrow+%5Cmathrm%7Bshort%7D%5Cleft%5B5%5Cright%5D%3Dw_%7B1%2C6%7D%2Bw_%7B6%2C5%7D%3D4%5Ctag%7B5%7D%5C%5C+%26%5Cmathrm%7Bshort%7D%5Cleft%5B6%5Cright%5D%3A%5Ccolor%7Bred%7D%7Bv_1%7D%5Cto+v_6%5CRightarrow+%5Cmathrm%7Bshort%7D%5Cleft%5B6%5Cright%5D%3Dw_%7B1%2C6%7D%3D3%5Ctag%7B6%7D+%5Cend%7Balign%2A%7D)

其中， ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bshort%7D%5B%5Cbullet%5D) 表示从源点 ![[公式]](https://www.zhihu.com/equation?tex=s%28%5Ccolor%7Bred%7D%7Bv_1%7D%29) 出发，到 ![[公式]](https://www.zhihu.com/equation?tex=V%5Csetminus%5C%7B%5Ccolor%7Bred%7D%7Bv_1%7D%5C%7D) 中的顶点 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbullet) 的最短路径。

> 注：**最短路径可以理解为所有可能的路径中总权和最小的那一条路径**。举一个再简单不过的例子：你开车从城市 ![[公式]](https://www.zhihu.com/equation?tex=A) 到城市 ![[公式]](https://www.zhihu.com/equation?tex=B) ，假设有很多条路可以走，最短的那条路就是最短路径，总权和可以理解为总的公里数。

以上是我们通过观察和计算比对出来的最短路径，下面我们就来看看Dijkstra 算法是如何帮助我们找到这些所有的最短路径的。

在开始之前，有几个概念需要明确一下。

- 定义一个集合 ![[公式]](https://www.zhihu.com/equation?tex=S) ，如果集合 ![[公式]](https://www.zhihu.com/equation?tex=V%5Csetminus+%5C%7Bs%5C%7D) 中的某个顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 在集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中了，那么就说明从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i%5Cin+V%5Csetminus+%5C%7Bs%5C%7D) 的最短路径已经被找到，而在算法一开始的时候，集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中只有源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 。即：

![[公式]](https://www.zhihu.com/equation?tex=S%3A%3D%5Cleft%5C%7Bv_i%5Cin+V%5C%2C%3A%5C%2C+%5Cmathrm%7Bthe%5C%2C%5C%2C+shortest%5C%2C%5C%2Cpath%5C%2C%5C%2Cof%5C%2C%5C%2Cvertex%5C%2C%5C%2C%7Dv_i%5C%2C%5C%2C%5Cmathrm%7Bhas%5C%2C%5C%2C+been%5C%2C%5C%2C+found%7D%5Cright%5C%7D%5Ctag%7B7%7D)

而且，当且仅当 ![[公式]](https://www.zhihu.com/equation?tex=S%3DV) 的时候算法执行完毕。此时顶点集 ![[公式]](https://www.zhihu.com/equation?tex=V) 中的所有元素都被放进了集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 种，也就是说除了源点以外的所有从源点出发到其余所有顶点的最短路径已被找到。

> 注：当然了，你也可以认为源点到自己本身的最短路径也被找到了。对于任意一个**无自环的**源点，它到自己本身的最短路径都是 ![[公式]](https://www.zhihu.com/equation?tex=0) 。

- 下面这个概念可能稍微有些抽象，不过没有关系，这里理解不了的话我们一会讲例子的时候会进行具体说明。这个概念叫做**从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i%5Cin+V)** （一开始 ![[公式]](https://www.zhihu.com/equation?tex=v_i%5Cnotin+S) ）**的相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径**。 即从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i%5Cin+V) 的路径**中间**只能经过已经包含在集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中的顶点，而不能经过其余的还未在集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中的顶点。而这个相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径的长度我们记作：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%5Ctag%7B8%7D)

而我们之前的 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bshort%7D%5B%5Cbullet%5D%5Cleft%28%5CLeftrightarrow%5Cmathrm%7Bshort%7D%5Bs%2Cv_i%5D%5Cright%29) 表示的是**全局的**从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i%5Cin+V%5Csetminus%5Cleft%5C%7Bs%5Cright%5C%7D) 的最短路径，这个最短路径没有限制“必须在路径中间只能经过已经包含在集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中的顶点”，这个全局的最短路径才是我们要的最终解。所以，一般有关系：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%5Cge%5Cmathrm%7Bshort%7D%5Bs%2Cv_i%5D%5Ctag%7B9%7D)

而我们的Dijkstra 算法要做的就是通过不断计算 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D) 进而不断的扩充集合 ![[公式]](https://www.zhihu.com/equation?tex=S) ，当集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 不断被扩充的时候，相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径会越来越短，直到 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 入集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 之时，此时我们便得到了 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bshort%7D%5Bs%2Cv_i%5D) ，且此时有 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%3D%5Cmathrm%7Bshort%7D%5Bs%2Cv_i%5D+) 。下面我们来看看算法的设计思想：

> **输入**：赋权有向图 ![[公式]](https://www.zhihu.com/equation?tex=G%3D%28V%2C%5C%2CE%2C%5C%2CW%29%2C%5Cquad+V%3D%5Cleft%5C%7Bv_1%2Cv_2%2C%5Cldots%2Cv_n%5Cright%5C%7D%2C%5Cquad+s%3A%3Dv_1) 。
> **输出**：从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到所有的 ![[公式]](https://www.zhihu.com/equation?tex=v_i%5Cin+V%5Csetminus%5C%7Bs%5C%7D) 的最短路径。
> ![[公式]](https://www.zhihu.com/equation?tex=1.) 初始 ![[公式]](https://www.zhihu.com/equation?tex=S%3D%5Cleft%5C%7Bv_1%5Cright%5C%7D) ；
> ![[公式]](https://www.zhihu.com/equation?tex=2.) 对于 ![[公式]](https://www.zhihu.com/equation?tex=v_i%5Cin+V-S) ，计算 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D) ；
> ![[公式]](https://www.zhihu.com/equation?tex=3.) 选择 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmin_%7Bv_j+%5Cin+V%7D%5C%2C%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D) ，并将这个 ![[公式]](https://www.zhihu.com/equation?tex=v_j) 放进集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中，更新 ![[公式]](https://www.zhihu.com/equation?tex=V-S) 中的顶点的 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D) 值；
> ![[公式]](https://www.zhihu.com/equation?tex=4.) 重复 ![[公式]](https://www.zhihu.com/equation?tex=1) ，直到 ![[公式]](https://www.zhihu.com/equation?tex=S%3DV) 。

然后是Dijkstra 算法的伪码：

![[公式]](https://www.zhihu.com/equation?tex=%5Cboxed%7B%5Clarge%5Cbegin%7Balign%2A%7D+%26%5Clarge%7B%5Cbm%7B%5Crm%7BAlgorithm%3ADijkstra%7D%7D%7D%5C%5C+%26%5C%5C+%26%5Cbm%7B%5Cmathrm%7BInput%3A%7D%7D%5Cmathrm%7BDirected%5C%2C%5C%2C+graph%5C%2C%5C%2C%7DG%3D%28V%2CE%2CW%29%5C%2C%5C%2C%5Cmathrm%7Bwith%5C%2C%5C%2C+weight%7D%5C%5C+%26%5C%5C+%26%5Cbm%7B%5Cmathrm%7BOutput%3A%7D%7D%5Cmathrm%7BAll%5C%2C%5C%2C+the%5C%2C%5C%2Cshortest%5C%2C%5C%2Cpaths%5C%2C%5C%2C+from%5C%2C%5C%2C+the%5C%2C%5C%2C+source%5C%2C%5C%2Cvertex%5C%2C%5C%2C%7Ds%5Cmathrm%7B%5C%2C%5C%2Cto%5C%2C%5C%2Cevery%5C%2C%5C%2Cvertex%5C%2C%5C%2C%7Dv_i%5Cin+V%5Csetminus%5Cleft%5C%7Bs%5Cright%5C%7D%5C%5C+%26%5C%5C+%261%3AS%5Cleftarrow+%5Cleft+%5C%7B+s+%5Cright+%5C%7D%5C%5C+%262%3A%5Cmathrm%7Bdist%7D%5Bs%2Cs%5D%5Cleftarrow+0%5C%5C+%263%3A%5Cbm%7B%5Cmathrm%7Bfor%7D%7D%5C%2C%5C%2C+v_i%5Cin+V-%5Cleft+%5C%7B+s+%5Cright+%5C%7D%5C%2C%5C%2C%5Cbm%7B%5Cmathrm%7Bdo%7D%7D%5C%5C+%264%3A%5Cquad%5C%2C%5C%2C+%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%5Cleftarrow+w%28s%2Cv_i%29%5C%5C+%26%5Cquad+%5C%2C%5C%2C%5C%2C%5Cquad+%28%5Cmathrm%7Bwhen%5C%2C%5C%2C%7Dv_i%5C%2C%5C%2C%5Cmathrm%7Bnot%5C%2C%5C%2Cfound%7D%2C%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%5Cleftarrow+%5Cinfty%29%5C%5C+%265%3A%5Cbm%7B%5Cmathrm%7Bwhile%7D%7D%5C%2C%5C%2CV-S%5Cne%5Cvarnothing+%5C%2C%5C%2C%5Cbm%7B%5Cmathrm%7Bdo%7D%7D%5C%5C+%266%3A%5Cquad%5C%2C%5C%2C%5C%2C%5C%2C+%5Cmathrm%7Bfind%5C%2C%5C%2C%7D%5Cmin_%7Bv_j%5Cin+V%7D%5C%2C%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%5C%2C%5C%2C%5Cmathrm%7Bfrom%5C%2C%5C%2C+the%5C%2C%5C%2C+set%5C%2C%5C%2C%7DV-S%5C%5C+%267%3A%5Cquad%5C%2C%5C%2C%5C%2C%5C%2C+S%5Cleftarrow+S%5Ccup+%5Cleft%5C%7Bv_j%5Cright%5C%7D%5C%5C+%268%3A%5C%2C%5C%2C%5C%2C%5C%2C%5Cquad+%5Cbm%7B%5Cmathrm%7Bfor%5C%2C%5C%2C%7D%7Dv_i%5Cin+V-S%5C%2C%5C%2C%5Cbm%7B%5Cmathrm%7Bdo%7D%7D%5C%5C+%269%3A%5C%2C%5C%2C%5C%2C%5C%2C%5C%2C%5C%2C%5C%2C%5Cquad%5Cquad+%5Cbm%7B%5Cmathrm%7Bif%5C%2C%5C%2C%7D%7D%5Cmathrm%7Bdist%7D%5Bs%2Cv_j%5D%2Bw_%7Bj%2Ci%7D%3C%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%5C%2C%5C%2C%5Cbm%7B%5Cmathrm%7Bthen%7D%7D%5C%5C+%2610%3A%5C%2C%5C%2C%5C%2C%5C%2C%5C%2C%5Cquad%5Cquad%5Cquad+%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%5Cleftarrow+%5Cmathrm%7Bdist%7D%5Bs%2Cv_j%5D%2Bw_%7Bj%2Ci%7D+%5Cend%7Balign%2A%7D%7D%5Ctag%7B10%7D)

下面我们来解释一下这个伪码：

![[公式]](https://www.zhihu.com/equation?tex=1%3A) 算法初始，将选择的源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 放进集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中；

![[公式]](https://www.zhihu.com/equation?tex=2%3A) 无自环的源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到自己的最短路径为 ![[公式]](https://www.zhihu.com/equation?tex=0) ；

![[公式]](https://www.zhihu.com/equation?tex=3%3A) 当顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 不在集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中时（此时集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中仍只有源点 ![[公式]](https://www.zhihu.com/equation?tex=s) ），开始进入循环；

![[公式]](https://www.zhihu.com/equation?tex=4%3A) 将源点 ![[公式]](https://www.zhihu.com/equation?tex=+s) 与点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 之间的权值赋给 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D) 。由于是有向图，所以当源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 不指向任何其他集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 外的顶点时， ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bs%2Cv_i%5D%3D%5Cinfty) 。可以理解为**此时**从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 出发，**暂时**是达到不了 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 的。不过后来随着集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的扩充，从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 出发一定能到达所有的顶点。一会我们讲解例子时会出现这种情况。此时第一个 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bfor%7D%7D) 循环结束。

![[公式]](https://www.zhihu.com/equation?tex=5%3A) 如果集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) 不是空集，则进入循环；

![[公式]](https://www.zhihu.com/equation?tex=6%3A) 选出经过第一个 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bfor%7D%7D) 循环之后的，在集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) 中的，且相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径中距离最短的那个顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_j) ;

![[公式]](https://www.zhihu.com/equation?tex=7+%3A) 将这个顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_j) 并入集合 ![[公式]](https://www.zhihu.com/equation?tex=S) ，从而达到扩充集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的目的；

![[公式]](https://www.zhihu.com/equation?tex=8%3A) 将顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 并入集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 之后可能会对其他顶点相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路的长度会有影响，所以进入内 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bfor%7D%7D) 循环对有影响的进行更新；

![[公式]](https://www.zhihu.com/equation?tex=9%3A) 即如果从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到我们在第 ![[公式]](https://www.zhihu.com/equation?tex=6) 步选出的顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_j) 的相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径的长度再加上顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_j) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 之间的距离 ![[公式]](https://www.zhihu.com/equation?tex=w_%7Bi%2Cj%7D) 还要小于源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 的相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径的长度还要短的话；

![[公式]](https://www.zhihu.com/equation?tex=10%3A+) 则将源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 的相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径更新成源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 到我们在第 ![[公式]](https://www.zhihu.com/equation?tex=6) 步选出的顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_j) 的相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径再加上顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_j) 到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_i) 之间的权值 ![[公式]](https://www.zhihu.com/equation?tex=w_%7Bi%2Cj%7D) 。

下面我们开始讲例子，我们还是以图片1中的赋权有向图进行说明。

![img](https://pic3.zhimg.com/80/v2-3efe1805d5487018b65b470643f463de_720w.jpg)

​																												图片4

首先我们还是选择 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) 为原点 ![[公式]](https://www.zhihu.com/equation?tex=s) ，那么在算法的开始， ![[公式]](https://www.zhihu.com/equation?tex=S%3D%5C%7B%5Ccolor%7Bred%7D%7Bv_1%7D%5C%7D) 。之后我们计算除了 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) 以外的其余顶点到 ![[公式]](https://www.zhihu.com/equation?tex=s%3D%5Ccolor%7Bred%7D%7Bv_1%7D) 的距离 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bv_2%2Cv_1%5D%5Csim+%5Cmathrm%7Bdist%7D%5Bv_6%2Cv_1%5D) ，即寻找所有的除了 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) 以外的所有顶点相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路，即从 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D%7B%7D) 出发，到达所有顶点且只允许通过顶点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D%7B%7D)（因为此时集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中只有 ![[公式]](https://www.zhihu.com/equation?tex=v_1) 这一个元素）的最短路径。这是我们的算法中的第一个 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bfor%7D%7D) 循环在做的事情。这时候我们发现想要**只通过**顶点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D%7B%7D) 而到达顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_4%2Cv_3%2Cv_5) 都是不可能的，所以我们有：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bmatrix%7D+%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%3Dw_%7B1%2C2%7D%3D10+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_3%5D%3D%5Cinfty+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_4%5D%3D%5Cinfty+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_5%5D%3D%5Cinfty+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_6%5D%3Dw_%7B1%2C6%7D%3D3+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bred%7D%7Bv_1%7D%5D%3D0+%5Cend%7Bmatrix%7D%5Ctag%7B11%7D)

而 ![[公式]](https://www.zhihu.com/equation?tex=v_4%2Cv_3%2Cv_5) 就是算法中所说的暂时到达不了的顶点了。现在算法的前四步已经结束了，现在开始第五步检验集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) 是否是空集，这里显然不是，这里：

![[公式]](https://www.zhihu.com/equation?tex=V-S%3D%5Cleft%5C%7Bv_2%2Cv_3%2Cv_4%2Cv_5%2Cv_6%5Cright%5C%7D%5Ctag%7B12%7D+)

现在进行第六步。第六步是选出经过第一个 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bfor%7D%7D) 循环之后的，在集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) 中的，且相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径中距离最短的那个顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_j)。那我们看看在式 ![[公式]](https://www.zhihu.com/equation?tex=%2811%29) 中那个顶点距离源点 ![[公式]](https://www.zhihu.com/equation?tex=v_1) 最短就好了，显然是 ![[公式]](https://www.zhihu.com/equation?tex=v_6) ，所以，我们这里选择的 ![[公式]](https://www.zhihu.com/equation?tex=v_j%3Dv_6) 。

那么第七步就是将 ![[公式]](https://www.zhihu.com/equation?tex=v_6) 放进集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中了。此时集合 ![[公式]](https://www.zhihu.com/equation?tex=S%3D%5Cleft%5C%7Bv_1%2Cv_6%5Cright%5C%7D) 。这就是说明从源点 ![[公式]](https://www.zhihu.com/equation?tex=s) 出发，到顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_6) 的最短路径已经被找到了。

下面我用绿色表示被放入集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中的顶点：

![img](https://pic2.zhimg.com/80/v2-75622c3b71863d77ba7ee5cf4527dfad_720w.jpg)

​																									图片5：顶点v_6被加进集合S中。

![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) 的颜色我就不变了，因为它一直都在集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中。此时：

![[公式]](https://www.zhihu.com/equation?tex=S%3D%5C%7B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5C%7D%5Ctag%7B13%7D)

这就说明下次在找相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径的时候 ![[公式]](https://www.zhihu.com/equation?tex=S) 中就有两个点可以被通过了，这样也许就会使得一些原来到达不了的顶点由于可以多经过一个点而到达，这也就是算法中所说的当我将一个新的顶点并入集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 之后，其他的在集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) 以外的顶点的相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径的长度可能会发生改变，因为有些原来暂时到达不了的顶点现在可以到达了。具体的来讲，我们有：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bmatrix%7D+%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%3D5+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_3%5D%3D%5Cinfty+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_4%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C4%7D%3D9+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_5%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C5%7D%3D4+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%3Dw_%7B1%2C6%7D%3D3+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bred%7D%7Bv_1%7D%5D%3D0+%5Cend%7Bmatrix%7D%5Ctag%7B14%7D)

这个更新步骤我也来详细是说一下，这是算法第八到第十步所做的事情。比如 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D) ，一开始在集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中只有源点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) ，而找到 ![[公式]](https://www.zhihu.com/equation?tex=v_2) 相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径只能通过顶点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) ，这样我们在式 ![[公式]](https://www.zhihu.com/equation?tex=%2811%29) 中所得到 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%3Dw_%7B2%2C1%7D%3D10) 。但是当顶点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bgreen%7D%7Bv_6%7D) 也进入到集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 之后我们再找 ![[公式]](https://www.zhihu.com/equation?tex=v_2) 相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径时就可以先通过顶点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bred%7D%7Bv_1%7D) 然后到顶点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bgreen%7D%7Bv_6%7D) ，最后再到 ![[公式]](https://www.zhihu.com/equation?tex=v_2) 。现在这两种走法都可以，但是算法究竟选择哪种算法还是要判断哪种走法距离最短，即比较 ：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%2C%5Cquad%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%5Ctag%7B15%7D)

之间的大小关系，谁小算法就选择谁。经过比较发现：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%3D10%3E%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%3D5%5Ctag%7B16%7D)

所以选择后者。再比如原来达到不了的 ![[公式]](https://www.zhihu.com/equation?tex=+v_4) ，现在由于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中多了顶点 ![[公式]](https://www.zhihu.com/equation?tex=%5Ccolor%7Bgreen%7D%7Bv_6%7D) 变得可以达到了，即：

![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_4%5D%3D%5Cinfty%5Cgg%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C4%7D%3D9%5Ctag%7B17%7D)

所以算法肯定选择后者。不过此时算法也没得可选，先要到达顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_4) 就必须走这条路。

其余发生变化的顶点分析类似，大家可以自己试试。

现在算法从头到尾被执行了一遍了，然后我们回到第五步判断 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bwhile%7D%7D) 循环的条件还是否为真，此时：

![[公式]](https://www.zhihu.com/equation?tex=V-S%3D%5Cleft%5C%7Bv_2%2Cv_3%2Cv_4%2Cv_5%5Cright%5C%7D%5Cne%5Cvarnothing%5Ctag%7B18%7D)

所以再执行 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bwhile%7D%7D) 循环，由第六步从式 ![[公式]](https://www.zhihu.com/equation?tex=%2814%29) 中选择出属于集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) ，且相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径中距离最短的那个顶点为 ![[公式]](https://www.zhihu.com/equation?tex=v_j) ，所以，这里我们选择的 ![[公式]](https://www.zhihu.com/equation?tex=v_j%3Dv_5) 。然后第七步 将 ![[公式]](https://www.zhihu.com/equation?tex=v_5) 放进集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 。此时，集合 ![[公式]](https://www.zhihu.com/equation?tex=S%3D%5Cleft%5C%7B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%2C%5Ccolor%7Bgreen%7D%7Bv_5%7D%5Cright%5C%7D) ：

![img](https://pic2.zhimg.com/80/v2-5200e361ff0071b378ce43a614c8b3c5_720w.jpg)

​																						图片6：v_5被放进集合S中。

此时我们有：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bmatrix%7D+%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%3D5+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_3%5D%3D%5Cinfty+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_4%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C4%7D%3D9+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_5%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C5%7D%3D4+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%3Dw_%7B1%2C6%7D%3D3+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bred%7D%7Bv_1%7D%5D%3D0+%5Cend%7Bmatrix%7D%5Ctag%7B19%7D)

可见这次没有发生更新，且此时的：

![[公式]](https://www.zhihu.com/equation?tex=V-S%3D%5Cleft%5C%7Bv_2%2Cv_3%2Cv_4%5Cright%5C%7D%5Cne%5Cvarnothing%5Ctag%7B20%7D)

所以再执行 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bwhile%7D%7D) 循环，由第六步从式 ![[公式]](https://www.zhihu.com/equation?tex=%2819%29) 中选择出属于集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) ，且相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径中距离最短的那个顶点为 ![[公式]](https://www.zhihu.com/equation?tex=v_j) ，所以，这里我们选择的 ![[公式]](https://www.zhihu.com/equation?tex=v_j%3Dv_2) 。然后第七步 将 ![[公式]](https://www.zhihu.com/equation?tex=v_2) 放进集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 。此时，集合 ![[公式]](https://www.zhihu.com/equation?tex=S%3D%5Cleft%5C%7B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%2C%5Ccolor%7Bgreen%7D%7Bv_5%7D%2C%5Ccolor%7Bgreen%7D%7Bv_2%7D%5Cright%5C%7D) ：

![img](https://pic2.zhimg.com/80/v2-fda0caba25cac11a229bb76319173aad_720w.jpg)

​																								图片7：v_2被放进集合S中。

此时我们有：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bmatrix%7D+%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%3D5+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_3%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%2Bw_%7B2%2C3%7D%3D12+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_4%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C4%7D%3D9+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_5%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C5%7D%3D4+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%3Dw_%7B1%2C6%7D%3D3+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bred%7D%7Bv_1%7D%5D%3D0+%5Cend%7Bmatrix%7D%5Ctag%7B21%7D)

可见这次在顶点 ![[公式]](https://www.zhihu.com/equation?tex=v_3) 处发生了更新（至于为什么 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_3%5D%5Cne+17) 大家可以自己分析一下试试），且此时的：

![[公式]](https://www.zhihu.com/equation?tex=V-S%3D%5Cleft%5C%7Bv_3%2Cv_4%5Cright%5C%7D%5Cne%5Cvarnothing%5Ctag%7B22%7D)

所以再执行 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bwhile%7D%7D) 循环，由第六步从式 ![[公式]](https://www.zhihu.com/equation?tex=%2819%29) 中选择出属于集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) ，且相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径中距离最短的那个顶点为 ![[公式]](https://www.zhihu.com/equation?tex=v_j) ，所以，这里我们选择的 ![[公式]](https://www.zhihu.com/equation?tex=v_j%3Dv_4) 。然后第七步 将 ![[公式]](https://www.zhihu.com/equation?tex=v_4) 放进集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 。此时，集合 ![[公式]](https://www.zhihu.com/equation?tex=S%3D%5Cleft%5C%7B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%2C%5Ccolor%7Bgreen%7D%7Bv_5%7D%2C%5Ccolor%7Bgreen%7D%7Bv_2%7D%2C%5Ccolor%7Bgreen%7D%7Bv_4%7D%5Cright%5C%7D) ：

![img](https://pic3.zhimg.com/80/v2-11a7463fec71c81e326f4d88e0135e26_720w.jpg)

​																								图片8：v_4被放进集合S中。

此时我们有：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bmatrix%7D+%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%3D5+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_3%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%2Bw_%7B2%2C3%7D%3D12+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_4%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C4%7D%3D9+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_5%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C5%7D%3D4+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%3Dw_%7B1%2C6%7D%3D3+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bred%7D%7Bv_1%7D%5D%3D0+%5Cend%7Bmatrix%7D%5Ctag%7B23%7D)

可见这次并未发生更新，且此时的：

![[公式]](https://www.zhihu.com/equation?tex=V-S%3D%5Cleft%5C%7Bv_3%5Cright%5C%7D%5Cne%5Cvarnothing%5Ctag%7B24%7D)

所以再执行 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bwhile%7D%7D) 循环，由第六步从式 ![[公式]](https://www.zhihu.com/equation?tex=%2819%29) 中选择出属于集合 ![[公式]](https://www.zhihu.com/equation?tex=V-S) ，且相对于集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 的最短路径中距离最短的那个顶点为 ![[公式]](https://www.zhihu.com/equation?tex=v_j) ，所以，这里我们选择的 ![[公式]](https://www.zhihu.com/equation?tex=v_j%3Dv_3) （至剩下 ![[公式]](https://www.zhihu.com/equation?tex=v_3) 可以被选择了）。然后第七步 将 ![[公式]](https://www.zhihu.com/equation?tex=v_3) 放进集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 。此时，集合 ![[公式]](https://www.zhihu.com/equation?tex=S%3D%5Cleft%5C%7B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%2C%5Ccolor%7Bgreen%7D%7Bv_5%7D%2C%5Ccolor%7Bgreen%7D%7Bv_2%7D%2C%5Ccolor%7Bgreen%7D%7Bv_4%7D%2C%5Ccolor%7Bgreen%7D%7Bv_3%7D%5Cright%5C%7D) ：

![img](https://pic1.zhimg.com/80/v2-253f806d333345fdde806e2988a40a00_720w.jpg)

​																							图片9：v_4被放进集合S中。

此时我们有：

![[公式]](https://www.zhihu.com/equation?tex=%5Cbegin%7Bmatrix%7D+%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_2%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%3D5+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_3%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C2%7D%2Bw_%7B2%2C3%7D%3D12+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_4%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C4%7D%3D9+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2Cv_5%5D%3D%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%2Bw_%7B6%2C5%7D%3D4+%5C%5C++%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bgreen%7D%7Bv_6%7D%5D%3Dw_%7B1%2C6%7D%3D3+%26%5Cmathrm%7Bdist%7D%5B%5Ccolor%7Bred%7D%7Bv_1%7D%2C%5Ccolor%7Bred%7D%7Bv_1%7D%5D%3D0+%5Cend%7Bmatrix%7D%5Ctag%7B25%7D)

这是最后一次了，且这次并未发生更新，且此时的：

![[公式]](https://www.zhihu.com/equation?tex=V-S%3D%5Cleft%5C%7B%5Cright%5C%7D%3D%5Cvarnothing%5Ctag%7B26%7D)

则不满足算法中的 ![[公式]](https://www.zhihu.com/equation?tex=%5Cbm%7B%5Crm%7Bwhile%7D%7D) 循环的条件，循环结束，算法结束。显然，此时有 ![[公式]](https://www.zhihu.com/equation?tex=V%3DS) 。

最后我们来看一看Dijkstra 算法的时间复杂度。

Dijkstra 算法的时间复杂度是 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%28nm%29) 。其中：

![[公式]](https://www.zhihu.com/equation?tex=n%3D%5Cleft%7C+V%5Cright%7C%2C%5Cquad+m%3D%5Cleft%7C+E%5Cright%7C%5Ctag%7B23%7D)

分别为赋权有向图中的顶点个数和边的个数。Dijkstra 算法的时间复杂度是 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%28nm%29) 是因为算法总共进行 ![[公式]](https://www.zhihu.com/equation?tex=%28n-1%29) 步，每一步选出一个具有最小 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathrm%7Bdist%7D%5Bs%2C%5Cbullet%5D) 值的顶点放入集合 ![[公式]](https://www.zhihu.com/equation?tex=S) 中，需要 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%28m%29%7D) 的时间。

而选择基于堆实现的优先队列数据结构，可将Dijkstra 算法的时间复杂度降为 ![[公式]](https://www.zhihu.com/equation?tex=%5Cmathcal%7BO%7D%28+m%5Clog+n%29) 。

### 例题：

#### 1342：【例4-1】最短路径问题

[ybt 1342：【例4-1】最短路径问题](http://ybt.ssoier.cn:8088/problem_show.php?pid=1342)

时间限制: 1000 ms     内存限制: 65536 KB
提交数: 16345   通过数: 7408

**【题目描述】**

平面上有n个点（n<=100），每个点的坐标均在-10000~10000之间。其中的一些点之间有连线。

若有连线，则表示可从一个点到达另一个点，即两点间有通路，通路的距离为两点间的直线距离。现在的任务是找出从一点到另一点之间的最短路径。

**【输入】**

共n+m+3行，其中:

第一行为整数n。

第2行到第n+1行（共n行） ，每行两个整数x和y，描述了一个点的坐标。

第n+2行为一个整数m，表示图中连线的个数。

此后的m 行，每行描述一条连线，由两个整数i和j组成，表示第i个点和第j个点之间有连线。

最后一行：两个整数s和t，分别表示源点和目标点。

**【输出】**

一行，一个实数（保留两位小数），表示从s到t的最短路径长度。

**【输入样例】**

```
5  0 0 2 0 2 2 0 2 3 1 5  1 2 1 3 1 4 2 5 3 5 1 5
```

**【输出样例】**

```
3.41
```

#### [743. 网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)

难度中等538

有 `n` 个网络节点，标记为 `1` 到 `n`。

给你一个列表 `times`，表示信号经过 **有向** 边的传递时间。 `times[i] = (ui, vi, wi)`，其中 `ui` 是源节点，`vi` 是目标节点， `wi` 是一个信号从源节点传递到目标节点的时间。

现在，从某个节点 `K` 发出一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2019/05/23/931_example_1.png)

```
输入：times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2
输出：2
```

**示例 2：**

```
输入：times = [[1,2,1]], n = 2, k = 1
输出：1
```

**示例 3：**

```
输入：times = [[1,2,1]], n = 2, k = 2
输出：-1
```

 

**提示：**

- `1 <= k <= n <= 100`
- `1 <= times.length <= 6000`
- `times[i].length == 3`
- `1 <= ui, vi <= n`
- `ui != vi`
- `0 <= wi <= 100`
- 所有 `(ui, vi)` 对都 **互不相同**（即，不含重复边）

**方法：Dijkstra 模板题**

堆的写法复杂度如下：

时间复杂度：$$O(mlogm)$$，其中 m 是数组 $$\textit{times}$$ 的长度。

空间复杂度：$$O(n+m)$$。

值得注意的是，由于本题边数远大于点数，是一张稠密图，因此在运行时间上，枚举写法要略快于堆的写法

C++版代码：

```c++
class Solution {
private:
    typedef pair<int, int> pii;
    const int INF = 1e5;
    struct Edge{
        //int from;
        int to;
        int weight;
    };
    vector<vector<Edge>> graph;
    static bool cmp(const pair<int, int> a, const pair<int, int> b) {
        return a.first > b.first;
    }
    vector<int> dijkstra(int s, int n, vector<vector<Edge>>& G) {
        vector<int> dist(n + 1, INF);
        dist[s] = 0;
        priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> pque(cmp);
        //priority_queue<pii, vector<pii>, greater<pii>> pque;
        pque.push({0, s});
        while (!pque.empty()) {
            int dis = pque.top().first;
            int v = pque.top().second;
            pque.pop();
            if (dis > dist[v]) continue;
            for (auto e : G[v]) {
                if (dist[e.to] > dist[v] + e.weight) {
                    dist[e.to] = dist[v] + e.weight;
                    pque.push({dist[e.to], e.to});
                }
            }
        }
        return dist;
    }
public:
    int networkDelayTime(vector<vector<int>>& times, int n, int k) {
        graph = vector<vector<Edge>>(n + 1);
        for (auto edge : times) {
            graph[edge[0]].push_back({edge[1], edge[2]}); // 初始化邻接表
        }
        auto dist = dijkstra(k, n, graph);
        int res = 0;
        for (int i = 1; i < dist.size(); i++) {
            res = max(res, dist[i]);
        }
        return res == INF ? -1 : res;
    }
}; // 2022.4.29
```



#### [2203. 得到要求路径的最小带权子图](https://leetcode-cn.com/problems/minimum-weighted-subgraph-with-the-required-paths/)

给你一个整数 n ，它表示一个 带权有向 图的节点数，节点编号为 0 到 n - 1 。

同时给你一个二维整数数组 edges ，其中 edges[i] = [fromi, toi, weighti] ，表示从 fromi 到 toi 有一条边权为 weighti 的 有向 边。

最后，给你三个 互不相同 的整数 src1 ，src2 和 dest ，表示图中三个不同的点。

请你从图中选出一个 边权和最小 的子图，使得从 src1 和 src2 出发，在这个子图中，都 可以 到达 dest 。如果这样的子图不存在，请返回 -1 。

子图 中的点和边都应该属于原图的一部分。子图的边权和定义为它所包含的所有边的权值之和。

 

示例 1：



输入：n = 6, edges = [[0,2,2],[0,5,6],[1,0,3],[1,4,5],[2,1,1],[2,3,3],[2,3,4],[3,4,2],[4,5,1]], src1 = 0, src2 = 1, dest = 5
输出：9
解释：
上图为输入的图。
蓝色边为最优子图之一。
注意，子图 [[1,0,3],[0,5,6]] 也能得到最优解，但无法在满足所有限制的前提下，得到更优解。
示例 2：



输入：n = 3, edges = [[0,1,1],[2,1,1]], src1 = 0, src2 = 1, dest = 2
输出：-1
解释：
上图为输入的图。
可以看到，不存在从节点 1 到节点 2 的路径，所以不存在任何子图满足所有限制。


提示：

3 <= n <= 105
0 <= edges.length <= 105
edges[i].length == 3
0 <= fromi, toi, src1, src2, dest <= n - 1
fromi != toi
src1 ，src2 和 dest 两两不同。
1 <= weight[i] <= 105

代码部分：

```c++
class Solution {
private:
    typedef long long ll;
    typedef long double ld;
    typedef pair<int, int> pii;
    typedef pair<long long, long long> pll;
    typedef vector<int> vi;
    const ll INF = (ll)1e18;

    struct edge {
        int to, cost; // [toi, weighti]
    };
    vector<vector<edge>> G, rG;
    vector<long long> dijkstra(int s, int n, vector<vector<edge>>& S) {
        vector<long long> dist(n, INF); // 最短路径全部初始化为最大值
        dist[s] = 0; // 初始化节点 s 到节点 s 的最小路径为 0
        // priority_queue<Type, Container, Functional>
        // Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，
        // 比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式。
        priority_queue<pll, vector<pll>, greater<pll>> pque; // 优先级队列：小顶堆
        pque.push({0, s}); // {distance, vertex} {最小距离, 节点}
        while (!pque.empty()) {
            auto p = pque.top();
            pque.pop();
            ll d = p.first; // 路径长度
            ll v = p.second; // 当前中间节点 v
            // 优先级队列中会保存，从源点 s 经过中间点 j 到达节点 v 的路径长度，
            // 如果此时 dist 中已经更新的 dist[v] 比队列中临时存储的小，则队列中临时存储的该数据为冗余数据，跳过后面的处理步骤
            // 因为通过该冗余数据计算得到的路径长度一定比通过 dist 数组中存储的路径长度大
            if (dist[v] < d) continue;
            for (auto &e : S[v]) { // 遍历邻接表节点 v 的那一行
                if (dist[e.to] > dist[v] + e.cost) { // 如果源点 s 到节点 e.to 的路径长度大于经过中间节点 v 到达 e.to 的路径长度
                    dist[e.to] = dist[v] + e.cost;
                    pque.push({dist[e.to], e.to});
                }
            }
        }
        return dist;
    }
public:
    long long minimumWeight(int n, vector<vector<int>>& edges, int src1, int src2, int dest) {
        G = vector<vector<edge>>(n);
        rG = vector<vector<edge>>(n);
        for (auto &v : edges) {
            G[v[0]].push_back({v[1], v[2]}); // 邻接表[fromi, toi, weighti]
            rG[v[1]].push_back({v[0], v[2]}); // 反邻接表[toi, fromi, weighti]
        }
        auto dsrc1 = dijkstra(src1, n, G); // src1 到其他节点的最小路径
        auto dsrc2 = dijkstra(src2, n, G); // src2 到其他节点的最小路径
        auto ddest = dijkstra(dest, n, rG); // dest 到其他节点的最小路径
        /*
        for (int i = 0; i < n; i++) {
            cout<<dsrc1[i]<<" ";
        }
        */
        ll res = INF;
        for (int i = 0; i < n; i++) {
            res = min(res, dsrc1[i] + dsrc2[i] + ddest[i]); // src1 经过中间节点 i 到节点 dest 的最小路径
        }
        if (res >= INF) return -1;
        else return res;
    }
};
```

### **弗洛伊德算法(Floyd)**

![[公式]](https://www.zhihu.com/equation?tex=%5Cqquad)上一篇文章介绍了迪杰斯特拉算法(Dijkstra)。具体请看：

[土豆同学：最短路径算法——简单明了的迪杰斯特拉算法(Dijkstra)2 赞同 · 0 评论文章![img](https://pic4.zhimg.com/v2-577f60ff1796871073a50e426537d89f_180x120.jpg)](https://zhuanlan.zhihu.com/p/405185587)

Dijkstra适用于非负权图，并且一次只能从网络中找源点到任何一个节点的最短路径，而Floyd算法的应用更加广泛，可以求网络中任意两点之间的最短路径，而且弗洛伊德算法适用于负权图，这篇文章就用图和表的形式来介绍一下弗洛伊德算法！

**1 思想（原理）**

![[公式]](https://www.zhihu.com/equation?tex=%5Cqquad)Floyd算法可以给出网络中任意两个节点之间的最短路径，因此它是比Dijkstra更一般的算法。Floyd算法的思想是将![[公式]](https://www.zhihu.com/equation?tex=n)个节点的网络表示为![[公式]](https://www.zhihu.com/equation?tex=n)行![[公式]](https://www.zhihu.com/equation?tex=n)列的矩阵，而矩阵中的元素![[公式]](https://www.zhihu.com/equation?tex=%28i%2Cj%29)表示从节点![[公式]](https://www.zhihu.com/equation?tex=i)到节点![[公式]](https://www.zhihu.com/equation?tex=j)的距离![[公式]](https://www.zhihu.com/equation?tex=d_%7Bij%7D)，如果两点直接没有边相连，则相应的元素就是无穷![[公式]](https://www.zhihu.com/equation?tex=%28%5Cinfty%29).

**2 步骤**

<1> 第0步：定义初始距离矩阵![[公式]](https://www.zhihu.com/equation?tex=D_0)、节点序列矩阵![[公式]](https://www.zhihu.com/equation?tex=S_0)，如下表。对角线上用”—“表示不需要从自身到自身。

![img](https://pic3.zhimg.com/80/v2-beeb3a5524748e954db0e3a8ac46b70a_720w.jpg)

![[公式]](https://www.zhihu.com/equation?tex=%5Cqquad)这里的节点序列矩阵相当于路线表，如下表，![[公式]](https://www.zhihu.com/equation?tex=S_%7Bij%7D%3D%7Bj%7D)表示，从节点![[公式]](https://www.zhihu.com/equation?tex=i)到节点![[公式]](https://www.zhihu.com/equation?tex=j)只需经过节点![[公式]](https://www.zhihu.com/equation?tex=j)即可。

令![[公式]](https://www.zhihu.com/equation?tex=k%3D1).

<2> 一般的第k步：令第![[公式]](https://www.zhihu.com/equation?tex=k)行为枢轴行，第![[公式]](https://www.zhihu.com/equation?tex=k)列为枢轴列。对于矩阵![[公式]](https://www.zhihu.com/equation?tex=D_%7Bk-1%7D)（上一步完成后的矩阵）中对的每一个元素做三重操作。

如果满足条件：![[公式]](https://www.zhihu.com/equation?tex=+d_%7Bik%7D%2Bd_%7Bkj%7D%3Cd_%7Bij%7D)，其中(i≠k,j≠k,i≠j)

则进行下面的操作：

<\a> 用![[公式]](https://www.zhihu.com/equation?tex=d_%7Bik%7D%2Bd_%7Bkj%7D)代替矩阵![[公式]](https://www.zhihu.com/equation?tex=D_%7Bk-1%7D)中的元素![[公式]](https://www.zhihu.com/equation?tex=d_%7Bij%7D)，从而得到矩阵![[公式]](https://www.zhihu.com/equation?tex=D_k).

<\b> 用![[公式]](https://www.zhihu.com/equation?tex=k)代替矩阵![[公式]](https://www.zhihu.com/equation?tex=S_%7Bk-1%7D)中的元素![[公式]](https://www.zhihu.com/equation?tex=s_%7Bij%7D)，从而得到矩阵![[公式]](https://www.zhihu.com/equation?tex=S_k).

<\c> 令![[公式]](https://www.zhihu.com/equation?tex=k%3Dk%2B1)，如果![[公式]](https://www.zhihu.com/equation?tex=k%3Dn%2B1)，停止，否则重复<2>.

**3 栗子**

![[公式]](https://www.zhihu.com/equation?tex=%5Cqquad)直接看方法步骤会感觉太抽象，这里用一个例子进行步骤的演示. ![[公式]](https://www.zhihu.com/equation?tex=%5Cqquad)
对下图中的网络，求任意两个节点之间的最短路径，图中弧上给出了相应节点间的距离。弧(3,5)是有向的，其他边都是双边。



![img](https://pic4.zhimg.com/80/v2-ed2d844f423f68c086b5c051bd34a0c7_720w.jpg)

**迭代0**：矩阵![[公式]](https://www.zhihu.com/equation?tex=D_0)和![[公式]](https://www.zhihu.com/equation?tex=S_0)代表初始的网络。可以看到矩阵![[公式]](https://www.zhihu.com/equation?tex=D_0)除了![[公式]](https://www.zhihu.com/equation?tex=d_%7B53%7D%3D%E2%88%9E)外(因为弧(3,5)是单向弧)，![[公式]](https://www.zhihu.com/equation?tex=D_0)是对称的。

![img](https://pic1.zhimg.com/80/v2-f0268c3cd80b307afbcad2ebecbbbdd4_720w.jpg)



**迭代1**：令![[公式]](https://www.zhihu.com/equation?tex=k%3D1). ![[公式]](https://www.zhihu.com/equation?tex=D_0)矩阵中的黄色阴影表示的第1行和第1列为枢轴行和枢轴列。根据三重操作发现可以改进的元素是![[公式]](https://www.zhihu.com/equation?tex=d_%7B23%7D)和![[公式]](https://www.zhihu.com/equation?tex=d_%7B32%7D)，即

![img](https://pic2.zhimg.com/80/v2-91235769968c20b6eda4d6126a2e4165_720w.jpg)

(1) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B21%7D%2Bd_%7B13%7D%3D3%2B10%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B23%7D)中用![[公式]](https://www.zhihu.com/equation?tex=13)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B23%7D%3D1).
(2) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B31%7D%2Bd_%7B12%7D%3D10%2B3%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B32%7D)中用![[公式]](https://www.zhihu.com/equation?tex=13)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B32%7D%3D1).

此时得到![[公式]](https://www.zhihu.com/equation?tex=D_1)和![[公式]](https://www.zhihu.com/equation?tex=S_1)，得到下表

![img](https://pic3.zhimg.com/80/v2-35b5f9b0503cc8ef1625d990dc0dcdae_720w.jpg)

**迭代2**：令![[公式]](https://www.zhihu.com/equation?tex=k%3D2). ![[公式]](https://www.zhihu.com/equation?tex=D_0)矩阵中的黄色阴影表示的第2行和第2列为枢轴行和枢轴列。根据三重操作发现可以改进的元素是![[公式]](https://www.zhihu.com/equation?tex=d_%7B14%7D)和![[公式]](https://www.zhihu.com/equation?tex=d_%7B41%7D)，即

![img](https://pic3.zhimg.com/80/v2-7aea75837c95a4f93a58a79978dffa6a_720w.jpg)

(1) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B21%7D%2Bd_%7B42%7D%3D3%2B5%3D8%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B41%7D)中用![[公式]](https://www.zhihu.com/equation?tex=8)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B41%7D%3D2).
(2) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B12%7D%2Bd_%7B24%7D%3D3%2B5%3D8%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B14%7D)中用![[公式]](https://www.zhihu.com/equation?tex=8)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B14%7D%3D2).

此时得到![[公式]](https://www.zhihu.com/equation?tex=D_2)和![[公式]](https://www.zhihu.com/equation?tex=S_2)，得到下表

![img](https://pic3.zhimg.com/80/v2-faba620712d47a117dda77577e0d5db6_720w.jpg)

**迭代3**：令![[公式]](https://www.zhihu.com/equation?tex=k%3D3). ![[公式]](https://www.zhihu.com/equation?tex=D_0)矩阵中的黄色阴影表示的第3行和第3列为枢轴行和枢轴列。根据三重操作发现可以改进的元素是![[公式]](https://www.zhihu.com/equation?tex=d_%7B15%7D)和![[公式]](https://www.zhihu.com/equation?tex=d_%7B25%7D)，即

![img](https://pic4.zhimg.com/80/v2-34eed1e387b225ba51e050f2edf6de9b_720w.jpg)

(1) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B13%7D%2Bd_%7B35%7D%3D10%2B15%3D25%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B15%7D)中用![[公式]](https://www.zhihu.com/equation?tex=25)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B15%7D%3D3).
(2) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B23%7D%2Bd_%7B35%7D%3D13%2B15%3D28%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B25%7D)中用![[公式]](https://www.zhihu.com/equation?tex=28)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B25%7D%3D3).

此时得到![[公式]](https://www.zhihu.com/equation?tex=D_3)和![[公式]](https://www.zhihu.com/equation?tex=S_3)，得到下表

![img](https://pic4.zhimg.com/80/v2-3460c66dce2c90e0d836d116b968b613_720w.jpg)

**迭代4**：令![[公式]](https://www.zhihu.com/equation?tex=k%3D4). ![[公式]](https://www.zhihu.com/equation?tex=D_0)矩阵中的黄色阴影表示的第4行和第4列为枢轴行和枢轴列。根据三重操作发现可以改进的元素是![[公式]](https://www.zhihu.com/equation?tex=d_%7B15%7D)、![[公式]](https://www.zhihu.com/equation?tex=d_%7B23%7D)、![[公式]](https://www.zhihu.com/equation?tex=d_%7B25%7D)、![[公式]](https://www.zhihu.com/equation?tex=d_%7B32%7D)、![[公式]](https://www.zhihu.com/equation?tex=d_%7B35%7D)、![[公式]](https://www.zhihu.com/equation?tex=d_%7B51%7D)、![[公式]](https://www.zhihu.com/equation?tex=d_%7B52%7D)、![[公式]](https://www.zhihu.com/equation?tex=d_%7B53%7D)，即

![img](https://pic1.zhimg.com/80/v2-abdd4164a9cf96816ba1c70656914858_720w.jpg)

(1) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B14%7D%2Bd_%7B45%7D%3D8%2B4%3D12%3C25)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B15%7D)中用![[公式]](https://www.zhihu.com/equation?tex=12)代替![[公式]](https://www.zhihu.com/equation?tex=25)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B15%7D%3D4).
(2) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B24%7D%2Bd_%7B43%7D%3D5%2B6%3D11%3C13)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B23%7D)中用![[公式]](https://www.zhihu.com/equation?tex=11)代替![[公式]](https://www.zhihu.com/equation?tex=13)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B23%7D%3D4).
(3) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B24%7D%2Bd_%7B45%7D%3D5%2B4%3D9%3C28)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B25%7D)中用![[公式]](https://www.zhihu.com/equation?tex=9)代替![[公式]](https://www.zhihu.com/equation?tex=28)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B25%7D%3D4).
(4) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B34%7D%2Bd_%7B42%7D%3D6%2B5%3D11%3C13)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B25%7D)中用![[公式]](https://www.zhihu.com/equation?tex=11)代替![[公式]](https://www.zhihu.com/equation?tex=13)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B32%7D%3D4).
(5) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B34%7D%2Bd_%7B45%7D%3D6%2B4%3D10%3C15)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B35%7D)中用![[公式]](https://www.zhihu.com/equation?tex=10)代替![[公式]](https://www.zhihu.com/equation?tex=15)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B35%7D%3D4).
(6) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B41%7D%2Bd_%7B54%7D%3D8%2B4%3D12%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B51%7D)中用![[公式]](https://www.zhihu.com/equation?tex=12)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B51%7D%3D4).
(7) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B42%7D%2Bd_%7B54%7D%3D5%2B4%3D9%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B52%7D)中用![[公式]](https://www.zhihu.com/equation?tex=9)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B52%7D%3D4).
(8) ![[公式]](https://www.zhihu.com/equation?tex=d_%7B43%7D%2Bd_%7B54%7D%3D6%2B4%3D10%3C%E2%88%9E)，则在![[公式]](https://www.zhihu.com/equation?tex=d_%7B53%7D)中用![[公式]](https://www.zhihu.com/equation?tex=10)代替![[公式]](https://www.zhihu.com/equation?tex=%E2%88%9E)，并令![[公式]](https://www.zhihu.com/equation?tex=s_%7B53%7D%3D4).

此时得到![[公式]](https://www.zhihu.com/equation?tex=D_4)和![[公式]](https://www.zhihu.com/equation?tex=S_4)，得到下表

![img](https://pic3.zhimg.com/80/v2-6f51722d803a3f8fe463772dd453e806_720w.jpg)

**迭代5**：令![[公式]](https://www.zhihu.com/equation?tex=k%3D5). ![[公式]](https://www.zhihu.com/equation?tex=D_0)矩阵中的黄色阴影表示的第5行和第5列为枢轴行和枢轴列。根据三重操作发现没有可以改进的元素了。

![img](https://pic3.zhimg.com/80/v2-4768bdcb7c6e292461514acc9a767312_720w.jpg)

因此，最后得到的矩阵为：

![img](https://pic3.zhimg.com/80/v2-74da8d7ab48a0b5b3fe1bcf7a979986a_720w.jpg)

![[公式]](https://www.zhihu.com/equation?tex=%5Cqquad)这两个矩阵包含了网络中任意两个节点最短路径的所有信息。如从矩阵![[公式]](https://www.zhihu.com/equation?tex=D)中可以看出节点1到节点5的最短路径长度为12.从矩阵![[公式]](https://www.zhihu.com/equation?tex=S)中发现，节点1到节点5的中间节点是节点4，即节点1→节点4→节点5，再看节点1→节点4中间是节点2，即节点1需要通过节点2到达节点4，即节点1→节点2→节点4；而节点4可以直接到节点5，中间没有节点，因此可以得到节点1到节点5的最短路径是节点1→节点2→节点4→节点5.

#### 例题

#### [1462. 课程表 IV](https://leetcode.cn/problems/course-schedule-iv/)

难度中等81

你总共需要上 `numCourses` 门课，课程编号依次为 `0` 到 `numCourses-1` 。你会得到一个数组 `prerequisite` ，其中 `prerequisites[i] = [ai, bi]` 表示如果你想选 `bi` 课程，你 **必须** 先选 `ai` 课程。

- 有的课会有直接的先修课程，比如如果想上课程 `1` ，你必须先上课程 `0` ，那么会以 `[0,1]` 数对的形式给出先修课程数对。

先决条件也可以是 **间接** 的。如果课程 `a` 是课程 `b` 的先决条件，课程 `b` 是课程 `c` 的先决条件，那么课程 `a` 就是课程 `c` 的先决条件。

你也得到一个数组 `queries` ，其中 `queries[j] = [uj, vj]`。对于第 `j` 个查询，您应该回答课程 `uj` 是否是课程 `vj` 的先决条件。

返回一个布尔数组 `answer` ，其中 `answer[j]` 是第 `j` 个查询的答案。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg)

```
输入：numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
输出：[false,true]
解释：课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
输出：[false,false]
解释：没有先修课程对，所以每门课程之间是独立的。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg)

```
输入：numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
输出：[true,true]
```

 

**提示：**



- `2 <= numCourses <= 100`
- `0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)`
- `prerequisites[i].length == 2`
- `0 <= ai, bi <= n - 1`
- `ai != bi`
- 每一对 `[ai, bi]` 都 **不同**
- 先修课程图中没有环。
- `0 <= ui, vi <= n - 1`
- `ui != vi`

C++版代码：

```c++
class Solution {
private:
    vector<vector<int>> graph;
    const int INF = 1e9;
public:
    vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
        graph = vector<vector<int>>(numCourses, vector<int>(numCourses, INF));
        for (auto edge : prerequisites) {
            graph[edge[0]][edge[1]] = 1;
        }
        
        for (int k = 0; k < numCourses; k++) {
            for (int i = 0; i < numCourses; i++) {
                for (int j = 0; j < numCourses; j++) {
                    if (graph[i][k] + graph[k][j] < graph[i][j]) {
                        graph[i][j] = graph[i][k] + graph[k][j];
                    }
                }
            }
        }
        vector<bool> res(queries.size(), false);
        for (int i = 0; i < queries.size(); i++) {
            int v = queries[i][0];
            int w = queries[i][1];
            if (graph[v][w] != INF) {
                res[i] = true;
            }
        }
        return res;
    }
}; // 2022.4.29
```



## 广度优先搜索

### 例题：

| 题目                                                         | 题型                                                         | 难度 | 推荐指数 | 是否刷过 | 周赛题       |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | -------- | -------- | ------------ |
| [127. 单词接龙](https://leetcode-cn.com/problems/word-ladder/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/word-ladder/solution/gong-shui-san-xie-ru-he-shi-yong-shuang-magjd/) | 困难 | 🤩🤩🤩🤩🤩    |          |              |
| [403. 青蛙过河](https://leetcode-cn.com/problems/frog-jump/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/frog-jump/solution/gong-shui-san-xie-yi-ti-duo-jie-jiang-di-74fw/) | 困难 | 🤩🤩🤩🤩🤩    |          |              |
| [417. 太平洋大西洋水流问题](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/pacific-atlantic-water-flow/solution/by-ac_oier-do7d/) | 中等 | 🤩🤩🤩🤩🤩    | 是       |              |
| [752. 打开转盘锁](https://leetcode-cn.com/problems/open-the-lock/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/open-the-lock/solution/gong-shui-san-xie-yi-ti-shuang-jie-shuan-wyr9/) | 中等 | 🤩🤩🤩🤩     |          |              |
| [773. 滑动谜题](https://leetcode-cn.com/problems/sliding-puzzle/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/sliding-puzzle/solution/gong-shui-san-xie-fa-hui-a-suan-fa-zui-d-3go8/) | 困难 | 🤩🤩🤩🤩     |          |              |
| [815. 公交路线](https://leetcode-cn.com/problems/bus-routes/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/bus-routes/solution/gong-shui-san-xie-yi-ti-shuang-jie-po-su-1roh/) | 困难 | 🤩🤩🤩🤩     |          |              |
| [847. 访问所有节点的最短路径](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/shortest-path-visiting-all-nodes/solution/gong-shui-san-xie-yi-ti-shuang-jie-bfs-z-6p2k/) | 困难 | 🤩🤩🤩🤩🤩    |          |              |
| [863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-jian-x6hak/) | 中等 | 🤩🤩🤩🤩     |          |              |
| [909. 蛇梯棋](https://leetcode-cn.com/problems/snakes-and-ladders/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/snakes-and-ladders/solution/gong-shui-san-xie-bfs-mo-ni-by-ac_oier-woh6/) | 中等 | 🤩🤩🤩🤩     |          |              |
| [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/number-of-enclaves/solution/gong-shui-san-xie-bing-cha-ji-dfs-yun-yo-oyh1/) | 中等 | 🤩🤩🤩      |          |              |
| [1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/coloring-a-border/solution/gong-shui-san-xie-tu-lun-sou-suo-zhuan-t-snvw/) | 中等 | 🤩🤩🤩🤩     |          |              |
| [1036. 逃离大迷宫](https://leetcode-cn.com/problems/escape-a-large-maze/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/escape-a-large-maze/solution/gong-shui-san-xie-bfs-gei-ding-zhang-ai-8w63o/) | 中等 | 🤩🤩🤩🤩     |          |              |
| [1162. 地图分析](https://leetcode-cn.com/problems/as-far-from-land-as-possible/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/as-far-from-land-as-possible/solution/gong-shui-san-xie-ru-he-shi-yong-duo-yua-vlea/) | 中等 | 🤩🤩🤩🤩     |          |              |
| [1345. 跳跃游戏 IV](https://leetcode-cn.com/problems/jump-game-iv/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/jump-game-iv/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-q9tb1/) | 困难 | 🤩🤩🤩🤩🤩    |          |              |
| [1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/) | 多源 BFS                                                     | 中等 | 🤩🤩🤩🤩     | 是       |              |
| [2039. 网络空闲的时刻](https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/) | BFS                                                          | 中等 | 🤩🤩🤩      | 是       |              |
| [2045. 到达目的地的第二短时间](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/second-minimum-time-to-reach-destination/solution/gong-shui-san-xie-yi-ti-shuang-jie-dui-y-88np/) | 困难 | 🤩🤩🤩🤩     |          |              |
| [2059. 转化数字的最小运算数](https://leetcode-cn.com/problems/minimum-operations-to-convert-number/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/minimum-operations-to-convert-number/solution/gong-shui-san-xie-shuang-xiang-bfs-mo-ba-uckg/) | 中等 | 🤩🤩🤩🤩🤩    |          |              |
| [LCP 07. 传递信息](https://leetcode-cn.com/problems/chuan-di-xin-xi/) | DP/BFS                                                       | 简单 | 🤩🤩🤩🤩     | 是       |              |
| [2258. 逃离火灾](https://leetcode.cn/problems/escape-the-spreading-fire/) | 多源BFS + 二分                                               | 困难 |          | 是       | 第77场双周赛 |

#### [1765. 地图中的最高点](https://leetcode-cn.com/problems/map-of-highest-peak/)

难度中等101

给你一个大小为 `m x n` 的整数矩阵 `isWater` ，它代表了一个由 **陆地** 和 **水域** 单元格组成的地图。

- 如果 `isWater[i][j] == 0` ，格子 `(i, j)` 是一个 **陆地** 格子。
- 如果 `isWater[i][j] == 1` ，格子 `(i, j)` 是一个 **水域** 格子。

你需要按照如下规则给每个单元格安排高度：

- 每个格子的高度都必须是非负的。
- 如果一个格子是 **水域** ，那么它的高度必须为 `0` 。
- 任意相邻的格子高度差 **至多** 为 `1` 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）

找到一种安排高度的方案，使得矩阵中的最高高度值 **最大** 。

请你返回一个大小为 `m x n` 的整数矩阵 `height` ，其中 `height[i][j]` 是格子 `(i, j)` 的高度。如果有多种解法，请返回 **任意一个** 。

 

**示例 1：**

**![img](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82045-am.png)**

```
输入：isWater = [[0,1],[0,0]]
输出：[[1,0],[2,1]]
解释：上图展示了给各个格子安排的高度。
蓝色格子是水域格，绿色格子是陆地格。
```

**示例 2：**

**![img](https://assets.leetcode.com/uploads/2021/01/10/screenshot-2021-01-11-at-82050-am.png)**

```
输入：isWater = [[0,0,1],[1,0,0],[0,0,0]]
输出：[[1,1,0],[0,1,1],[1,2,2]]
解释：所有安排方案中，最高可行高度为 2 。
任意安排方案中，只要最高高度为 2 且符合上述规则的，都为可行方案。
```

 

**提示：**

- `m == isWater.length`
- `n == isWater[i].length`
- `1 <= m, n <= 1000`
- `isWater[i][j]` 要么是 `0` ，要么是 `1` 。
- 至少有 **1** 个水域格子。

方法：多源BFS

C++代码

```c++
class Solution {
public:
    static constexpr int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
    vector<vector<int>> highestPeak(vector<vector<int>>& isWater) {
        int row = isWater.size();
        int col = isWater[0].size();
        vector<vector<int>> height(row, vector<int>(col, -1));// -1 表示该格子尚未被访问过
        queue<pair<int, int>> Q;
        for(int i = 0; i < row; i++){
            for(int j = 0; j < col; j++){
                if(isWater[i][j]){
                    height[i][j] = 0;
                    Q.emplace(i, j);// 将所有水格子入队
                }
            }
        }
        
        while(!Q.empty()){
            int x = Q.front().first;
            int y = Q.front().second;
            Q.pop();
            for(int m = 0; m < 4; m++){
                int xx = x + directions[m][0];
                int yy = y + directions[m][1];
                if(xx >=0 && xx < row && yy >= 0 && yy < col && -1 == height[xx][yy]){ 
                    height[xx][yy] = height[x][y] + 1;
                    Q.emplace(xx, yy);
                }
            }
        }
        return height;
    }
};
/*
题目要求水域的高度必须为 0，因此水域的高度是已经确定的值，我们可以从水域出发，推导出其余格子的高度：

①计算与水域相邻的格子的高度。对于这些格子来说，其相邻格子中的最小高度即为水域的高度 0，因此这些格子的高度为 1。
②计算与高度为 1 的格子相邻的、尚未被计算过的格子的高度。对于这些格子来说，其相邻格子中的最小高度为 1，因此这些格子的高度为 2。
以此类推，计算出所有格子的高度。
*/ // 2022.1.29
```



#### [2039. 网络空闲的时刻](https://leetcode-cn.com/problems/the-time-when-the-network-becomes-idle/)

难度中等110

给你一个有 `n` 个服务器的计算机网络，服务器编号为 `0` 到 `n - 1` 。同时给你一个二维整数数组 `edges` ，其中 `edges[i] = [ui, vi]` 表示服务器 `ui` 和 `vi` 之间有一条信息线路，在 **一秒** 内它们之间可以传输 **任意** 数目的信息。再给你一个长度为 `n` 且下标从 **0** 开始的整数数组 `patience` 。

题目保证所有服务器都是 **相通** 的，也就是说一个信息从任意服务器出发，都可以通过这些信息线路直接或间接地到达任何其他服务器。

编号为 `0` 的服务器是 **主** 服务器，其他服务器为 **数据** 服务器。每个数据服务器都要向主服务器发送信息，并等待回复。信息在服务器之间按 **最优** 线路传输，也就是说每个信息都会以 **最少时间** 到达主服务器。主服务器会处理 **所有** 新到达的信息并 **立即** 按照每条信息来时的路线 **反方向** 发送回复信息。

在 `0` 秒的开始，所有数据服务器都会发送各自需要处理的信息。从第 `1` 秒开始，**每** 一秒最 **开始** 时，每个数据服务器都会检查它是否收到了主服务器的回复信息（包括新发出信息的回复信息）：

- 如果还没收到任何回复信息，那么该服务器会周期性 **重发** 信息。数据服务器 `i` 每 `patience[i]` 秒都会重发一条信息，也就是说，数据服务器 `i` 在上一次发送信息给主服务器后的 `patience[i]` 秒 **后** 会重发一条信息给主服务器。
- 否则，该数据服务器 **不会重发** 信息。

当没有任何信息在线路上传输或者到达某服务器时，该计算机网络变为 **空闲** 状态。

请返回计算机网络变为 **空闲** 状态的 **最早秒数** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/09/22/quiet-place-example1.png)

```
输入：edges = [[0,1],[1,2]], patience = [0,2,1]
输出：8
解释：
0 秒最开始时，
- 数据服务器 1 给主服务器发出信息（用 1A 表示）。
- 数据服务器 2 给主服务器发出信息（用 2A 表示）。

1 秒时，
- 信息 1A 到达主服务器，主服务器立刻处理信息 1A 并发出 1A 的回复信息。
- 数据服务器 1 还没收到任何回复。距离上次发出信息过去了 1 秒（1 < patience[1] = 2），所以不会重发信息。
- 数据服务器 2 还没收到任何回复。距离上次发出信息过去了 1 秒（1 == patience[2] = 1），所以它重发一条信息（用 2B 表示）。

2 秒时，
- 回复信息 1A 到达服务器 1 ，服务器 1 不会再重发信息。
- 信息 2A 到达主服务器，主服务器立刻处理信息 2A 并发出 2A 的回复信息。
- 服务器 2 重发一条信息（用 2C 表示）。
...
4 秒时，
- 回复信息 2A 到达服务器 2 ，服务器 2 不会再重发信息。
...
7 秒时，回复信息 2D 到达服务器 2 。

从第 8 秒开始，不再有任何信息在服务器之间传输，也不再有信息到达服务器。
所以第 8 秒是网络变空闲的最早时刻。
```

**示例 2：**

![example 2](https://assets.leetcode.com/uploads/2021/09/04/network_a_quiet_place_2.png)

```
输入：edges = [[0,1],[0,2],[1,2]], patience = [0,10,10]
输出：3
解释：数据服务器 1 和 2 第 2 秒初收到回复信息。
从第 3 秒开始，网络变空闲。
```

 

**提示：**

- `n == patience.length`
- `2 <= n <= 105`
- `patience[0] == 0`
- 对于 `1 <= i < n` ，满足 `1 <= patience[i] <= 105`
- `1 <= edges.length <= min(105, n * (n - 1) / 2)`
- `edges[i].length == 2`
- `0 <= ui, vi < n`
- `ui != vi`
- 不会有重边。
- 每个服务器都直接或间接与别的服务器相连。

方法：BFS

C++版代码：

```c++
class Solution {
public:
    int networkBecomesIdle(vector<vector<int>>& edges, vector<int>& patience) {
        int n = patience.size();       
        vector<vector<int>> adj(n);
        vector<bool> visit(n, false);  
        for (auto & v : edges) {
            adj[v[0]].emplace_back(v[1]);
            adj[v[1]].emplace_back(v[0]);
        }

        queue<int> qu;
        qu.emplace(0);
        visit[0] = true;
        int dist = 1;
        int ans = 0;
        while (!qu.empty()) {
            int sz = qu.size();
            for (int i = 0; i < sz; ++i) {
                int curr = qu.front();
                qu.pop();
                for (auto & v : adj[curr]) {
                    if (visit[v]) {
                        continue;
                    }
                    qu.emplace(v);
                    int time = patience[v] * ((2 * dist - 1) / patience[v]) + 2 * dist + 1;
                    ans = max(ans, time);
                    visit[v] = true;
                }
            }
            dist++;
        }
        return ans;
    }
}; // 2022.3.23
```



#### [LCP 07. 传递信息](https://leetcode-cn.com/problems/chuan-di-xin-xi/)

小朋友 A 在和 ta 的小伙伴们玩传信息游戏，游戏规则如下：

1. 有 n 名玩家，所有玩家编号分别为 0 ～ n-1，其中小朋友 A 的编号为 0
2. 每个玩家都有固定的若干个可传信息的其他玩家（也可能没有）。传信息的关系是单向的（比如 A 可以向 B 传信息，但 B 不能向 A 传信息）。
3. 每轮信息必须需要传递给另一个人，且信息可重复经过同一个人

给定总玩家数 `n`，以及按 `[玩家编号,对应可传递玩家编号]` 关系组成的二维数组 `relation`。返回信息从小 A (编号 0 ) 经过 `k` 轮传递到编号为 n-1 的小伙伴处的方案数；若不能到达，返回 0。

**示例 1：**

> 输入：`n = 5, relation = [[0,2],[2,1],[3,4],[2,3],[1,4],[2,0],[0,4]], k = 3`
>
> 输出：`3`
>
> 解释：信息从小 A 编号 0 处开始，经 3 轮传递，到达编号 4。共有 3 种方案，分别是 0->2->0->4， 0->2->1->4， 0->2->3->4。

**示例 2：**

> 输入：`n = 3, relation = [[0,2],[2,1]], k = 2`
>
> 输出：`0`
>
> 解释：信息不能从小 A 处经过 2 轮传递到编号 2

**限制：**

- `2 <= n <= 10`
- `1 <= k <= 5`
- `1 <= relation.length <= 90, 且 relation[i].length == 2`
- `0 <= relation[i][0],relation[i][1] < n 且 relation[i][0] != relation[i][1]`

方法一：DP

C++版代码：

```C++
class Solution {
public:
    int numWays(int n, vector<vector<int>>& relation, int k) {
        vector<vector<int>> dp(k + 1, vector<int>(n, 0));
        dp[0][0] = 1;
        for (int i = 1; i <= k; i++) { // 遍历 k 轮传递
            for (auto edge: relation) {
                dp[i][edge[1]] += dp[i - 1][edge[0]];
            }
        }
        return dp[k][n - 1];
    }
};
/*
1. 确定dp数组（dp table）以及下标的含义
    dp[i][j]：表示 经过 i 轮传递到达编号为 j 的方案数为：dp[i][j]
2. 确定递推公式
    如果编号 0 经过 i + 1 轮传递到达顶点 m，并且存在该点点 m 到 j 的边，则 dp[i][j] += dp[i - 1][m];
3. dp数组如何初始化
    如果从在 从编号 0 到编号 j 的边，则 dp[0][j] = 1，
4. 确定遍历顺序
   由递推公式 dp[i][j] += dp[i - 1][m]，dp[i][j] 是根据上一轮传递推导来的，所以遍历顺序从上到下，从左到右。
*/ // 2022.3.18
```

方法二：BFS

C++版代码：

```c++
class Solution {
public:
    int numWays(int n, vector<vector<int>>& relation, int k) {
        vector<vector<int>> adjacencyList(n);
        int result = 0;
        for (auto edge : relation) {
            adjacencyList[edge[0]].push_back(edge[1]); // 将 [玩家编号,对应可传递玩家编号] 数组存储到邻接表中
        }
        
        for (int row = 0; row < adjacencyList.size(); row++) {
            for (int col = 0; col < adjacencyList[row].size(); col++) {
                cout<<adjacencyList[row][col]<<" ";
            }
            cout<<endl;
        }
        
        queue<int> que;
        que.push(0);
        queue<vector<int>> pathQue;
        pathQue.push({0});
        while (!que.empty()) {
            int cur = que.front();
            que.pop();
            vector<int> curPath = pathQue.front();
            pathQue.pop();
            int round = curPath.size();
            for (auto index : adjacencyList[cur]) {
                if (index == n - 1 && round == k) { // 在 k 轮传递中到达编号 n - 1
                    result++;
                    continue;
                } else if (round < k) { // 传递次数未用尽，但还未找到编号 n - 1
                    curPath.push_back(index);
                    pathQue.push(curPath);
                    que.push(index);
                    curPath.pop_back(); // 回溯
                }
            }
        }
        return result;
    }
}; // 2022.3.18
```



#### [417. 太平洋大西洋水流问题](https://leetcode.cn/problems/pacific-atlantic-water-flow/)

有一个 `m × n` 的矩形岛屿，与 **太平洋** 和 **大西洋** 相邻。 **“太平洋”** 处于大陆的左边界和上边界，而 **“大西洋”** 处于大陆的右边界和下边界。

这个岛被分割成一个由若干方形单元格组成的网格。给定一个 `m x n` 的整数矩阵 `heights` ， `heights[r][c]` 表示坐标 `(r, c)` 上单元格 **高于海平面的高度** 。

岛上雨水较多，如果相邻单元格的高度 **小于或等于** 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。

返回网格坐标 `result` 的 **2D 列表** ，其中 `result[i] = [ri, ci]` 表示雨水从单元格 `(ri, ci)` 流动 **既可流向太平洋也可流向大西洋** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/06/08/waterflow-grid.jpg)

```
输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
```

**示例 2：**

```
输入: heights = [[2,1],[1,2]]
输出: [[0,0],[0,1],[1,0],[1,1]]
```

 

**提示：**

- `m == heights.length`
- `n == heights[r].length`
- `1 <= m, n <= 200`
- `0 <= heights[r][c] <= 105`

**思路：**

  从大洋一侧反向BFS，同时用 vector<vector<int>> oceans 保存每个单元格 (x, y) 的大洋值。

  1.从左上边界开始遍历时，对左上边界单元格 `oceans[x][y] += 1`，

​    寻找 `heights[i][j] >= heights[x][y]` 的单元格，并对 `oceans[i][j] += 1`

  2.从右下边界开始遍历时，对左上边界单元格 `oceans[x][y] += 2`，

​    寻找 `heights[i][j] >= heights[x][y]` 的单元格，并对 `oceans[i][j] += 2`

  最后遍历所有单元格，若 `oceans[i][j] == 3`，存入结果数组中。

C++代码部分：

```c++
class Solution {
private:
    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};   
    vector<vector<bool>> visited;
    // 0 表示没有找到任何大洋
    // 1 表示只能到达太平洋（左上），
    // 2 表示只能能到达大西洋（右下）
    // 3 表示可以同时到达太平洋（左上）和大西洋（右下）
    vector<vector<int>> oceans;
    void bfs(vector<vector<int>>& heights, vector<vector<bool>>& visited, queue<pair<int, int>>& que, int val) {
        int m = heights.size();
        int n = heights[0].size();
        while (!que.empty()) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            for (int i = 0; i < 4; i++) {
                int xx = x + dirs[i][0];
                int yy = y + dirs[i][1];
                if (xx < 0 or xx >= m or yy < 0 or yy >= n) continue;
                if (visited[xx][yy] or heights[xx][yy] < heights[x][y]) continue;
                que.emplace(xx, yy);
                visited[xx][yy] = true;
                oceans[xx][yy] += val;
            }
        }
    }
public:
    vector<vector<int>> pacificAtlantic(vector<vector<int>>& heights) {
        int m = heights.size();
        int n = heights[0].size();
        visited = vector<vector<bool>>(m, vector<bool>(n, false));
        oceans = vector<vector<int>>(m, vector<int>(n, 0));
        vector<vector<int>> result;
        queue<pair<int, int>> que;

        for (int i = 0; i < m; i++) {
            que.emplace(i, 0);
            oceans[i][0]++;
            visited[i][0] = true;
        }
        for (int j = 1; j < n; j++) {
            que.emplace(0, j);
            oceans[0][j]++;
            visited[0][j] = true;
        }
        bfs(heights, visited, que, 1);

        visited = vector<vector<bool>>(m, vector<bool>(n, false));
        for (int i = 0; i < m; i++) {
            que.emplace(i, n - 1);
            oceans[i][n - 1] += 2;
            visited[i][n - 1] = true;
        }
        for (int j = 0; j < n - 1; j++) {
            que.emplace(m - 1, j);
            oceans[m - 1][j] += 2;
            visited[m - 1][j] = true;
        }
        bfs(heights, visited, que, 2);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                //cout << oceans[i][j] << " ";
                if (oceans[i][j] == 3) {
                    result.push_back({i, j});
                }
            }
            //cout << endl;
        }
        return result;
    }
}; // 2022.4.27
```

#### [2258. 逃离火灾](https://leetcode.cn/problems/escape-the-spreading-fire/)（不会）第 77 场双周赛题

给你一个下标从 **0** 开始大小为 `m x n` 的二维整数数组 `grid` ，它表示一个网格图。每个格子为下面 3 个值之一：

- `0` 表示草地。
- `1` 表示着火的格子。
- `2` 表示一座墙，你跟火都不能通过这个格子。

一开始你在最左上角的格子 `(0, 0)` ，你想要到达最右下角的安全屋格子 `(m - 1, n - 1)` 。每一分钟，你可以移动到 **相邻** 的草地格子。每次你移动 **之后** ，着火的格子会扩散到所有不是墙的 **相邻** 格子。

请你返回你在初始位置可以停留的 **最多** 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 `-1` 。如果不管你在初始位置停留多久，你 **总是** 能到达安全屋，请你返回 `109` 。

注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。

如果两个格子有共同边，那么它们为 **相邻** 格子。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg)

```
输入：grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
输出：3
解释：上图展示了你在初始位置停留 3 分钟后的情形。
你仍然可以安全到达安全屋。
停留超过 3 分钟会让你无法安全到达安全屋。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg)

```
输入：grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
输出：-1
解释：上图展示了你马上开始朝安全屋移动的情形。
火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。
所以返回 -1 。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg)

```
输入：grid = [[0,0,0],[2,2,0],[1,2,0]]
输出：1000000000
解释：上图展示了初始网格图。
注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。
所以返回 109 。
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `2 <= m, n <= 300`
- `4 <= m * n <= 2 * 104`
- `grid[i][j]` 是 `0` ，`1` 或者 `2` 。
- `grid[0][0] == grid[m - 1][n - 1] == 0`

**方法：** **BFS + 二分查找**

题意：

```c++
	返回你在初始位置可以停留的 最多 分钟数，且停留完这段时间后你还能安全到达安全屋。
    如果无法实现，请你返回 -1 。如果不管你在初始位置停留多久，你 总是 能到达安全屋，请你返回 109 。
	注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。
```

思路：

​		人要能够安全的到达安全屋，说明在到达安全屋的路径上，**人到达该空格子的最早时间早于该空格子的最早着火时间**。如果不存在一条这样的路径，人就不能到达安全屋。并且，到达空格子的最早时间还要**加上人在初始位置停留的时间**。

​		因此，用数组 `fireTime` 记录空格子的最早着火时间，用数组 `arriveTime` 记录人达到空格子的最早到达时间。用二分查找的方法查找人能够在初始位置停留的最长时间。左端值为 0， 右端值为 grid 中格子的数量。

**记录空格子的最早着火时间**

​		从初始的火格子开始，BFS 遍历所有为 0 的格子，并记录每个格子的最早着火时间。火的格子的最早着火时间初始化为0，其他格子初始化为 INT_MAX。

**记录人在初始位置停留 `time` 分钟时间后，空格子的最早到达时间**

​		从初始位置 （0，0）开始，BFS 遍历所有为 0 的格子，并记录每个格子的最早到达时间。人的初始位置的最早到达时间为 `time`，其他格子初始化为 INT_MAX。

​		BFS 遍历的时间，如果最早到达时间大于等于格子的最早着火时间，就不能入队列；如果下一个格子为安全屋时，最早到达时间可以等于格子的最早着火时间。

​		更新最早到达时间的公式为：`arriveTime[nx][ny] = arriveTime[x][y] + 1`

​		最后就是二分查找人在初始位置可以停留的最长时间。

**C++版代码：**

```c++
class Solution {
private:
    static constexpr int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
public:
    int maximumMinutes(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> fireTime(m, vector<int>(n, INT_MAX)); // 保存每个格子着火的最早时间

        queue<pair<int, int>> que;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) { // 如果初始时为火格子，就入队列
                    que.emplace(i, j);
                    fireTime[i][j] = 0; // 最初就为火格子的着火时间为 0
                }
            }
        }
        // BFS 记录所有可以着火的草地的最早着火时间
        while (!que.empty()) {
            auto [x, y] = que.front();
            que.pop();
            for (auto dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                if (nx < 0 or nx >= m or ny < 0 or ny >= n or grid[nx][ny] == 2) continue; // 边界或墙
                if (grid[nx][ny] == 0 and fireTime[nx][ny] == INT_MAX) { // 如果为草地
                    que.emplace(nx, ny);
                    fireTime[nx][ny] = fireTime[x][y] + 1; // 记录最早着火时间为 
                }
            }
        }
        auto check = [&](int time) {
            // 保存人到达每个草地的最早到达时间，初始化为 INT_MAX
            vector<vector<int>> arriveTime(m, vector<int>(n, INT_MAX));
            queue<pair<int, int>> q;
            q.emplace(0, 0);
            arriveTime[0][0] = time; // 人的初始点的最早到达时间为 time
            if (arriveTime[0][0] >= fireTime[0][0]) return false; // 初始点着火了，直接返回false
            while (!q.empty()) {
                auto [x, y] = q.front();
                q.pop();
                for (auto dir : dirs) {
                    int nx = x + dir[0];
                    int ny = y + dir[1];
                    if (nx < 0 or nx >= m or ny < 0 or ny >= n or grid[nx][ny] == 2) continue;// 边界或墙
                    if (grid[nx][ny] == 0 and arriveTime[nx][ny] == INT_MAX) { // 如果为草地且此前没到达过
                        arriveTime[nx][ny] = arriveTime[x][y] + 1; // 记录最到达火时间
                        // 判断是否在安全屋着火前到达安全屋
                        if (nx == m - 1 and ny == n - 1) return arriveTime[nx][ny] <= fireTime[nx][ny]; 
                        if (arriveTime[nx][ny] < fireTime[nx][ny]) { // 到达时没着火
                            q.emplace(nx, ny);
                        }
                    }
                }
            }
            return false; // 不能到达安全屋
        };
        int left = 0;
        int right = m * n; // grid 中有 m * n 个格子，人最多走 m * n 分钟的时间
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (check(mid)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        int res = left; // 到达初始位置的时间，如果为 0 的话 说明不能在初始位置停留
        if (left == m * n) res = 1e9; // 不管停留多久都能到达安全屋
        else res = res - 1;
        return res;
    }
}; // 2022.5.2
```



## 拓扑排序

### 例题

| 题目                                                         | 题解                                                         | 难度 | 推荐指数 | 是否写了 |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ---- | -------- | -------- |
| [802. 找到最终的安全状态](https://leetcode-cn.com/problems/find-eventual-safe-states/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/find-eventual-safe-states/solution/gong-shui-san-xie-noxiang-xin-ke-xue-xi-isy6u/) | 中等 | 🤩🤩🤩🤩     |          |
| [851. 喧闹和富有](https://leetcode-cn.com/problems/loud-and-rich/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/loud-and-rich/solution/gong-shui-san-xie-tuo-bu-pai-xu-yun-yong-ylih/) | 中等 | 🤩🤩🤩🤩     |          |
| [954. 二倍数对数组](https://leetcode-cn.com/problems/array-of-doubled-pairs/) | [LeetCode 题解链接](https://leetcode-cn.com/problems/array-of-doubled-pairs/solution/by-ac_oier-d1z7/) | 中等 | 🤩🤩🤩🤩     |          |

#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

难度中等

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
输出：false
解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。
```

 

**提示：**

- `1 <= numCourses <= 105`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

C++版代码：

```c++
class Solution {
private:
    vector<vector<int>> graph;
    vector<int> inDegree;
    bool topologicalSort(vector<vector<int>>& graph, vector<int>& inDegree) {
        int count = 0;
        queue<int> que;
        for (int i = 0; i < graph.size(); i++) {
            if (inDegree[i] == 0) {
                que.push(i);
            }
        }
        while (!que.empty()) {
            int cur = que.front(); que.pop();
            count++;
            for (auto v : graph[cur]) {
                inDegree[v]--;
                if (inDegree[v] == 0) {
                    que.push(v);
                }
            }
        }
        if (count == graph.size()) {
            return true;
        }
        return false;
    }
public:
    bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {
        graph = vector < vector<int> >(numCourses);
        inDegree = vector<int>(numCourses);
        for (auto edge : prerequisites) {
            graph[edge[1]].push_back(edge[0]);
            inDegree[edge[0]]++;
        }
        return topologicalSort(graph, inDegree);
    }
};
//2022.4.10
```

#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

难度中等613

现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。

- 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

 

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：[0,1]
解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。
```

**示例 2：**

```
输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]
输出：[0,2,1,3]
解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。
```

**示例 3：**

```
输入：numCourses = 1, prerequisites = []
输出：[0]
```

 

**提示：**

- `1 <= numCourses <= 2000`
- `0 <= prerequisites.length <= numCourses * (numCourses - 1)`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `ai != bi`
- 所有`[ai, bi]` **互不相同**

C++版代码：

```c++
class Solution {
private:
    vector<vector<int>> graph;
    vector<int> inDegree;
    vector<int> result;
    vector<int> topologicalSort(vector<vector<int>>& graph, vector<int>& inDegree) {
        vector<int> result;
        queue<int> que;
        for (int i = 0; i < inDegree.size(); i++) {
            if (inDegree[i] == 0) {
                que.push(i);
            }
        }
        while (!que.empty()) {
            int cur = que.front(); que.pop();
            result.push_back(cur);
            for (auto v : graph[cur]) {
                inDegree[v]--;
                if (inDegree[v] == 0) {
                    que.push(v);
                }
            }
        }
        if (result.size() == graph.size()) return result;
        else return {};
    }
public:
    vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {
        graph = vector<vector<int>>(numCourses);
        inDegree = vector<int>(numCourses);
        for (auto edge : prerequisites) {
            graph[edge[1]].push_back(edge[0]);
            inDegree[edge[0]]++;
        }
        return topologicalSort(graph, inDegree);
    }
};
//2022.4.10
```

#### [1462. 课程表 IV](https://leetcode.cn/problems/course-schedule-iv/)

难度中等81

你总共需要上 `numCourses` 门课，课程编号依次为 `0` 到 `numCourses-1` 。你会得到一个数组 `prerequisite` ，其中 `prerequisites[i] = [ai, bi]` 表示如果你想选 `bi` 课程，你 **必须** 先选 `ai` 课程。

- 有的课会有直接的先修课程，比如如果想上课程 `1` ，你必须先上课程 `0` ，那么会以 `[0,1]` 数对的形式给出先修课程数对。

先决条件也可以是 **间接** 的。如果课程 `a` 是课程 `b` 的先决条件，课程 `b` 是课程 `c` 的先决条件，那么课程 `a` 就是课程 `c` 的先决条件。

你也得到一个数组 `queries` ，其中 `queries[j] = [uj, vj]`。对于第 `j` 个查询，您应该回答课程 `uj` 是否是课程 `vj` 的先决条件。

返回一个布尔数组 `answer` ，其中 `answer[j]` 是第 `j` 个查询的答案。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/05/01/courses4-1-graph.jpg)

```
输入：numCourses = 2, prerequisites = [[1,0]], queries = [[0,1],[1,0]]
输出：[false,true]
解释：课程 0 不是课程 1 的先修课程，但课程 1 是课程 0 的先修课程。
```

**示例 2：**

```
输入：numCourses = 2, prerequisites = [], queries = [[1,0],[0,1]]
输出：[false,false]
解释：没有先修课程对，所以每门课程之间是独立的。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2021/05/01/courses4-3-graph.jpg)

```
输入：numCourses = 3, prerequisites = [[1,2],[1,0],[2,0]], queries = [[1,0],[1,2]]
输出：[true,true]
```

 

**提示：**



- `2 <= numCourses <= 100`
- `0 <= prerequisites.length <= (numCourses * (numCourses - 1) / 2)`
- `prerequisites[i].length == 2`
- `0 <= ai, bi <= n - 1`
- `ai != bi`
- 每一对 `[ai, bi]` 都 **不同**
- 先修课程图中没有环。
- `0 <= ui, vi <= n - 1`
- `ui != vi`

**方法一：拓扑排序**

​	拓扑排序过程中用 `unordered_map<int, unordered_set<int>> hashMap` 保存每个课程的先修课程及先修课程的先修课程

C++版代码：

```c++
class Solution {
private:
    vector<vector<int>> graph;
    vector<int> indegree;
    unordered_map<int, unordered_set<int>> hashMap; // 记录 <endi, starti>
    void topologicalSort() {
        queue<int> que;
        for (int i = 0; i < graph.size(); i++) {
            if (!indegree[i]) {
                que.push(i);
            }
        }

        while (!que.empty()) {
            int cur = que.front();
            que.pop();
            for (auto v : graph[cur]) {
                indegree[v]--;
                hashMap[v].insert(cur);
                for (auto it = hashMap[cur].begin(); it != hashMap[cur].end(); it++) {
                    hashMap[v].insert(*it); // 记录课程 v 的先修课程 cur
                }
                if (!indegree[v]) {
                    que.push(v);
                }
            }
        }
    }
public:
    vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
        graph = vector<vector<int>>(numCourses);
        indegree = vector<int>(numCourses, 0);
        for (auto edge : prerequisites) {
            graph[edge[0]].push_back(edge[1]);
            indegree[edge[1]]++;
        }
        topologicalSort();
        vector<bool> res(queries.size(), false);
        for (int i = 0; i < queries.size(); i++) {
            int v = queries[i][0];
            int u = queries[i][1];
            if (hashMap[u].find(v) != hashMap[u].end()) {
                res[i] = true;
            }
        }
        /*
        for (auto it1 = hashMap.begin(); it1 != hashMap.end(); it1++) {
            cout << it1->first << " ";
            for (auto it = hashMap[it1->first].begin(); it != hashMap[it1->first].end(); it++) {
                cout << (*it) << " ";
            }
            cout << endl;
        }
        */
        return res;
    }
}; // 2022.4.29
```

**方法二：Floyd 算法**

​	用Floyd 算法判断，如果 v 和 w 课程之间的最短路径不为无穷大，则 v 为 w 的先修课程

C++版代码：

```c++
class Solution {
private:
    vector<vector<int>> graph;
    const int INF = 1e9;
public:
    vector<bool> checkIfPrerequisite(int numCourses, vector<vector<int>>& prerequisites, vector<vector<int>>& queries) {
        graph = vector<vector<int>>(numCourses, vector<int>(numCourses, INF));
        for (auto edge : prerequisites) {
            graph[edge[0]][edge[1]] = 1;
        }
        
        for (int k = 0; k < numCourses; k++) {
            for (int i = 0; i < numCourses; i++) {
                for (int j = 0; j < numCourses; j++) {
                    if (graph[i][k] + graph[k][j] < graph[i][j]) {
                        graph[i][j] = graph[i][k] + graph[k][j];
                    }
                }
            }
        }
        vector<bool> res(queries.size(), false);
        for (int i = 0; i < queries.size(); i++) {
            int v = queries[i][0];
            int w = queries[i][1];
            if (graph[v][w] != INF) {
                res[i] = true;
            }
        }
        return res;
    }
}; // 2022.4.29
```



## 最小生成树

### kruskal卡鲁斯卡尔 求最小生成树

**NC159** **最小生成树**

**描述**

一个有 n 户人家的村庄，有 m 条路**相互**连接着。村里现在要修路，每条路都有一个成本价格，现在请你帮忙计算下，最少需要花费多少钱，就能让这 n 户人家连接起来。

cost为一个二维数组，每个元素是一个长度为 3 的一维数组 a*a* ， a[0] 和 a[1]表示村庄 a[0]和村庄 a[1] 有一条路，修这条路的成本价格为 a[2] .

每户之间可能有多条道路连接，但不可能自己与自己相连
$$
数据范围: 1≤ n ≤5×103 ， 1≤ m ≤5×105 ， 1≤ a[2] ≤104 
\\进阶： 时间复杂度 O(n+mlogm) ， 空间复杂度 O(n)
$$
核心代码部分：

```c++
//卡鲁斯卡尔 求最小生成树

class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost intvector<vector<>> 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */
    int find(int x)//并查集合并及查找根节点
    {
        if(x !=p[x])
            p[x] = find(p[x]);
        return p[x];
    }
    int p[100010];
    int miniSpanningTree(int n, int m, vector<vector<int> >& cost) {
        // write code here
        
        for(int i = 0; i <= n; i++) p[i] = i;//初始化并查集
        
        //排序
        sort(cost.begin(),cost.begin() + m, [](vector<int>& a, vector<int> &b){return a[2] < b[2];});
        int res = 0;
        for(int i = 0; i < m; i++)
        {
            if(find(cost[i][0]) != find(cost[i][1]))//如果不是同一个集合，
            {
                res += cost[i][2];//加路
                p[find(cost[i][0])] = find(cost[i][1]);//合并集合
            }
        }
        return res;       
    }
};
```

优先级队列代码：

```c++
class Solution {
private:
    vector<int> parent;
    void initParent(vector<int>& parent) { // 初始化并查集
        for (int i = 0; i < parent.size(); i++) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (parent[x] != x) {
            return find(parent[x]);
        }
        return x;
    }
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost intvector<vector<>> 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */
    int miniSpanningTree(int n, int m, vector<vector<int> >& cost) {
        this->parent = vector<int>(n + 1, -1);
        initParent(parent);
        auto cmp = [](vector<int>& a, vector<int>& b)->bool {
            return a[2] > b[2];
        };
        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pque(cmp); //小顶堆
        int result = 0;
        for (int i = 0; i < cost.size(); i++) {
            pque.push(cost[i]);
        }
        int cnt = n - 1;
        while (!pque.empty() and cnt > 0) {
            vector<int> edge = pque.top();
            pque.pop();
            if (find(edge[0]) == find(edge[1])) {
                continue;
            }
            
            result += edge[2];
            parent[find(edge[0])] = find(edge[1]);
            cnt--;
        }
        return result;
    }
};
```

可运行代码：

```c++
#include<iostream>
#include<vector>
#include<queue>
#include<functional>
#include<string>
using namespace std;

class PrintTwoVector {
public:
    void PrintMatrix(vector <vector<int>>& matrix) // 格式输出
    {
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                cout << matrix[i][j];
                if (j != matrix[0].size() - 1)
                    cout << "\t";
            }
            if (i != matrix.size() - 1)
                cout << endl;
        }
        cout << endl;
    }
};

class Solution {
private:
    vector<int> parent;
    void initParent(vector<int>& parent) { // 初始化并查集
        for (int i = 0; i < parent.size(); i++) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (parent[x] != x) {
            return find(parent[x]);
        }
        return x;
    }
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost intvector<vector<>> 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */
    int miniSpanningTree(int n, int m, vector<vector<int> >& cost) {
        this->parent = vector<int>(n + 1, -1);
        initParent(parent);
        auto cmp = [](vector<int>& a, vector<int>& b)->bool {
            return a[2] > b[2];
        };
        priority_queue<vector<int>, vector<vector<int>>, decltype(cmp)> pque(cmp); //小顶堆
        int result = 0;
        for (int i = 0; i < cost.size(); i++) {
            pque.push(cost[i]);
        }
        int cnt = n - 1;
        while (!pque.empty() and cnt > 0) {
            vector<int> edge = pque.top();
            pque.pop();
            if (find(edge[0]) == find(edge[1])) {
                continue;
            }

            result += edge[2];
            parent[find(edge[0])] = find(edge[1]);
            cnt--;
        }
        cout << "result = " << result << endl;
        return result;
    }
};
void SplitString(string input, vector <string>& output, string pattern)
{
    string::size_type pos;
    input += pattern;
    for (int i = 0; i < input.size(); i++) {
        pos = input.find(pattern, i);
        if (pos < input.size()) {
            string temp = input.substr(i, pos - i);
            if ((temp != pattern) && (!temp.empty())) {
                output.push_back(temp);
            }
            i = pos + pattern.size() - 1;
        }
    }
}

void SplitInt(string input, vector<int>& output, string pattern)
{
    string::size_type pos;
    input += pattern;
    for (int i = 0; i < input.size(); i++) {
        pos = input.find(pattern, i);
        if (pos < input.size()) {
            string s = input.substr(i, pos - i);
            if ((s != " ") && (!s.empty())) {
                output.push_back(stoi(s));
            }
            i = pos + pattern.size() - 1;
        }
    }
}


int main(int argc, const char** argv)
{
    int N, M;
    cin >> N >> M;
    string input;
    while (getline(cin, input)) {
        if (!input.empty()) {
            input = input.substr(2, input.size() - 4); // 去掉最外层的两对[]
            vector <string> groups;
            string pattern = "],[";
            SplitString(input, groups, pattern);
            vector <vector<int>> matrix;
            for (auto& group : groups) {
                vector<int> vec;
                SplitInt(group, vec, ",");
                matrix.push_back(vec);
            }
            
            auto minTree = new Solution;
            minTree->miniSpanningTree(N, M, matrix);
        }
    }
    return 0;
}
/*
6,10,[[5,3,8],[1,3,6],[2,5,4],[2,3,5],[4,5,6],[3,4,3],[2,4,8],[1,2,2],[1,4,5],[5,6,2]]
6 10
[[5,3,8],[1,3,6],[2,5,4],[2,3,5],[4,5,6],[3,4,3],[2,4,8],[1,2,2],[1,4,5],[5,6,2]]
*/
```

### prim算法

**NC159** **最小生成树**

代码部分：

```c++
class Solution {
private:
    vector<int> parent;
    struct Edge {
        //int from;
        int to;
        int weight;
    };
    void initParent(vector<int>& parent) { // 初始化并查集
        for (int i = 0; i < parent.size(); i++) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (parent[x] != x) {
            return find(parent[x]);
        }
        return x;
    }
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost intvector<vector<>> 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */
    int primMinSpanningTree(int source, vector < vector<Edge>>& graph) {
        int n = graph.size();
        int result = 0;
        auto cmp = [](Edge& a, Edge& b)->bool {
            return a.weight == b.weight ? a.to > b.to : a.weight > b.weight;;
        };

        priority_queue<Edge, vector<Edge>, decltype(cmp)> pque(cmp); //小顶堆
        
        for (auto edge : graph[source]) {
            pque.push(edge);
        }
        int cnt = n - 1;
        while (!pque.empty() and cnt > 0) {
            Edge edge = pque.top();
            pque.pop();
            if (find(edge.to) == source) {
                continue;
            }

            result += edge.weight;
            parent[find(edge.to)] = source;
            cnt--;
            for (auto edge : graph[edge.to]) {
                pque.push(edge);
            }
        }
        return result;
    }
    int miniSpanningTree(int n, int m, vector<vector<int> >& cost) {
        this->parent = vector<int>(n + 1, -1);
        initParent(parent);
        vector < vector<Edge>> graph(n + 1);
        for (auto edge : cost) { // 初始化邻接表
            graph[edge[0]].push_back({ edge[1], edge[2] });
            graph[edge[1]].push_back({ edge[0], edge[2] });
        }
        int result = primMinSpanningTree(1, graph);
        cout << "result = " << result << endl;
        return result;
    }
};
```

可运行代码：

```c++
#include<iostream>
#include<vector>
#include<queue>
#include<functional>
#include<string>
using namespace std;

class PrintTwoVector {
public:
    void PrintMatrix(vector <vector<int>>& matrix) // 格式输出
    {
        for (int i = 0; i < matrix.size(); i++) {
            for (int j = 0; j < matrix[0].size(); j++) {
                cout << matrix[i][j];
                if (j != matrix[0].size() - 1)
                    cout << "\t";
            }
            if (i != matrix.size() - 1)
                cout << endl;
        }
        cout << endl;
    }
};

class Solution {
private:
    vector<int> parent;
    struct Edge {
        //int from;
        int to;
        int weight;
    };
    void initParent(vector<int>& parent) { // 初始化并查集
        for (int i = 0; i < parent.size(); i++) {
            parent[i] = i;
        }
    }
    int find(int x) {
        if (parent[x] != x) {
            return find(parent[x]);
        }
        return x;
    }
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 返回最小的花费代价使得这n户人家连接起来
     * @param n int n户人家的村庄
     * @param m int m条路
     * @param cost intvector<vector<>> 一维3个参数，表示连接1个村庄到另外1个村庄的花费的代价
     * @return int
     */
    int primMinSpanningTree(int source, vector < vector<Edge>>& graph) {
        int n = graph.size();
        int result = 0;
        auto cmp = [](Edge& a, Edge& b)->bool {
            return a.weight == b.weight ? a.to > b.to : a.weight > b.weight;;
        };

        priority_queue<Edge, vector<Edge>, decltype(cmp)> pque(cmp); //小顶堆

        for (auto edge : graph[source]) {
            pque.push(edge);
        }
        int cnt = n - 1;
        while (!pque.empty() and cnt > 0) {
            Edge edge = pque.top();
            pque.pop();
            if (find(edge.to) == source) {
                continue;
            }

            result += edge.weight;
            parent[find(edge.to)] = source;
            cnt--;
            for (auto edge : graph[edge.to]) {
                pque.push(edge);
            }
        }
        return result;
    }
    int miniSpanningTree(int n, int m, vector<vector<int> >& cost) {
        this->parent = vector<int>(n + 1, -1);
        initParent(parent);
        vector < vector<Edge>> graph(n + 1);
        for (auto edge : cost) { // 初始化邻接表
            graph[edge[0]].push_back({ edge[1], edge[2] });
            graph[edge[1]].push_back({ edge[0], edge[2] });
        }
        int result = primMinSpanningTree(1, graph);
        cout << "result = " << result << endl;
        return result;
    }
};
void SplitString(string input, vector <string>& output, string pattern)
{
    string::size_type pos;
    input += pattern;
    for (int i = 0; i < input.size(); i++) {
        pos = input.find(pattern, i);
        if (pos < input.size()) {
            string temp = input.substr(i, pos - i);
            if ((temp != pattern) && (!temp.empty())) {
                output.push_back(temp);
            }
            i = pos + pattern.size() - 1;
        }
    }
}

void SplitInt(string input, vector<int>& output, string pattern)
{
    string::size_type pos;
    input += pattern;
    for (int i = 0; i < input.size(); i++) {
        pos = input.find(pattern, i);
        if (pos < input.size()) {
            string s = input.substr(i, pos - i);
            if ((s != " ") && (!s.empty())) {
                output.push_back(stoi(s));
            }
            i = pos + pattern.size() - 1;
        }
    }
}



int main(int argc, const char** argv)
{
    int N, M;
    cin >> N >> M;
    string input;
    while (getline(cin, input)) {
        if (!input.empty()) {
            input = input.substr(2, input.size() - 4); // 去掉最外层的两对[]
            vector <string> groups;
            string pattern = "],[";
            SplitString(input, groups, pattern);
            vector <vector<int>> matrix;
            for (auto& group : groups) {
                vector<int> vec;
                SplitInt(group, vec, ",");
                matrix.push_back(vec);
            }
            
            auto minTree = new Solution;
            minTree->miniSpanningTree(N, M, matrix);
        }
    }
    return 0;
}

/*
6,10,[[5,3,8],[1,3,6],[2,5,4],[2,3,5],[4,5,6],[3,4,3],[2,4,8],[1,2,2],[1,4,5],[5,6,2]]
6 10
[[5,3,8],[1,3,6],[2,5,4],[2,3,5],[4,5,6],[3,4,3],[2,4,8],[1,2,2],[1,4,5],[5,6,2]]
100 1000
[[78,24,6266],[35,88,9549],[72,100,5915],[66,21,9671],[87,78,1355],[83,91,8577],[91,7,4452],[25,15,6958],[5,54,3477],[37,100,3542],[13,29,6732],[5,55,5206],[68,37,3316],[79,50,2905],[7,83,4235],[99,65,9083],[47,64,7341],[4,28,5363],[58,24,3228],[92,85,36],[26,38,2107],[93,20,9970],[91,44,6931],[91,8,3902],[74,75,254],[39,66,699],[29,5,3853],[62,46,9221],[60,94,3265],[2,63,7200],[62,73,5454],[1,56,1587],[39,64,9866],[60,97,7614],[100,12,7687],[31,42,2525],[13,63,8696],[61,43,1641],[34,36,9431],[34,44,8395],[99,42,7768],[82,32,6043],[18,63,4853],[74,5,4440],[7,70,4024],[71,97,3546],[52,27,1274],[62,64,1610],[86,44,1024],[70,42,2696],[51,24,3796],[27,35,3603],[99,36,30],[92,73,3201],[66,34,1897],[51,92,2825],[83,34,1826],[39,65,1968],[46,70,7129],[60,46,8242],[25,87,9258],[98,53,6546],[55,14,7751],[49,85,7236],[11,91,7838],[35,54,6878],[4,11,2633],[25,9,3787],[62,13,4575],[43,90,6356],[19,46,3663],[40,21,6810],[15,95,2188],[58,77,9877],[17,37,1760],[66,78,8199],[27,66,1205],[81,44,7123],[10,68,9132],[58,61,6082],[29,12,931],[72,100,8586],[76,43,6061],[54,94,6086],[89,76,9016],[28,16,1662],[5,22,1055],[59,89,1810],[52,42,1236],[49,63,9254],[66,31,2179],[84,39,4985],[69,13,9976],[28,84,344],[29,83,5454],[35,48,7592],[82,89,9806],[3,99,694],[65,60,2632],[48,62,9368],[4,53,1400],[49,16,809],[57,21,7762],[9,55,2788],[12,68,2649],[69,1,397],[67,71,7303],[41,99,9580],[79,6,7762],[9,69,3244],[62,31,2295],[99,21,9786],[87,66,9374],[48,26,3887],[98,28,5184],[2,46,9571],[10,6,1504],[51,99,2753],[71,19,1806],[88,86,6658],[22,83,1771],[15,27,4565],[72,8,2980],[48,6,5105],[34,22,4738],[76,44,4971],[73,51,4524],[31,10,4313],[93,38,770],[33,80,1262],[63,27,588],[60,97,300],[89,51,8877],[36,61,8321],[70,38,8682],[50,22,112],[78,10,7048],[39,39,9034],[15,53,5121],[23,12,4030],[59,14,9431],[56,6,1215],[72,2,7124],[83,39,5978],[31,35,7880],[89,56,1072],[81,68,4579],[32,61,4036],[44,46,5534],[55,88,1876],[12,93,4492],[55,12,1904],[25,69,3168],[72,65,455],[48,94,69],[50,18,6611],[35,11,161],[63,14,2659],[26,46,4487],[84,63,5023],[78,45,6017],[72,86,8558],[77,17,3197],[16,85,9968],[3,82,7843],[95,93,8068],[94,88,9085],[23,93,4070],[56,97,9729],[45,35,4998],[46,12,7110],[59,40,421],[34,26,9246],[61,49,35],[55,48,7387],[13,40,9419],[27,39,1658],[7,67,388],[84,49,8688],[93,84,9041],[85,31,1979],[100,49,5821],[58,29,5795],[55,86,821],[18,7,1610],[73,57,2786],[12,48,5004],[23,52,5398],[28,55,6764],[12,64,872],[41,81,584],[24,2,8849],[94,48,4515],[92,11,5870],[51,36,5411],[2,50,9643],[8,40,9205],[23,100,4458],[86,51,741],[91,8,4223],[80,37,8715],[82,77,807],[76,75,1726],[98,55,8905],[82,22,1372],[100,13,7327],[4,25,4261],[36,88,836],[58,94,6203],[67,5,933],[72,33,5741],[36,50,2032],[28,42,9007],[48,29,3846],[19,2,5338],[95,33,6487],[79,2,5266],[25,59,736],[41,34,7603],[26,43,9714],[41,40,9596],[15,23,5698],[57,19,7160],[21,52,6423],[58,41,1681],[17,92,4261],[30,31,5974],[28,65,2949],[39,91,9465],[14,94,6059],[14,28,5592],[4,5,562],[77,94,9550],[35,21,6759],[84,75,5681],[45,14,3059],[18,61,44],[50,70,5948],[30,10,792],[17,70,7997],[36,12,2388],[84,63,4041],[1,47,2228],[4,36,2811],[81,36,8689],[33,72,6597],[91,68,4616],[58,5,6880],[46,50,8751],[20,67,6791],[54,53,8705],[13,37,2927],[46,32,2073],[5,43,1224],[92,12,1501],[92,5,4345],[40,49,4915],[92,74,6412],[22,47,1886],[3,54,8630],[40,16,5191],[75,16,3902],[97,70,224],[16,21,119],[27,95,8692],[6,68,4763],[50,47,3944],[65,89,8810],[35,80,5091],[93,19,5682],[62,62,206],[60,79,4638],[61,32,1372],[31,38,9897],[66,24,1196],[32,41,1833],[23,46,7626],[58,42,4418],[83,44,5303],[9,89,7016],[45,11,5898],[38,85,1216],[24,76,173],[98,63,3526],[19,4,4906],[13,1,2932],[79,33,1],[1,84,720],[70,28,8064],[12,39,11],[70,66,3940],[59,84,551],[27,7,1320],[39,56,7644],[36,17,324],[64,59,5894],[38,33,4578],[86,24,1742],[87,95,2505],[25,32,9975],[27,27,6412],[48,82,4936],[7,97,7597],[49,6,464],[57,87,9692],[94,32,6461],[55,99,5645],[21,7,6371],[8,23,785],[96,30,4583],[87,92,942],[88,70,6181],[98,37,6987],[44,90,354],[70,75,4897],[94,64,7886],[80,80,9944],[76,27,460],[36,73,6458],[83,77,7922],[35,25,4193],[29,81,6058],[15,11,8414],[27,76,4927],[24,31,84],[16,36,9405],[46,61,2828],[60,53,5160],[7,24,2099],[48,70,695],[39,95,6685],[80,46,9952],[35,62,9501],[100,70,120],[90,52,5471],[79,4,9450],[9,9,4172],[19,27,541],[61,76,7902],[31,30,4352],[31,90,8735],[22,50,4059],[10,99,9717],[15,99,1329],[76,43,4281],[93,32,1095],[30,94,9556],[37,100,1968],[86,56,6330],[64,83,8681],[95,44,4850],[60,41,5994],[46,82,2813],[44,30,1633],[61,70,917],[65,97,5863],[63,38,4850],[85,30,5465],[28,47,5472],[64,3,8388],[52,80,893],[90,62,2397],[17,60,8989],[49,15,7263],[3,89,2686],[75,19,1800],[18,78,6507],[24,28,7077],[19,18,2547],[37,6,6721],[72,96,1321],[50,20,3288],[60,82,6572],[16,42,1205],[76,70,2756],[53,60,1987],[14,74,6493],[21,4,3637],[84,46,9086],[27,17,9618],[71,11,1577],[23,47,1090],[71,43,1024],[26,96,317],[69,5,5421],[16,28,6056],[14,36,9778],[59,32,2582],[48,18,747],[90,72,7336],[61,74,8936],[11,10,322],[54,9,8744],[59,29,938],[30,1,6783],[81,40,1084],[20,91,7129],[68,22,9169],[81,83,5256],[70,67,2023],[52,2,7305],[29,96,128],[75,6,277],[62,98,1347],[3,48,3295],[26,96,9614],[91,31,7523],[44,35,884],[70,66,1550],[21,71,5957],[6,46,9447],[91,36,4271],[40,99,3260],[96,25,3649],[61,53,8236],[22,61,1173],[99,59,2728],[85,86,5798],[45,72,9883],[22,81,3892],[27,76,2342],[83,84,2386],[10,95,1308],[82,38,7211],[13,46,8189],[91,37,6484],[18,38,7389],[16,5,7406],[44,61,9587],[7,97,9419],[48,63,8144],[78,37,4474],[28,72,1848],[98,67,1972],[91,50,1866],[78,42,6282],[45,16,2432],[73,1,1502],[8,25,9962],[42,6,6715],[23,87,1061],[72,7,7647],[1,15,7623],[55,100,2780],[42,86,4556],[100,80,6476],[77,46,7150],[68,89,8649],[16,4,3591],[47,91,4036],[24,10,1610],[98,91,2025],[84,60,428],[85,16,446],[87,45,9780],[38,18,5734],[58,89,980],[75,68,9747],[55,92,4685],[26,5,109],[76,7,9655],[93,17,3902],[9,31,7306],[24,57,1654],[28,37,4325],[32,22,4003],[7,80,2512],[3,8,964],[8,22,5880],[76,33,1549],[66,53,6817],[44,17,7984],[77,97,4153],[38,58,7771],[79,8,1622],[65,31,8819],[63,17,1473],[18,64,2156],[14,79,7533],[60,95,8802],[28,63,2690],[87,73,1098],[88,87,4661],[22,26,3262],[83,98,2468],[20,71,1045],[19,16,7256],[81,47,2380],[3,28,5316],[18,69,9217],[48,18,809],[7,57,3729],[25,45,4218],[97,82,8130],[64,55,1214],[27,11,1217],[50,1,6571],[76,13,8517],[72,85,2432],[73,100,8922],[89,50,8367],[95,92,1362],[15,61,6080],[62,17,860],[96,52,867],[72,79,9777],[44,49,3244],[38,33,3947],[33,16,82],[6,88,4665],[48,94,4867],[5,32,6423],[99,86,4544],[72,67,4016],[100,74,1462],[28,35,7306],[89,93,3223],[78,13,7871],[51,88,2976],[59,84,9603],[90,16,5846],[16,63,2229],[35,12,4456],[86,88,6851],[74,3,6839],[92,81,78],[1,53,4052],[85,80,5093],[88,60,5168],[89,60,1124],[6,20,9024],[84,5,7730],[29,91,220],[91,3,6710],[91,91,9312],[16,82,1317],[64,67,3227],[77,97,2120],[68,66,7010],[78,27,7612],[54,82,4824],[57,54,7675],[8,58,6503],[25,11,576],[81,19,6729],[91,81,4205],[65,79,8228],[6,78,3445],[12,30,285],[25,26,1540],[74,22,1893],[2,94,8597],[49,36,9201],[82,20,3894],[85,3,9809],[84,11,1481],[10,89,68],[52,60,6347],[50,99,3572],[40,48,3946],[24,74,7612],[87,27,743],[24,45,7321],[60,95,1158],[70,18,6296],[27,12,3058],[11,67,8247],[5,23,1302],[93,91,9704],[9,82,6569],[53,28,9534],[52,85,6078],[4,97,202],[62,85,1786],[34,16,1666],[18,17,3525],[22,67,7735],[51,99,859],[78,15,2199],[13,66,8856],[33,2,2381],[24,90,9595],[97,37,2525],[80,100,9289],[70,62,8462],[82,43,2637],[69,57,2078],[85,21,6446],[99,18,361],[91,89,1537],[98,52,6006],[45,26,7174],[68,62,6152],[6,18,9605],[6,25,9539],[84,87,9790],[33,83,8122],[39,93,5564],[7,95,4798],[6,16,1492],[15,28,755],[49,45,972],[2,66,153],[62,22,9034],[30,47,6321],[21,33,4525],[49,74,9754],[25,62,1807],[22,98,5263],[16,13,6480],[72,60,4406],[65,60,3066],[9,14,10000],[48,69,9278],[43,37,9106],[42,63,5880],[32,100,5924],[7,80,194],[56,13,7494],[97,59,3991],[76,55,1471],[93,62,6104],[7,60,6691],[100,95,2915],[47,42,6716],[35,9,7719],[1,91,7223],[6,49,2096],[79,46,8987],[32,8,780],[62,77,2750],[43,3,4073],[22,14,7747],[91,66,5417],[49,20,9228],[94,75,2984],[60,5,6116],[34,34,349],[62,55,4808],[2,57,7925],[9,76,9004],[98,51,1349],[78,37,1371],[6,36,723],[39,85,4765],[99,23,4755],[85,11,506],[84,7,5769],[70,47,332],[62,83,6077],[45,40,6081],[28,53,3182],[21,8,2750],[8,65,1272],[26,88,5601],[13,67,6344],[53,88,7215],[45,52,1173],[21,48,171],[32,32,1670],[7,47,3315],[77,11,4956],[5,61,525],[48,58,7196],[31,12,9569],[22,5,7144],[95,31,6445],[37,91,5086],[90,15,5356],[38,88,642],[92,99,1044],[80,47,8656],[68,24,2324],[34,54,4594],[89,63,6173],[75,49,1596],[90,10,1133],[56,100,4355],[47,70,239],[78,55,3396],[46,99,5182],[73,80,1413],[69,84,6119],[9,74,3738],[86,29,9149],[26,72,1352],[50,55,5657],[7,85,3070],[62,41,9241],[1,39,6599],[13,66,9209],[67,1,1688],[92,69,5593],[86,13,1266],[15,49,6725],[1,53,3285],[44,80,8788],[75,26,96],[71,42,1446],[71,71,4854],[60,69,2640],[40,48,9252],[12,71,9015],[73,43,9510],[69,28,575],[43,32,351],[37,32,148],[5,75,572],[44,28,3623],[28,40,6102],[96,42,3687],[76,63,9170],[43,44,4881],[23,7,9571],[95,88,9680],[37,14,7732],[94,81,2917],[39,17,5889],[59,66,6116],[16,25,204],[45,64,1908],[13,71,1172],[54,55,3415],[6,71,5980],[16,78,374],[40,14,5352],[57,99,9053],[57,93,3501],[59,36,4421],[76,1,2602],[10,33,429],[40,63,4151],[14,70,4937],[84,24,8651],[42,50,7751],[31,86,1969],[46,2,8326],[66,74,1603],[13,35,121],[93,3,427],[52,24,5124],[65,8,4947],[20,12,9180],[73,85,9466],[5,30,5822],[9,40,10000],[20,37,7092],[37,79,9587],[16,42,205],[73,91,1356],[83,47,1944],[82,96,1898],[28,55,9701],[51,86,918],[52,94,8431],[79,39,3500],[70,12,6113],[86,73,1476],[38,55,924],[86,17,4971],[30,61,235],[100,42,7998],[75,57,3388],[11,62,5498],[76,99,3743],[83,53,1006],[49,8,9854],[91,51,9017],[21,55,1057],[97,73,1879],[10,37,5010],[61,37,7986],[6,98,5819],[50,86,4],[89,47,4149],[42,42,7700],[28,4,3612],[17,27,2690],[40,13,9707],[54,22,1615],[89,62,8926],[62,6,8382],[59,76,4447],[62,74,2736],[30,68,167],[35,97,4099],[18,32,8152],[36,16,2783],[14,56,3027],[80,40,3598],[19,75,2092],[98,26,1863],[35,99,911],[76,37,5700],[63,33,5802],[53,48,8229],[70,16,1689],[52,96,951],[85,98,866],[97,47,7908],[8,23,1767],[50,27,2483],[19,4,6456],[93,64,6264],[73,54,4261],[39,23,2847],[84,39,1738],[35,53,488],[4,3,7540],[21,92,6481],[50,74,9902],[7,14,8480],[62,74,8127],[73,34,7298],[86,85,639],[55,94,1575],[92,89,6224],[71,29,596],[92,20,4729],[62,99,254],[88,9,2467],[10,54,8144],[44,45,5252],[54,24,6010],[8,17,8649],[54,47,2900],[1,17,6942],[91,82,5107],[100,25,8704],[80,99,4508],[84,95,3741],[4,78,6332],[41,37,7137],[25,82,3567],[65,74,9891],[39,21,7861],[27,12,1834],[89,88,1981],[40,60,8658],[84,36,8719],[45,31,1645],[49,99,5223],[79,44,3843],[35,41,2735],[23,22,4153],[11,71,2591],[2,24,6642],[43,33,6006],[44,28,5544],[53,8,2529],[47,46,4108],[1,32,7456],[100,13,3082],[69,47,2928],[68,100,4972],[54,10,4587],[75,17,3792],[4,70,5637],[50,2,4338],[47,8,5705],[6,74,5851],[85,72,166],[95,27,3301],[50,15,1785],[50,91,3062],[40,16,291],[71,87,1772],[69,91,497],[51,71,2753],[63,3,4534],[7,43,7335],[29,7,2016],[56,16,3648],[76,89,6074],[86,18,3187],[5,3,2051],[68,93,7252],[82,69,3980],[63,67,5983],[80,26,5126],[11,25,7784],[61,36,6401],[23,3,6024],[57,6,8285],[38,18,4655],[20,71,5464],[31,61,3228],[13,53,9666],[19,57,1437],[82,83,4961],[38,19,9309],[37,17,257],[72,91,1491],[97,45,5036],[49,75,1780],[77,63,2193],[18,39,7423],[37,55,9430],[58,49,6809],[56,43,7013],[65,72,1299],[21,54,2865],[13,100,2064],[58,51,5972],[31,14,3253],[2,4,9508],[32,60,8919],[82,85,917],[34,21,6663],[65,72,7042],[42,1,9597],[36,78,3998],[5,50,3512],[93,92,958],[91,50,2933],[30,98,1757],[26,93,4267],[28,6,7422],[91,3,9404],[89,16,3128],[11,58,5895],[26,3,7998],[20,100,4199],[7,86,1346],[55,79,2351],[44,8,1464],[92,6,3281],[46,25,2526],[21,30,9011],[7,62,7234],[13,78,3508],[28,60,2600],[34,4,2887],[68,80,9032],[7,33,1781],[98,16,449],[23,12,6611],[79,66,9307],[40,70,1973],[26,19,4475],[31,48,8299],[5,12,9817],[63,75,294],[57,57,1958],[31,65,5279],[3,56,3790],[88,19,3851],[47,63,7545],[64,78,4598],[60,21,2939],[49,22,1988],[20,100,2819],[85,4,7927],[2,84,5189],[56,81,9608],[27,70,1140],[17,23,9688],[56,40,5952],[20,8,7620],[89,2,3719],[90,76,1371],[31,72,4333],[26,86,1395],[45,8,3107],[92,96,7462],[3,12,3713],[85,64,5599],[62,81,4049],[9,24,9090],[80,65,9799],[67,53,5383],[89,20,8527],[9,31,5367],[88,49,41],[93,48,6593],[99,30,1542],[15,64,2086],[30,55,7498],[49,10,1586],[34,42,9368],[92,61,1159],[24,42,7542],[96,98,7948],[87,65,8094],[96,39,1972],[90,60,4750],[36,67,9928],[34,10,8000],[32,83,5894],[35,76,1934],[14,21,949],[90,61,5445],[83,12,7263],[8,99,6368],[10,27,1024],[95,64,1196],[16,59,3336],[70,40,53],[22,100,4500],[2,27,4108]]
*/
```

## A*算法

启发式搜索



## 图论例题

| 题目                                                         | 题型             | 难度            | 是否写 |
| ------------------------------------------------------------ | ---------------- | --------------- | ------ |
| [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/) | 多种解法         | 中等            | 是     |
| [2267. 检查是否有合法括号字符串路径](https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/) | DP/DFS           | 困难(292周赛)   | 不会   |
| [1293. 网格中的最短路径](https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/) |                  |                 |        |
| [2242.节点序列的最大得分](https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/) | dijkstra         | 困难（288周赛） | 不会   |
| [面试题 08.02. 迷路的机器人](https://leetcode.cn/problems/robot-in-a-grid-lcci/) | DFS + 记忆化搜索 | 中等            | 是     |

#### [433. 最小基因变化](https://leetcode.cn/problems/minimum-genetic-mutation/)

难度中等

基因序列可以表示为一条由 8 个字符组成的字符串，其中每个字符都是 `'A'`、`'C'`、`'G'` 和 `'T'` 之一。

假设我们需要调查从基因序列 `start` 变为 `end` 所发生的基因变化。一次基因变化就意味着这个基因序列中的一个字符发生了变化。

- 例如，`"AACCGGTT" --> "AACCGGTA"` 就是一次基因变化。

另有一个基因库 `bank` 记录了所有有效的基因变化，只有基因库中的基因才是有效的基因序列。

给你两个基因序列 `start` 和 `end` ，以及一个基因库 `bank` ，请你找出并返回能够使 `start` 变化为 `end` 所需的最少变化次数。如果无法完成此基因变化，返回 `-1` 。

注意：起始基因序列 `start` 默认是有效的，但是它并不一定会出现在基因库中。

 

**示例 1：**

```
输入：start = "AACCGGTT", end = "AACCGGTA", bank = ["AACCGGTA"]
输出：1
```

**示例 2：**

```
输入：start = "AACCGGTT", end = "AAACGGTA", bank = ["AACCGGTA","AACCGCTA","AAACGGTA"]
输出：2
```

**示例 3：**

```
输入：start = "AAAAACCC", end = "AACCCCCC", bank = ["AAAACCCC","AAACCCCC","AACCCCCC"]
输出：3
```

 

**提示：**

- `start.length == 8`
- `end.length == 8`
- `0 <= bank.length <= 10`
- `bank[i].length == 8`
- `start`、`end` 和 `bank[i]` 仅由字符 `['A', 'C', 'G', 'T']` 组成

**方法一：「包着 DFS 外皮的回溯」**

**复杂度分析：**

时间复杂度：令 n 为 bank 的数组长度（合法状态数），将 bank 存入 Set 结构复杂度为 $$O(n)$$，每个状态经过一步操作最多拓展出 C = 		32 个新基因（共有 8 个位置，每个位置有 4 个选择），BFS 过程复杂度为 $$O(C * n)$$。整体复杂度为 $$O(C * n)$$
空间复杂度：$$O(n)$$

```c++
class Solution {
private:
    int res;
    bool isValid(const string& s1, const string& s2) { // 判断两个基因序列是否只有一个字母不同
        int cnt = 0;
        for (int i = 0; i < s1.size(); i++) {
            if (s1[i] != s2[i]) cnt++;
        }
        if (cnt == 1) return true;
        return false;
    }
    void dfs(vector<string>& bank, string& start, string& end, vector<bool>& vis, int cnt) {
        if (start == end) {
            res = min(res, cnt);
            return;
        }
        for (int i = 0; i < bank.size(); i++) {
            if (!vis[i] and isValid(start, bank[i])) {
                vis[i] = true;
                bfs(bank, bank[i], end, vis, cnt + 1);
                vis[i] = false;
            }
        }
    }
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n = bank.size();
        vector<bool> vis(n, false);
        res = n + 1;

        for (int i = 0; i < n; i++) {
            if (isValid(start, bank[i])) {
                vis[i] = true;
                bfs(bank, bank[i], end, vis, 1);
                vis[i] = false;
            }
        }
        if (res > n) res = -1;
        return res;
    }
}; // 2022.5.7
```

**方法二：「BFS」**

思路：

​		将每个基因序列视为「状态」。

​		容易想到使用 BFS 进行求解，并使用「哈希表」记录到达某个状态所消耗的步数（同时为了快速判断某个状态是否合法，我们使用 Set 结构对 bank[i] 进行转存）。

​		起始将 start 加入队列，并更新到达 start 所使用的步数为 0，然后进行常规的 BFS 过程：每次取出队头元素，尝试替换当前状态的某一位（基因序列的某个字母），来得到新的状态（限定新状态必须合法，即必须出现在 Set 中）。**如果新状态合法并且没有在记录步数的哈希表中出现过，则将新状态入队并更新得到新状态所用步数**，否则丢弃新状态。

​		重复上述过程直到找到 end（返回具体步数） 或者队列为空（返回 -1）。

**复杂度分析：**

时间复杂度：令 n 为 bank 的数组长度（合法状态数），将 bank 存入 Set 结构复杂度为 $$O(n)$$，每个状态经过一步操作最多拓展出 C = 		32 个新基因（共有 8 个位置，每个位置有 4 个选择），BFS 过程复杂度为 $$O(C * n)$$。整体复杂度为 $$O(C * n)$$
空间复杂度：$$O(n)$$

C++版代码：

```c++
class Solution {
private:
    vector<char> items = {'A', 'C', 'G', 'T'};
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n = bank.size();
        // 为了快速判断某个状态是否合法，使用 Set 结构对 bank[i] 进行转存
        unordered_set<string> bankSet(bank.begin(), bank.end());
        
        unordered_map<string, int> hashMap; // 记录到达某个状态所消耗的步数
        queue<string> que;
        que.push(start);
        hashMap[start] = 0;
        while (!que.empty()) {
            int queSize = que.size();
            for (int i = 0; i < queSize; i++) {
                string cur = que.front();
                que.pop();
                int step = hashMap[cur]; // 当前状态发生了几次变化（走了多少步）
                for (int j = 0; j < cur.size(); j++) {
                    for (int k = 0; k < items.size(); k++) {
                        if (cur[j] == items[k]) continue;
                        string tmp = cur; // 复制一份当前状态
                        tmp[j] = items[k]; // 改变当前状态中的一个字母
                        if (bankSet.find(tmp) == bankSet.end()) continue; // bank 中不存在改变后的状态
                        if (hashMap.find(tmp) != hashMap.end()) continue; // 改变后的状态已经走过了
                        hashMap[tmp] = step + 1;
                        if (tmp == end) return hashMap[tmp]; // 找到 end 状态
                        que.push(tmp);
                    }
                }
            }
        }

        return -1;
    }
}; // 2022.5.7
```

**方法三：【建图 + DFS】**

思路：		

​		由 start 和 bank[i] 组成合法点集，且点集中任意两点之间存在无向边的充要条件是：点 u 和点 v 所代表的字符中，仅有一个位置字符不同。

​		因此我们可以将所有的点存入 数组 中，假设 数组长度为 n。同时为了方便，我们人为确保 start 出现在头部（点编号为 1），end 出现在尾部（点编号为 n）。

​		遍历 数组 进行建图（对于两字符串中仅有一位置不同的点进行连边操作），然后跑一遍从 1 到 n 的 DFS。

由于图中可能有环或无解，因此必须「设定一个最大搜索深度」并增加「最优解剪枝」，确保搜索过程结束。

最大搜索深度的设定可以利用反证法：如果 start 能够到达 end，那么最优路径中必然不存在环（否则可以把环去掉，得到一条更短的路径），即最优路径所经过的点的数量必然不超过 n。

**复杂度分析：**

时间复杂度：令 bank 的长度为 n（即点集的数量级为 n），预处理出 gene的复杂度为 $$O(n)$$；

​		建图操作的复杂度为 O(C * n^2)，其中 C = 8 基因序列长度；

​		DFS 过程由于设定了最大搜索深度，复杂度为 $$O(n^2)$$。整体复杂度为 $$O(C * n^2)$$
空间复杂度：最坏情况下为完全图，复杂度为 $$O(n^2)$$

C++版代码：

```c++
class Solution {
private:
    vector<vector<int>> graph; // 保存基因序列的状态改变图
    int res;
    bool isValid(const string& gene1, const string& gene2) { // 判断两个基因序列是否只有一个字母不同
        int cnt = 0;
        for (int i = 0; i < gene1.size(); i++) {
            if (gene1[i] != gene2[i]) cnt++;
        }
        if (cnt == 1) return true;
        return false;
    }
    void dfs(int from, int end, int depth) {
        if (depth == graph.size()) return; // 剪枝：步数超过了允许变化的最多次数
        if (from == end) { // 如果 start 为 end 基因的编号
            res = min(res, depth);
            return;
        }
        for (auto v : graph[from]) {
            dfs(v, end, depth + 1);
        }
    }
public:
    int minMutation(string start, string end, vector<string>& bank) {
        vector<string> gene; // 存放所有的基因序列
        gene.push_back(start); // 放入 start 基因序列
        bool isFoundEnd = false;
        for (auto str : bank) {
            if (str == start) continue;
            if (str == end) {
                isFoundEnd = true;
                continue;
            }
            gene.push_back(str);
        }
        if (!isFoundEnd) return -1; // bank 中没有 end 基因序列
        gene.push_back(end);
        
        int n = gene.size();
        res = n;
        graph = vector<vector<int>>(n); // start 编号为 0，end 编号为 n - 1
        for (int i = 0; i < n; i++) { // 根据基因序列状态改变进行建图（无向图）
            for (int j = 0; j < n; j++) {
                if (isValid(gene[i], gene[j])) { // 如果两个基因序列只有一个字母不同
                    graph[i].push_back(j);
                    graph[j].push_back(i);
                }
            }
        }
        dfs(0, n - 1, 0); // strat, end, 0
        return res == n ? -1 : res;
    }
}; // 2022.5.7
```

方法四：【双向 BFS】

​		双向 `BFS` 与常规 `BFS` 相比，能够有效解决「搜索空间爆炸」的问题：

![img](https://pic.leetcode-cn.com/1623894968-XELIvK-image.png)

C++版代码：

```c++
class Solution {
private:
    vector<char> items = {'A', 'C', 'G', 'T'};
    unordered_set<string> bankSet;
    int update(queue<string>& que, unordered_map<string, int>& sMap, unordered_map<string, int>& eMap) {
        while (!que.empty()) {
            string cur = que.front();
            que.pop();
            int step = sMap[cur]; // 当前状态发生了几次变化（走了多少步）
            for (int j = 0; j < cur.size(); j++) {
                for (int k = 0; k < items.size(); k++) {
                    if (cur[j] == items[k]) continue;
                    string tmp = cur; // 复制一份当前状态
                    tmp[j] = items[k]; // 改变当前状态中的一个字母
                    if (bankSet.find(tmp) == bankSet.end()) continue; // bank 中不存在改变后的状态
                    if (sMap.find(tmp) != sMap.end()) continue; // 改变后的状态已经走过了
                    if (eMap.find(tmp) != eMap.end()) return eMap[tmp] + step + 1; // 找到 end 状态
                    que.push(tmp);
                    sMap[tmp] = step + 1;
                }
            }
        }
        return -1;
    }
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n = bank.size();
        // 为了快速判断某个状态是否合法，使用 Set 结构对 bank[i] 进行转存
        bankSet = unordered_set<string>(bank.begin(), bank.end());
        if (bankSet.find(end) == bankSet.end()) return -1; // bank 中的基因序列不包含 end
        unordered_map<string, int> sMap; // 记录到达某个状态所消耗的步数
        unordered_map<string, int> eMap; // 记录到达某个状态所消耗的步数
        queue<string> que1;
        queue<string> que2;
        que1.push(start);
        sMap[start] = 0;

        que2.push(end);
        eMap[end] = 0;
        while (!que1.empty() and !que2.empty()) {
            int t = -1;
            if (que1.size() <= que2.size()) t = update(que1, sMap, eMap);
            else t = update(que2, eMap, sMap);
            if (t != - 1) return t;
        }
        return -1;
    }
};; // 2022.5.10
```

方法五：【A*算法】

思路：

​		若不考虑 bank 的限制，对于一个特定状态而言，我们可以任意选择一位替换为 4 类字符之一，因此对于任意状态 x 而言，其与目标状态 end 的「理论最小转换步数」为两者对应位置不同字符的数量，而由于存在 bank 限制，实际最小步数必然满足「大于等于」该理论最小转换步数。

基于此，我们可以计算当前状态到目标状态的「理论最小转换步数」作为启发式函数，进行启发式搜索。

具体的，我们使用优先队列（堆）维护所有的状态，每次优先「启发值 = 理论最小转换步数」的状态进行优先出队拓展。

C++版代码：

```c++
class Solution {
private:
    typedef pair<int, string> pis;
    vector<char> items = {'A', 'C', 'G', 'T'};
    int heuristic(const string& gene1, const string& gene2) { // 计算两个基因序列的距离
        int cnt = 0;
        for (int i = 0; i < gene1.size(); i++) {
            if (gene1[i] != gene2[i]) cnt++;
        }
        return cnt;
    }
public:
    int minMutation(string start, string end, vector<string>& bank) {
        int n = bank.size();
        int dis = heuristic(start, end);
        if (dis > n) return -1; // start 到 end 的步数转化大于 bank 的大小
        // 为了快速判断某个状态是否合法，使用 Set 结构对 bank[i] 进行转存
        unordered_set<string> bankSet(bank.begin(), bank.end());
        unordered_map<string, int> hashMap; // 记录到达某个状态所消耗的步数

        function<bool(pis, pis)> cmp = [] (const pis& a, const pis& b) {
            return a.first > b.first;
        };
        priority_queue<pis, vector<pis>, decltype(cmp)> pque(cmp);
        
        pque.push({dis, start});
        hashMap[start] = 0;
        while (!pque.empty()) {
            int queSize = pque.size();
            for (int i = 0; i < queSize; i++) {
                int dis = pque.top().first;
                string cur = pque.top().second;
                pque.pop();
                int step = hashMap[cur]; // 当前状态发生了几次变化（走了多少步）
                for (int j = 0; j < cur.size(); j++) {
                    for (int k = 0; k < items.size(); k++) {
                        if (cur[j] == items[k]) continue;
                        string tmp = cur; // 复制一份当前状态
                        tmp[j] = items[k]; // 改变当前状态中的一个字母
                        if (bankSet.find(tmp) == bankSet.end()) continue; // bank 中不存在改变后的状态
                        if (hashMap.find(tmp) != hashMap.end()) continue; // 改变后的状态已经走过了
                        hashMap[tmp] = step + 1;
                        if (tmp == end) return hashMap[tmp]; // 找到 end 状态
                        int curDis = heuristic(tmp, end);
                        pque.push({curDis, tmp});
                    }
                }
            }
        }

        return -1;
    }
}; // 2022.5.10
```



#### [2267. 检查是否有合法括号字符串路径](https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/)

难度困难

一个括号字符串是一个 **非空** 且只包含 `'('` 和 `')'` 的字符串。如果下面 **任意** 条件为 **真** ，那么这个括号字符串就是 **合法的** 。

- 字符串是 `()` 。
- 字符串可以表示为 `AB`（`A` 连接 `B`），`A` 和 `B` 都是合法括号序列。
- 字符串可以表示为 `(A)` ，其中 `A` 是合法括号序列。

给你一个 `m x n` 的括号网格图矩阵 `grid` 。网格图中一个 **合法括号路径** 是满足以下所有条件的一条路径：

- 路径开始于左上角格子 `(0, 0)` 。
- 路径结束于右下角格子 `(m - 1, n - 1)` 。
- 路径每次只会向 **下** 或者向 **右** 移动。
- 路径经过的格子组成的括号字符串是 **合法** 的。

如果网格图中存在一条 **合法括号路径** ，请返回 `true` ，否则返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png)

```
输入：grid = [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]]
输出：true
解释：上图展示了两条路径，它们都是合法括号字符串路径。
第一条路径得到的合法字符串是 "()(())" 。
第二条路径得到的合法字符串是 "((()))" 。
注意可能有其他的合法括号字符串路径。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png)

```
输入：grid = [[")",")"],["(","("]]
输出：false
解释：两条可行路径分别得到 "))(" 和 ")((" 。由于它们都不是合法括号字符串，我们返回 false 。
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 100`
- `grid[i][j]` 要么是 `'('` ，要么是 `')'` 。

方法：【DFS + 剪枝优化】

1. 用一个变量 c 表示括号字符串的平衡度：遇到左括号就 +1，遇到右括号就 -1。那么合法字符串等价于任意时刻 $$c ≥ 0$$ 且最后 $$c = 0$$
2. 从起点到终点，往下走的次数是固定的，即 $$m-1$$ 次，往右走的次数也是固定的，即 $$n-1$$ 次，因此路径长度（字符串长度）是一个定值，即 $$(m-1)+(n-1)+1 = m+n-1$$。
3. 极限情况下合法的字符串左半均为左括号，右半均为右括号，因此 c 最大为 $$\dfrac{m+n-1}{2} $$。
   把进入格子前的 c 值当作格子的附加状态，那么一个格子至多有 $$\dfrac{m+n-1}{2}+1=\dfrac{m+n+1}{2}$$  个不同的状态，整个网格图至多有 $$\dfrac{mn(m+n+1)}{2}$$ 个不同的状态。

在这些状态上 DFS：

- 起点为 (0,0,0)，表示从左上角 (0,0) 出发，初始 c=0；
- 终点为 (m-1,n-1,1)，表示到右下角 (m-1,n-1) 结束，且进入前 c=1（因为右下角必须为右括号）；
- 根据当前格子的字符计算 c 值，然后往下或往右移动，继续 DFS。

如何记忆化搜索？

​		代码实现时，由于找到合法路径就返回 true 了，不会继续执行 dfs，**若 dfs(x,y,c) 最后返回的是 false，那后续访问同一个状态时（再次调用 dfs(x,y,c)），仍然会得到 false**。因此没必要重复访问同一个状态，可以用一个 $$\textit{vis}$$ 数组标记，遇到访问过的状态可以直接返回 false。

另外有一个比较强的剪枝优化：由于字符串左括号和右括号的数目必须相同，因此字符串的长度为偶数，所以 $$m+n-1$$ 必须是偶数。我们可以在 DFS 之前就预先判断这一要求是否成立。

复杂度分析
时间复杂度：$$O(mn(m+n))$$，每个状态至多访问一次。
空间复杂度：$$O(mn(m+n))$$，需要记录每个状态是否被访问过。

复盘：

1. 想到了分别记录左括号 '(' 和右括号的个数，但没想到可以用一个 cnt 进行 +1，-1 操作来记录。
2. 想到了最多可以走 $$m+n-1$$ 步。
3. 想到了剪枝，每个格子当前的括号字符串的平衡度 cnt 不能超过 $$m + n - 1 - x - y$$。
4. **没想到可以用记忆化搜索**
5. 这个记忆化搜索确实很重要，自己解题的时候完全没有意识到要进行记忆化搜索

C++版本代码：

```c++
class Solution {
public:
    bool hasValidPath(vector<vector<char>> &grid) {
        int m = grid.size(), n = grid[0].size();
        if ((m + n) % 2 == 0 || grid[0][0] == ')' || grid[m - 1][n - 1] == '(') return false; // 剪枝
        bool vis[m][n][(m + n + 1) / 2]; 
        memset(vis, 0, sizeof(vis));
        function<bool(int, int, int)> dfs = [&](int x, int y, int c) -> bool {
            if (c > m - x + n - y - 1) return false; // 剪枝：即使后面都是 ')' 也不能将 c 减为 0
            if (x == m - 1 && y == n - 1) return c == 1; // 终点一定是 ')'
            if (vis[x][y][c]) return false; // 重复访问
            vis[x][y][c] = true;
            c += grid[x][y] == '(' ? 1 : -1;
            return c >= 0 && (x < m - 1 && dfs(x + 1, y, c) || y < n - 1 && dfs(x, y + 1, c)); // 往下或者往右
        };
        return dfs(0, 0, 0);
    }
}; // 2022.5.9
```

#### [1293. 网格中的最短路径](https://leetcode.cn/problems/shortest-path-in-a-grid-with-obstacles-elimination/)

难度困难180

给你一个 `m * n` 的网格，其中每个单元格不是 `0`（空）就是 `1`（障碍物）。每一步，您都可以在空白单元格中上、下、左、右移动。

如果您 **最多** 可以消除 `k` 个障碍物，请找出从左上角 `(0, 0)` 到右下角 `(m-1, n-1)` 的最短路径，并返回通过该路径所需的步数。如果找不到这样的路径，则返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/09/30/short1-grid.jpg)

```
输入： grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1
输出：6
解释：
不消除任何障碍的最短路径是 10。
消除位置 (3,2) 处的障碍后，最短路径是 6 。该路径是 (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2).
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/09/30/short2-grid.jpg)

```
输入：grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1
输出：-1
解释：我们至少需要消除两个障碍才能找到这样的路径。
```

 

**提示：**

- `grid.length == m`
- `grid[0].length == n`
- `1 <= m, n <= 40`
- `1 <= k <= m*n`
- `grid[i][j]` 是 `0` 或 `1`
- `grid[0][0] == grid[m-1][n-1] == 0`

### 2242. 节点序列的最大得分（不会）（第288场周赛）

[2242.节点序列的最大得分](https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/)

给你一个 `n` 个节点的 **无向图** ，节点编号为 `0` 到 `n - 1` 。

给你一个下标从 **0** 开始的整数数组 `scores` ，其中 `scores[i]` 是第 `i` 个节点的分数。同时给你一个二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` ，表示节点 `ai` 和 `bi` 之间有一条 **无向** 边。

一个合法的节点序列如果满足以下条件，我们称它是 **合法的** ：

- 序列中每 **相邻** 节点之间有边相连。
- 序列中没有节点出现超过一次。

节点序列的分数定义为序列中节点分数之 **和** 。

请你返回一个长度为 `4` 的合法节点序列的最大分数。如果不存在这样的序列，请你返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png)

```
输入：scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
输出：24
解释：上图为输入的图，节点序列为 [0,1,2,3] 。
节点序列的分数为 5 + 2 + 9 + 8 = 24 。
观察可知，没有其他节点序列得分和超过 24 。
注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。
序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/17/ex2.png)

```
输入：scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]
输出：-1
解释：上图为输入的图。
没有长度为 4 的合法序列，所以我们返回 -1 。
```

 

**提示：**

- `n == scores.length`
- `4 <= n <= 5 * 104`
- `1 <= scores[i] <= 108`
- `0 <= edges.length <= 5 * 104`
- `edges[i].length == 2`
- `0 <= ai, bi <= n - 1`
- `ai != bi`
- 不会有重边。

思路：（别人的作题思路）

**提示 1-1**
试试枚举可不可以。（做题时优先考虑最简单的算法）

**提示 1-2**
枚举谁呢？可以枚举点，也可以枚举边。

**提示 2-1**
简化问题可以帮助我们找到思路。

如果序列只要求 33 个点，要如何枚举？

**提示 2-2**
只要求 33 个点的话，可以枚举端点，也可以枚举中间的点。

**提示 2-3**
枚举中间的点是最方便的，算出与其相邻的分数最大的两个点即可。

另外相比枚举端点，枚举中间的效率也要更高。

顺着这个思路去思考原问题。

**提示 3-1**
设序列为 a-x-y-b（− 表示边），枚举 edges 中的每条边，作为序列正中间的那条边，即 x-y。

**提示 3-2**
我们需要把与 x 相邻的点中，分数最大且不同于 y 和 b 的点作为 a；把与 y 相邻的点中，分数最大且不同于 x 和 a 的点作为 b。

**提示 3-3**
与 x 相邻的点中，由于只需要与 y 和 b 不一样，我们仅需要保留分数最大的三个点，a 必定在这三个点中。

**提示 3-4**
剩下要做的，就是在枚举edges 前，预处理出这三个点。

代码实现时，可以用排序（见 Go 和 Java）、堆（见 Python nlargest）、分治（见 C++ nth_element）或者手动维护求前三大。最优的时间复杂度为 O(n+m)。
**C++版代码：**

```c++
class Solution {
public:
    int maximumScore(vector<int> &scores, vector<vector<int>> &edges) {
        int n = scores.size();
        vector<vector<pair<int, int>>> graph(n);
        for (auto &e : edges) {
            int x = e[0], y = e[1];
            graph[x].emplace_back(-scores[y], y);
            graph[y].emplace_back(-scores[x], x);
        }
        for (auto &vs : graph)
            if (vs.size() > 3) { // 排序取前三
                nth_element(vs.begin(), vs.begin() + 3, vs.end());
                vs.resize(3);
            }

        int ans = -1;
        // a - x - y - b
        // a — x — y — b,其中枚举的是x——y这条边,那么要想和的值最大,那么就需要找出a与b的最大值
        // 找出a中不与y和b重合的最大值(肯定不与x重合,因为a是x相邻的边)
        // 同理找出b中不与x和a重合的最大值(肯定不与y重合,因为b是y相邻的边)
        // 因此找出a相邻边的最大的那三条,那么a必定会取到其中一条是符合要求的最长边(利用排序)
        // 因为与 a 相邻的边最多与 y 和 b 相同，那么只要与 a 相邻的有 3 条边，必定有一条边的节点不等于 x，y，b
        for (auto &e : edges) {
            int x = e[0], y = e[1]; // 枚举的当前这条边是 u->v
            for (auto &[score_a, a] : graph[x]) // /枚举 x 前三个最大的分数点
                for (auto &[score_b, b] : graph[y])
                    if (a != y && b != x && a != b) // 这几个点互不相同，就更新答案
                        ans = max(ans, -score_a + scores[x] + scores[y] - score_b);
        }
        return ans;
    }
}; // 2022.4.22
```

**Python版代码：**

```python
class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
        g = [[] for _ in range(len(scores))]
        for x, y in edges:
            g[x].append((scores[y], y))
            g[y].append((scores[x], x))
        for i, vs in enumerate(g):
            g[i] = nlargest(3, vs)

        # 下面这一段可以简写成一行，为了可读性这里就不写了
        ans = -1
        for x, y in edges:
            for (score_a, a), (score_b, b) in product(g[x], g[y]):
                if y != a != b != x:
                    ans = max(ans, score_a + scores[x] + scores[y] + score_b)
        return ans
```

### [面试题 08.02. 迷路的机器人](https://leetcode.cn/problems/robot-in-a-grid-lcci/)

难度中等91

设想有个机器人坐在一个网格的左上角，网格 r 行 c 列。机器人只能向下或向右移动，但不能走到一些被禁止的网格（有障碍物）。设计一种算法，寻找机器人从左上角移动到右下角的路径。

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/22/robot_maze.png)

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

返回一条可行的路径，路径由经过的网格的行号和列号组成。左上角为 0 行 0 列。如果没有可行的路径，返回空数组。

**示例 1:**

```
输入:
[
  [0,0,0],
  [0,1,0],
  [0,0,0]
]
输出: [[0,0],[0,1],[0,2],[1,2],[2,2]]
解释: 
输入中标粗的位置即为输出表示的路径，即
0行0列（左上角） -> 0行1列 -> 0行2列 -> 1行2列 -> 2行2列（右下角）
```

**说明：***r* 和 *c* 的值均不超过 100。

方法：【DFS + 记忆化搜索】

C++版代码：

```c++
class Solution {
private:
    static constexpr int dirs[2][2] = {{1, 0}, {0, 1}};
    // 将 (x, y) 按 1000 * x + y 进行索引
    unordered_map<int, bool> hashMap; // 记忆化存储, 单元格 (x, y) 是否可到达终点(m - 1, n - 1)
    unordered_map<int, vector<vector<int>>> pathMap;
    bool dfs(vector<vector<int>>& obstacleGrid, int x, int y) {
        if (obstacleGrid[x][y] == 1) {
            hashMap[x * 1000 + y] = false;
            return false;
        }
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        if (x == m - 1 and y == n - 1) { // 到达终点
            hashMap[x * 1000 + y] = true;
            pathMap[x * 1000 + y] = {{x, y}};
            return true;
        }
        hashMap[x * 1000 + y] = false;
        
        for (auto dir : dirs) {
            int nx = x + dir[0];
            int ny = y + dir[1];
            if (nx < 0 or nx >= m or ny < 0 or ny >= n) continue; // 越界
            if (hashMap.find(nx * 1000 + ny) == hashMap.end()) { // 没访问过
                dfs(obstacleGrid, nx, ny);
            }
            if (hashMap[nx * 1000 + ny]) {
                auto path = pathMap[nx * 1000 + ny];
                path.push_back({x, y});
                pathMap[x * 1000 + y] = path;
                hashMap[x * 1000 + y] = true;
                return true;
            }
            
        }
        return hashMap[x * 1000 + y];
    }
public:
    vector<vector<int>> pathWithObstacles(vector<vector<int>>& obstacleGrid) {
        int m = obstacleGrid.size();
        int n = obstacleGrid[0].size();
        vector<vector<int>> res;
        if (obstacleGrid[0][0] == 1) return res; // 初始点有障碍物
        if (obstacleGrid[m - 1][n - 1] == 1) return res; // 终点有障碍物
        dfs(obstacleGrid, 0, 0);
        if (hashMap[0]) {
            res = pathMap[0];
            reverse(res.begin(), res.end());
        }
        return res;
    }
}; // 2022.5.12
```

方法二：【回溯】

C++版代码：

```c++
class Solution {
public:
    bool find = false;
    static constexpr int dirs[2][2] = {{0, 1}, {1, 0}};
    vector<vector<int>> path;
    bool backTracking(const vector<vector<int>>& grids, vector<vector<bool>>& visited, int x, int y) {
        int m = grids.size();
        int n = grids[0].size();
        if (x == m - 1 && y == n - 1) { // 到达终点
            find = true;
            return true;
        }
        for (auto dir : dirs) {
            int nx = x + dir[0];
            int ny = y + dir[1];
            if (nx < 0 or nx >= m or ny < 0 or ny >= n) continue; // 越界
            if (!visited[nx][ny] && !grids[nx][ny]) {
                visited[nx][ny] = true;
                path.push_back({nx, ny});
                if (backTracking(grids, visited, nx, ny)) return true;
                // 如果前后左右都能走，那么回溯的时候visited要置成false
                // visited[nx][ny] = false;
                path.pop_back(); // 回溯
            }
        }
        return false;
    }

    vector<vector<int>> pathWithObstacles(vector<vector<int>>& obstacleGrid) {
        int rows = obstacleGrid.size();
        int cols = obstacleGrid[0].size();
        if (obstacleGrid[0][0] or obstacleGrid[rows - 1][cols - 1]) return {};
        vector<vector<bool>> visited(rows, vector<bool>(cols, false));
        
        visited[0][0] = true;
        path.push_back({0, 0});
        backTracking(obstacleGrid, visited, 0, 0);
        if (find) return path;
        return {};
    }
}; // 2022.5.12
```

