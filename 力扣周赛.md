# 力扣周赛

第 293 场周赛-2022.5.15

#### [2276. 统计区间中的整数数目](https://leetcode.cn/problems/count-integers-in-intervals/)

难度困难

给你区间的 **空** 集，请你设计并实现满足要求的数据结构：

- **新增：**添加一个区间到这个区间集合中。
- **统计：**计算出现在 **至少一个** 区间中的整数个数。

实现 `CountIntervals` 类：

- `CountIntervals()` 使用区间的空集初始化对象
- `void add(int left, int right)` 添加区间 `[left, right]` 到区间集合之中。
- `int count()` 返回出现在 **至少一个** 区间中的整数个数。

**注意：**区间 `[left, right]` 表示满足 `left <= x <= right` 的所有整数 `x` 。

 

**示例 1：**

```
输入
["CountIntervals", "add", "add", "count", "add", "count"]
[[], [2, 3], [7, 10], [], [5, 8], []]
输出
[null, null, null, 6, null, 8]

解释
CountIntervals countIntervals = new CountIntervals(); // 用一个区间空集初始化对象
countIntervals.add(2, 3);  // 将 [2, 3] 添加到区间集合中
countIntervals.add(7, 10); // 将 [7, 10] 添加到区间集合中
countIntervals.count();    // 返回 6
                           // 整数 2 和 3 出现在区间 [2, 3] 中
                           // 整数 7、8、9、10 出现在区间 [7, 10] 中
countIntervals.add(5, 8);  // 将 [5, 8] 添加到区间集合中
countIntervals.count();    // 返回 8
                           // 整数 2 和 3 出现在区间 [2, 3] 中
                           // 整数 5 和 6 出现在区间 [5, 8] 中
                           // 整数 7 和 8 出现在区间 [5, 8] 和区间 [7, 10] 中
                           // 整数 9 和 10 出现在区间 [7, 10] 中
```

 

**提示：**

- `1 <= left <= right <= 109`
- 最多调用 `add` 和 `count` 方法 **总计** `105` 次
- 调用 `count` 方法至少一次

方法：【线段树板子题】

​		周赛的时候看出来了，就是自己不熟悉代码

C++版代码：

```c++
struct Node {
    int v, lz, ls, rs;
    Node(): v(0), lz(0), ls(0), rs(0) {}
};
class SegTree {
    vector<Node> tr;
    int cnt;
    void push_down(int p, int len) {
        if (!tr[p].ls) tr[p].ls = ++cnt, tr.emplace_back(Node{});
        if (!tr[p].rs) tr[p].rs = ++cnt, tr.emplace_back(Node{});
        if (!tr[p].lz) return;
        int lz = tr[p].lz;
        tr[tr[p].ls].v = len / 2 * lz;
        tr[tr[p].rs].v = (len - len / 2) * lz;
        tr[tr[p].ls].lz = tr[tr[p].rs].lz = lz;
        tr[p].lz = 0;
    }
    void push_up(int p) {
        tr[p].v = tr[tr[p].ls].v + tr[tr[p].rs].v;
    }
public:
    SegTree(): tr(1), cnt(0) {}

    void modify(int l, int r, int L, int R, int v, int p = 0) {
        if (l <= L && r >= R) {
            tr[p].lz = v, tr[p].v = v * (R - L + 1);
            return;
        }
        int mid = (L + R - 1) / 2;
        push_down(p, R - L + 1);
        if (mid >= l) modify(l, r, L, mid, v, tr[p].ls);
        if (mid < r) modify(l, r, mid + 1, R, v, tr[p].rs);
        push_up(p);
    }

    int query(int l, int r, int L, int R, int p = 0) {
        if (l <= L && r >= R) return tr[p].v;
        int mid = (L + R - 1) / 2, ret = 0;
        push_down(p, R - L + 1);
        if (mid >= l) ret += query(l, r, L, mid, tr[p].ls);
        if (mid < r) ret += query(l, r, mid + 1, R, tr[p].rs);
        return ret;
    }
};

class CountIntervals {
    SegTree seg;
    int M = 1e9;
public:
    CountIntervals() {

    }
    
    void add(int l, int r) {
        seg.modify(l, r, 1, M, 1);
    }
    
    int count() {
        return seg.query(1, M, 1, M);
    }
};

/**
 * Your CountIntervals object will be instantiated and called as such:
 * CountIntervals* obj = new CountIntervals();
 * obj->add(left,right);
 * int param_2 = obj->count();
 */
```



## 第 78 场双周赛-2022.5.14

### 6069. 最大波动的子字符串

字符串的 **波动** 定义为子字符串中出现次数 **最多** 的字符次数与出现次数 **最少** 的字符次数之差。

给你一个字符串 `s` ，它只包含小写英文字母。请你返回 `s` 里所有 **子字符串的** **最大波动** 值。

**子字符串** 是一个字符串的一段连续字符序列。

 

**示例 1：**

```
输入：s = "aababbb"
输出：3
解释：
所有可能的波动值和它们对应的子字符串如以下所示：
- 波动值为 0 的子字符串："a" ，"aa" ，"ab" ，"abab" ，"aababb" ，"ba" ，"b" ，"bb" 和 "bbb" 。
- 波动值为 1 的子字符串："aab" ，"aba" ，"abb" ，"aabab" ，"ababb" ，"aababbb" 和 "bab" 。
- 波动值为 2 的子字符串："aaba" ，"ababbb" ，"abbb" 和 "babb" 。
- 波动值为 3 的子字符串 "babbb" 。
所以，最大可能波动值为 3 。
```

**示例 2：**

```
输入：s = "abcde"
输出：0
解释：
s 中没有字母出现超过 1 次，所以 s 中每个子字符串的波动值都是 0 。
```

 

**提示：**

- `1 <= s.length <= 104`
- `s` 只包含小写英文字母。

方法：

思路：

​		以 s[i] 结尾的子串，可以看成是以 s[i - 1] 结尾的子串，在末尾添加上 s[i] 组成。

分类讨论：

1. 若字符 s[i] 之前没出现过：则以 s[i] 字符结尾的子串的出现次数 **最多** 的字符次数不变，出现次数 **最少** 的字符次数为 1。
2. 若字符 s[i] 之前出现过，又可以分为两种情况：第一种：字符 s[i] **不为**之前出现次数**最少** 的字符；第二种：字符 s[i] **为**之前出现次数**最少** 的字符。

- 第一种：字符 s[i] **不为**之前出现次数**最少** 的字符，则判断 s[i] 是否为出现次数 **最多** 的字符。
  - 如果是出现次数 **最多** 的字符，则更新出现次数 **最多** 的字符次数，计算结果。
  - 如果是不是出现次数 **最多** 的字符，跳过。

- 第二种：字符 s[i] **为**之前出现次数**最少** 的字符。
  - 寻找出现次数 **最少** 的字符次数，并计算结果。

C++版本代码：

## 第 292 场周赛-2022.5.8

#### [6056. 字符串中最大的 3 位相同数字](https://leetcode.cn/problems/largest-3-same-digit-number-in-string/)（SE）

难度简单

给你一个字符串 `num` ，表示一个大整数。如果一个整数满足下述所有条件，则认为该整数是一个 **优质整数** ：

- 该整数是 `num` 的一个长度为 `3` 的 **子字符串** 。
- 该整数由唯一一个数字重复 `3` 次组成。

以字符串形式返回 **最大的优质整数** 。如果不存在满足要求的整数，则返回一个空字符串 `""` 。

**注意：**

- **子字符串** 是字符串中的一个连续字符序列。
- `num` 或优质整数中可能存在 **前导零** 。

 

**示例 1：**

```
输入：num = "6777133339"
输出："777"
解释：num 中存在两个优质整数："777" 和 "333" 。
"777" 是最大的那个，所以返回 "777" 。
```

**示例 2：**

```
输入：num = "2300019"
输出："000"
解释："000" 是唯一一个优质整数。
```

**示例 3：**

```
输入：num = "42352338"
输出：""
解释：不存在长度为 3 且仅由一个唯一数字组成的整数。因此，不存在优质整数。
```

 

**提示：**

- `3 <= num.length <= 1000`
- `num` 仅由数字（`0` - `9`）组成

C++版代码：

```c++
class Solution {
public:
    string largestGoodInteger(string num) {
        string res = "";
        for (int i = 1; i < num.size() - 1; i++) {
            if (num[i] == num[i - 1] and num[i] == num[i + 1]) {
                if (res == "") res.append(3, num[i]);
                else if (num[i] - '0' >= res[0] - '0') {
                    res = "";
                    res.append(3, num[i]);
                }
                i++;
            }
        }
        return res;
    }
}; // 2022.5.8
```

#### [6057. 统计值等于子树平均值的节点数](https://leetcode.cn/problems/count-nodes-equal-to-average-of-subtree/)（SE）

难度中等7

给你一棵二叉树的根节点 `root` ，找出并返回满足要求的节点数，要求节点的值等于其 **子树** 中值的 **平均值** 。

**注意：**

- `n` 个元素的平均值可以由 `n` 个元素 **求和** 然后再除以 `n` ，并 **向下舍入** 到最近的整数。
- `root` 的 **子树** 由 `root` 和它的所有后代组成。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/15/image-20220315203925-1.png)

```
输入：root = [4,8,5,0,1,null,6]
输出：5
解释：
对值为 4 的节点：子树的平均值 (4 + 8 + 5 + 0 + 1 + 6) / 6 = 24 / 6 = 4 。
对值为 5 的节点：子树的平均值 (5 + 6) / 2 = 11 / 2 = 5 。
对值为 0 的节点：子树的平均值 0 / 1 = 0 。
对值为 1 的节点：子树的平均值 1 / 1 = 1 。
对值为 6 的节点：子树的平均值 6 / 1 = 6 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/26/image-20220326133920-1.png)

```
输入：root = [1]
输出：1
解释：对值为 1 的节点：子树的平均值 1 / 1 = 1。
```

 

**提示：**

- 树中节点数目在范围 `[1, 1000]` 内
- `0 <= Node.val <= 1000`

方法：【二叉树后序遍历】

C++版代码：

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
private:
    int res;
    vector<int> inorder(TreeNode* root) {
        vector<int> leftSum = {0, 0};
        if (root->left) {
            leftSum = inorder(root->left);
        }
        vector<int> rightSum = {0, 0};
        if (root->right) {
            rightSum = inorder(root->right);
        }
        int sum = leftSum[0] + rightSum[0] + root->val;
        int cnt = leftSum[1] + rightSum[1] + 1;
        //cout << "root" << root->val << " sum = " << sum << " cnt = " << cnt << endl;
        if ((sum / cnt) == root->val) {
            res++;
        } 
        return {sum, cnt};
    }
public:
    int averageOfSubtree(TreeNode* root) {
        res = 0;
        if (root == nullptr) return res;
        inorder(root);
        return res;
    }
}; // 2022.5.8
```

#### [6058. 统计打字方案数](https://leetcode.cn/problems/count-number-of-texts/)

难度中等15

Alice 在给 Bob 用手机打字。数字到字母的 **对应** 如下图所示。

![img](https://assets.leetcode.com/uploads/2022/03/15/1200px-telephone-keypad2svg.png)

为了 **打出** 一个字母，Alice 需要 **按** 对应字母 `i` 次，`i` 是该字母在这个按键上所处的位置。

- 比方说，为了按出字母 `'s'` ，Alice 需要按 `'7'` 四次。类似的， Alice 需要按 `'5'` 两次得到字母 `'k'` 。
- 注意，数字 `'0'` 和 `'1'` 不映射到任何字母，所以 Alice **不** 使用它们。

但是，由于传输的错误，Bob 没有收到 Alice 打字的字母信息，反而收到了 **按键的字符串信息** 。

- 比方说，Alice 发出的信息为 `"bob"` ，Bob 将收到字符串 `"2266622"` 。

给你一个字符串 `pressedKeys` ，表示 Bob 收到的字符串，请你返回 Alice **总共可能发出多少种文字信息** 。

由于答案可能很大，将它对 `109 + 7` **取余** 后返回。

 

**示例 1：**

```
输入：pressedKeys = "22233"
输出：8
解释：
Alice 可能发出的文字信息包括：
"aaadd", "abdd", "badd", "cdd", "aaae", "abe", "bae" 和 "ce" 。
由于总共有 8 种可能的信息，所以我们返回 8 。
```

**示例 2：**

```
输入：pressedKeys = "222222222222222222222222222222222222"
输出：82876089
解释：
总共有 2082876103 种 Alice 可能发出的文字信息。
由于我们需要将答案对 109 + 7 取余，所以我们返回 2082876103 % (109 + 7) = 82876089 。
```

 

**提示：**

- `1 <= pressedKeys.length <= 105`
- `pressedKeys` 只包含数字 `'2'` 到 `'9'` 。

方法：【分组 + 线性 DP + 乘法原理】要想到爬楼梯的思路呀。。

思路：

​		把相同字符分为一组，然后对每一组相同字符进行爬楼梯计算排列方法数，由于不同组之间互不影响，根据乘法原理，把不同组的文字信息种类数相乘，得到答案。

**完全没看破爬楼梯这个思路，还是看了评论区后写出了代码。**

C++版代码：

```c++
class Solution {
private:
    const int MOD = 1e9 + 7;
    const vector<string> letterMap = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
    int getCnt(int n, int k) { // 爬楼梯的思路，n 阶楼梯，一次可以爬 [1, k] 个
        vector<int> dp(n + 1, 0);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= k; j++) {
                if (i - j >= 0) {
                    dp[i] = (dp[i] + dp[i - j]) % MOD;
                }
            }
        }
        return dp[n];
    }
public:
    int countTexts(string pressedKeys) {
        long long res = 1;
        pressedKeys += '0'; // 添加一个多余字符 '0' 方便后面的处理
        int n = pressedKeys.size();
        int length = 1;
        for (int i = 1; i < n; i++) {
            if (pressedKeys[i] != pressedKeys[i - 1]) {
                int k = letterMap[pressedKeys[i - 1] - '0'].size(); // 计算爬一次楼梯的 k 值
                res = res % MOD * getCnt(length, k) % MOD;
                length = 1;
            } else {
                length++;
            }
        }
        return res;
    }
}; // 2022.5.8
```



#### [6059. 检查是否有合法括号字符串路径](https://leetcode.cn/problems/check-if-there-is-a-valid-parentheses-string-path/)

难度困难

一个括号字符串是一个 **非空** 且只包含 `'('` 和 `')'` 的字符串。如果下面 **任意** 条件为 **真** ，那么这个括号字符串就是 **合法的** 。

- 字符串是 `()` 。
- 字符串可以表示为 `AB`（`A` 连接 `B`），`A` 和 `B` 都是合法括号序列。
- 字符串可以表示为 `(A)` ，其中 `A` 是合法括号序列。

给你一个 `m x n` 的括号网格图矩阵 `grid` 。网格图中一个 **合法括号路径** 是满足以下所有条件的一条路径：

- 路径开始于左上角格子 `(0, 0)` 。
- 路径结束于右下角格子 `(m - 1, n - 1)` 。
- 路径每次只会向 **下** 或者向 **右** 移动。
- 路径经过的格子组成的括号字符串是 **合法** 的。

如果网格图中存在一条 **合法括号路径** ，请返回 `true` ，否则返回 `false` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/15/example1drawio.png)

```
输入：grid = [["(","(","("],[")","(",")"],["(","(",")"],["(","(",")"]]
输出：true
解释：上图展示了两条路径，它们都是合法括号字符串路径。
第一条路径得到的合法字符串是 "()(())" 。
第二条路径得到的合法字符串是 "((()))" 。
注意可能有其他的合法括号字符串路径。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/15/example2drawio.png)

```
输入：grid = [[")",")"],["(","("]]
输出：false
解释：两条可行路径分别得到 "))(" 和 ")((" 。由于它们都不是合法括号字符串，我们返回 false 。
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 100`
- `grid[i][j]` 要么是 `'('` ，要么是 `')'` 。

方法：【DFS + 剪枝优化】

1. 
   用一个变量 c 表示括号字符串的平衡度：遇到左括号就 +1，遇到右括号就 -1。那么合法字符串等价于任意时刻 $$c ≥ 0$$ 且最后 $$c = 0$$
2. 从起点到终点，往下走的次数是固定的，即 $$m-1$$ 次，往右走的次数也是固定的，即 $$n-1$$ 次，因此路径长度（字符串长度）是一个定值，即 $$(m-1)+(n-1)+1 = m+n-1$$。
3. 极限情况下合法的字符串左半均为左括号，右半均为右括号，因此 c 最大为 $$\dfrac{m+n-1}{2} $$。
   把进入格子前的 c 值当作格子的附加状态，那么一个格子至多有 $$\dfrac{m+n-1}{2}+1=\dfrac{m+n+1}{2}$$  个不同的状态，整个网格图至多有 $$\dfrac{mn(m+n+1)}{2}$$ 个不同的状态。

在这些状态上 DFS：

- 起点为 (0,0,0)，表示从左上角 (0,0) 出发，初始 c=0；
- 终点为 (m-1,n-1,1)，表示到右下角 (m-1,n-1) 结束，且进入前 c=1（因为右下角必须为右括号）；
- 根据当前格子的字符计算 c 值，然后往下或往右移动，继续 DFS。

如何记忆化搜索？

​		代码实现时，由于找到合法路径就返回 true 了，不会继续执行 dfs，**若 dfs(x,y,c) 最后返回的是 false，那后续访问同一个状态时（再次调用 dfs(x,y,c)），仍然会得到 false**。因此没必要重复访问同一个状态，可以用一个 $$\textit{vis}$$ 数组标记，遇到访问过的状态可以直接返回 false。

另外有一个比较强的剪枝优化：由于字符串左括号和右括号的数目必须相同，因此字符串的长度为偶数，所以 $$m+n-1$$ 必须是偶数。我们可以在 DFS 之前就预先判断这一要求是否成立。

复杂度分析
时间复杂度：$$O(mn(m+n))$$，每个状态至多访问一次。
空间复杂度：$$O(mn(m+n))$$，需要记录每个状态是否被访问过。

复盘：

1. 想到了分别记录左括号 '(' 和右括号的个数，但没想到可以用一个 cnt 进行 +1，-1 操作来记录。
2. 想到了最多可以走 $$m+n-1$$ 步。
3. 想到了剪枝，每个格子当前的括号字符串的平衡度 cnt 不能超过 $$m + n - 1 - x - y$$。
4. **没想到可以用记忆化搜索**
5. 这个记忆化搜索确实很重要，自己解题的时候完全没有意识到要进行记忆化搜索

C++版本代码：

```c++
class Solution {
public:
    bool hasValidPath(vector<vector<char>> &grid) {
        int m = grid.size(), n = grid[0].size();
        if ((m + n) % 2 == 0 || grid[0][0] == ')' || grid[m - 1][n - 1] == '(') return false; // 剪枝
        bool vis[m][n][(m + n + 1) / 2]; 
        memset(vis, 0, sizeof(vis));
        function<bool(int, int, int)> dfs = [&](int x, int y, int c) -> bool {
            if (c > m - x + n - y - 1) return false; // 剪枝：即使后面都是 ')' 也不能将 c 减为 0
            if (x == m - 1 && y == n - 1) return c == 1; // 终点一定是 ')'
            if (vis[x][y][c]) return false; // 重复访问
            vis[x][y][c] = true;
            c += grid[x][y] == '(' ? 1 : -1;
            return c >= 0 && (x < m - 1 && dfs(x + 1, y, c) || y < n - 1 && dfs(x, y + 1, c)); // 往下或者往右
        };
        return dfs(0, 0, 0);
    }
}; // 2022.5.9
```



## 第 291 场周赛-2022.5.1

#### [2259. 移除指定数字得到的最大结果](https://leetcode.cn/problems/remove-digit-from-number-to-maximize-result/)（SE）

给你一个表示某个正整数的字符串 `number` 和一个字符 `digit` 。

从 `number` 中 **恰好** 移除 **一个** 等于 `digit` 的字符后，找出并返回按 **十进制** 表示 **最大** 的结果字符串。生成的测试用例满足 `digit` 在 `number` 中出现至少一次。

 

**示例 1：**

```
输入：number = "123", digit = "3"
输出："12"
解释："123" 中只有一个 '3' ，在移除 '3' 之后，结果为 "12" 。
```

**示例 2：**

```
输入：number = "1231", digit = "1"
输出："231"
解释：可以移除第一个 '1' 得到 "231" 或者移除第二个 '1' 得到 "123" 。
由于 231 > 123 ，返回 "231" 。
```

**示例 3：**

```
输入：number = "551", digit = "5"
输出："51"
解释：可以从 "551" 中移除第一个或者第二个 '5' 。
两种方案的结果都是 "51" 。
```

 

**提示：**

- `2 <= number.length <= 100`
- `number` 由数字 `'1'` 到 `'9'` 组成
- `digit` 是 `'1'` 到 `'9'` 中的一个数字
- `digit` 在 `number` 中出现至少一次

**方法一：暴力搜索**

​		对每个查找到的 digit 字符，都进行一次结果计算，最后返回最大的结果字符串。

C++版代码：

```c++
class Solution {
public:
    string removeDigit(string number, char digit) {
        int n = number.size();
        string res = "0";
        for (int i = 0; i < n; i++) {
            if (number[i] == digit) {
                string tmp = number.substr(0, i) + number.substr(i + 1);
                res = max(res, tmp);
            }
        }
        return res;
    }
}; // 2022.5.2
```

**方法二：贪心**（周赛里自己提交的代码）

题意：

​		从 `number` 中 **恰好** 移除 **一个** 等于 `digit` 的字符后，找出并返回按 **十进制** 表示 **最大** 的结果字符串。		

​		根据题意，最大的结果字符串一定为移除第一个 digit 字符，且该位置的 digit 字符一定小于其后一个字符。

即：`number[i] == digit and number[i] < number[i + 1]`

​		如果未查找到上面条件的字符 `digit`，则移除最后找到的一个 `digit`。

C++版代码：

```c++
class Solution {
public:
    string removeDigit(string number, char digit) {
        int n = number.size();
        int pos = -1;
        int resPos = -1;
        for (int i = 0; i < n; i++) {
            if (number[i] == digit) {
                if (i == n - 1 or number[i] < number[i + 1]) { // 判断条件是否符合
                    pos = i;
                    resPos = i;
                    break;
                }
                pos = i;
            }
        }
        string res = "";
        if (resPos == -1) { // 如果没找到符合条件的字符 digit
            res = number.substr(0, pos) + number.substr(pos + 1);
        } else { // 如果找到
            res = number.substr(0, resPos) + number.substr(resPos + 1);
        }
        return res;
    }
}; // 2022.5.1
```

#### [2260. 必须拿起的最小连续卡牌数](https://leetcode.cn/problems/minimum-consecutive-cards-to-pick-up/)（SE）

给你一个整数数组 `cards` ，其中 `cards[i]` 表示第 `i` 张卡牌的 **值** 。如果两张卡牌的值相同，则认为这一对卡牌 **匹配** 。

返回你必须拿起的最小连续卡牌数，以使在拿起的卡牌中有一对匹配的卡牌。如果无法得到一对匹配的卡牌，返回 `-1` 。

 

**示例 1：**

```
输入：cards = [3,4,2,3,4,7]
输出：4
解释：拿起卡牌 [3,4,2,3] 将会包含一对值为 3 的匹配卡牌。注意，拿起 [4,2,3,4] 也是最优方案。
```

**示例 2：**

```
输入：cards = [1,0,5,3]
输出：-1
解释：无法找出含一对匹配卡牌的一组连续卡牌。
```

 

**提示：**

- `1 <= cards.length <= 105`
- `0 <= cards[i] <= 106`

**方法一：滑动窗口**

思路：

​		用 `unordered_set<int> hashSet` 做滑动窗口，保存当前的连续卡牌，用 `left` 保存滑动窗口的左端下标。

​		遍历 `cards` 数组中所有元素。每当遍历到的 `cards[i]`  在滑动窗口中存在，就缩小滑动窗口将 `left` 向后移动找到 `cards[left] == cards[i]` 的新下标 `left`，并计算结果（最小连续卡牌数）。

周赛中不小心将缩小滑动窗口的代码写反了，如下：导致一直错，调试了N久。。。。

**时间复杂度：$$O(N)$$**

**空间复杂度：$$O(N)$$**

```c++
while (cards[left] != cards[i]) { // 找到滑动窗口中值为 cards[i] 的 left 值
    left++;
    hashSet.erase(cards[left]);
}
```

C++版代码：

```c++
class Solution {
public:
    int minimumCardPickup(vector<int>& cards) {
        unordered_set<int> hashSet;
        int n = cards.size();
        int res = INT_MAX;
        int left = 0;
        
        for (int i = 0; i < n; i++) {
            if (hashSet.find(cards[i]) == hashSet.end()) { // 没找到等于 cards[i]
                hashSet.insert(cards[i]);
            } else if (hashSet.find(cards[i]) != hashSet.end()){ // 找到等于 cards[i]
                while (cards[left] != cards[i]) { // 找到滑动窗口中值为 cards[i] 的 left 值
                    hashSet.erase(cards[left]);
                    left++;
                }
                res = min(res, i - left + 1);
                hashSet.erase(cards[left++]);
                hashSet.insert(cards[i]);
            }
        }
        if (res == INT_MAX) res = -1;
        return res;
    }
}; // 2022.5.1
```

方法二：哈希表

​		用 `unordered_map<int, int> hashMap; ` 记录每个数字及其上次出现的位置`<cards[i], index>`，当前数字如果出现过，计算当前位置和上次出现位置的差，并更新结果。

**时间复杂度：$$O(N)$$**

**空间复杂度：$$O(N)$$**

C++版代码：

```c++
class Solution {
public:
    int minimumCardPickup(vector<int>& cards) {
        unordered_map<int, int> hashMap; // <cards[i], index>
        int n = cards.size();
        int res = INT_MAX;
        
        for (int i = 0; i < n; i++) {
            if (hashMap.count(cards[i])) {
                res = min(res, i - hashMap[cards[i]] + 1);
            }
            hashMap[cards[i]] = i;
        }
        if (res == INT_MAX) res = -1;
        return res;
    }
}; // 2022.5.2
```

#### [2261. 含最多 K 个可整除元素的子数组](https://leetcode.cn/problems/k-divisible-elements-subarrays/)（周赛复盘的时候发现挺简单的）

难度中等

给你一个整数数组 `nums` 和两个整数 `k` 和 `p` ，找出并返回满足要求的不同的子数组数，要求子数组中最多 `k` 个可被 `p` 整除的元素。

如果满足下述条件之一，则认为数组 `nums1` 和 `nums2` 是 **不同** 数组：

- 两数组长度 **不同** ，或者
- 存在 **至少** 一个下标 `i` 满足 `nums1[i] != nums2[i]` 。

**子数组** 定义为：数组中的连续元素组成的一个 **非空** 序列。

 

**示例 1：**

```
输入：nums = [2,3,3,2,2], k = 2, p = 2
输出：11
解释：
位于下标 0、3 和 4 的元素都可以被 p = 2 整除。
共计 11 个不同子数组都满足最多含 k = 2 个可以被 2 整除的元素：
[2]、[2,3]、[2,3,3]、[2,3,3,2]、[3]、[3,3]、[3,3,2]、[3,3,2,2]、[3,2]、[3,2,2] 和 [2,2] 。
注意，尽管子数组 [2] 和 [3] 在 nums 中出现不止一次，但统计时只计数一次。
子数组 [2,3,3,2,2] 不满足条件，因为其中有 3 个元素可以被 2 整除。
```

**示例 2：**

```
输入：nums = [1,2,3,4], k = 4, p = 1
输出：10
解释：
nums 中的所有元素都可以被 p = 1 整除。
此外，nums 中的每个子数组都满足最多 4 个元素可以被 1 整除。
因为所有子数组互不相同，因此满足所有限制条件的子数组总数为 10 。
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i], p <= 200`
- `1 <= k <= nums.length`

思路：

​		统计数组的所有字数组中有多少满足条件的【不同的子数组数，要求子数组中最多 k 个可被 p 整除的元素】 ，因为要去重所以可以采用C++ 自带的去重的数据结构，比如：

- map, set[这两个特点是底层是红黑树有序的，存储的**数据类型可以自定义**，就是空间时间复杂度比较高]

- unordered_map, unordered_set[这两个特点是底层实现是哈希表无序存储查询插入时间空间复杂度比较低（相比于上面两个来说），但是缺点就是**数据类型只能是基本的类型**比如 int ,char float.string 等等]

为了减小本题的时间空间复杂度决定采用无序容器 unordered_map 进行去重处理。
具体实现步骤：

1. 定义无序容器用于去重 unordered_map<string, int> result;；

2. 定义两个中间变量，计算出现整除的次数和转化为 字符串tmp；
3. 将符合条件的字符串插入到map容器中自动去重；
4. 返回 容器大小 result.size()

方法一：【暴力 + set 去重】

C++版本代码：

```c++
class Solution {
public:
    int countDistinct(vector<int>& nums, int k, int p) {
        int n = nums.size();
        set<vector<int>> hashSet;
        for (int i = 0; i < n; i++) {
            int cnt = 0;
            for (int j = i; j < n; j++) {
                if (nums[j] % p == 0) cnt++;
                if (cnt > k) break;
                vector<int> tmp(nums.begin() + i, nums.begin() + j + 1);
                hashSet.insert(tmp);
            }
        }
        return (int)hashSet.size();
    }
}; // 2022.5.9
```

python版代码 tuple 去重：

```python
class Solution:
    def countDistinct(self, nums: List[int], k: int, p: int) -> int:
        s, n = set(), len(nums)
        for i in range(n):
            cnt = 0
            for j in range(i, n):
                if nums[j] % p == 0:
                    cnt += 1
                    if cnt > k:
                        break
                s.add(tuple(nums[i: j + 1]))
        return len(s)
    # 2022.5.9
```

方法二：【滑动窗口 + set 去重】

C++版本代码：

```c++
class Solution {
public:
    int countDistinct(vector<int>& nums, int k, int p) {
        int cnt = 0;
        int left = 0;
        int n = nums.size();
        set<vector<int>> hashSet;
        for (int i = 0; i < n; i++) {
            if (nums[i] % p != 0) {
                for (int j = left; j <= i; j++) {
                    vector<int> tmp(nums.begin() + j, nums.begin() + i + 1);
                    hashSet.insert(tmp);
                }
            } else {
                cnt++;
                while (cnt > k and left <= i) {
                    cnt -= (nums[left] % p) == 0;
                    left++; 
                }
                for (int j = left; j <= i; j++) {
                    vector<int> tmp(nums.begin() + j, nums.begin() + i + 1);
                    hashSet.insert(tmp);
                }
            }
        }
        int res = (int)hashSet.size();
        return res;
    }
}; // 2022.5.9
```



#### [2262. 字符串的总引力](https://leetcode.cn/problems/total-appeal-of-a-string/)(好难，思路太巧妙了)

字符串的 **引力** 定义为：字符串中 **不同** 字符的数量。

- 例如，`"abbca"` 的引力为 `3` ，因为其中有 `3` 个不同字符 `'a'`、`'b'` 和 `'c'` 。

给你一个字符串 `s` ，返回 **其所有子字符串的总引力** **。**

**子字符串** 定义为：字符串中的一个连续字符序列。

 

**示例 1：**

```
输入：s = "abbca"
输出：28
解释："abbca" 的子字符串有：
- 长度为 1 的子字符串："a"、"b"、"b"、"c"、"a" 的引力分别为 1、1、1、1、1，总和为 5 。
- 长度为 2 的子字符串："ab"、"bb"、"bc"、"ca" 的引力分别为 2、1、2、2 ，总和为 7 。
- 长度为 3 的子字符串："abb"、"bbc"、"bca" 的引力分别为 2、2、3 ，总和为 7 。
- 长度为 4 的子字符串："abbc"、"bbca" 的引力分别为 3、3 ，总和为 6 。
- 长度为 5 的子字符串："abbca" 的引力为 3 ，总和为 3 。
引力总和为 5 + 7 + 7 + 6 + 3 = 28 。
```

**示例 2：**

```
输入：s = "code"
输出：20
解释："code" 的子字符串有：
- 长度为 1 的子字符串："c"、"o"、"d"、"e" 的引力分别为 1、1、1、1 ，总和为 4 。
- 长度为 2 的子字符串："co"、"od"、"de" 的引力分别为 2、2、2 ，总和为 6 。
- 长度为 3 的子字符串："cod"、"ode" 的引力分别为 3、3 ，总和为 6 。
- 长度为 4 的子字符串："code" 的引力为 4 ，总和为 4 。
引力总和为 4 + 6 + 6 + 4 = 20 。
```

 

**提示：**

- `1 <= s.length <= 105`
- `s` 由小写英文字母组成

方法：【DP】

提示 1-1
将所有子串按照其末尾字符的下标分组。

提示 1-2
考虑两组相邻的子串：以 s[i - 1] 结尾的子串、以 s[i] 结尾的子串。

提示 1-3
**以 s[i] 结尾的子串，可以看成是以 s[i - 1] 结尾的子串，在末尾添加上 s[i] 组成。**

**上面这一串提示是思考子串统计类问题的通用技巧之一。**

提示 2-1
从左往右遍历 s，考虑将 s[i] 添加到以 s[i - 1] 结尾的子串的末尾。添加后，这些子串的引力值会增加多少？

提示 2-2
分类讨论：

1. 如果 s[i] 之前没有遇到过，那么这些子串的引力值都会增加 1，这些子串的引力值之和会增加 i，再加上 1，即为 s[i] 单独组成的子串的引力值；

2. 如果 s[i] 之前遇到过，设其上次出现的下标为 j，

- 那么向子串 $$s[0..i-1],\ s[1..i-1],\ s[2..i-1],\cdots,s[j..i-1]$$ 的末尾添加 s[i] 后，这些子串的引力值是不会变化的，因为 s[i] 已经在 s[j] 处出现过了；
- 而子串 $$s[j+1..i-1],\ s[j+2..i-1],\cdots,s[i-1..i-1]$$ 由于不包含字符 s[i]，这些子串的引力值都会增加 1，因此有 $$i - j- 1$$ 个子串的引力值会增加 1，这些子串的引力值之和会增加 $$i-j-1$$，再加上 1，即 s[i] 单独组成的子串的引力值。

提示 2-3
模拟上述过程，遍历 s 的过程中用一个变量 $$\textit{sumG}$$ 维护以 s[i] 结尾的子串的引力值之和，同时用一个数组 $$\textit{last}$$ 记录每个字符上次出现的下标。

累加遍历中的 $$\textit{sumG}$$ 即为答案。（提示 1-1）

复杂度分析
时间复杂度：$$O(n)$$，其中 n 为 s 的长度。
空间复杂度：$$O(|\Sigma|)$$，其中 $$|\Sigma|$$ 为字符集合的大小，本题中字符均为小写字母，所以 $$|\Sigma|=26$$。
相似题目

[828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)

C++版代码：

```c++
class Solution {
public:
    long long appealSum(string &s) {
        long ans = 0L;
        vector<int> last(26, -1);
        for (int i = 0, sum_g = 0; i < s.length(); ++i) {
            char c = s[i] - 'a';
            sum_g += i - last[c];
            ans += sum_g;
            last[c] = i;
        }
        return ans;
    }
}; // 2022.5.12
```



## 第 77 场双周赛-2022.4.30

#### [2255. 统计是给定字符串前缀的字符串数目](https://leetcode.cn/problems/count-prefixes-of-a-given-string/)（SE)

给你一个字符串数组 `words` 和一个字符串 `s` ，其中 `words[i]` 和 `s` 只包含 **小写英文字母** 。

请你返回 `words` 中是字符串 `s` **前缀** 的 **字符串数目** 。

一个字符串的 **前缀** 是出现在字符串开头的子字符串。**子字符串** 是一个字符串中的连续一段字符序列。

 

**示例 1：**

```
输入：words = ["a","b","c","ab","bc","abc"], s = "abc"
输出：3
解释：
words 中是 s = "abc" 前缀的字符串为：
"a" ，"ab" 和 "abc" 。
所以 words 中是字符串 s 前缀的字符串数目为 3 。
```

**示例 2：**

```
输入：words = ["a","a"], s = "aa"
输出：2
解释：
两个字符串都是 s 的前缀。
注意，相同的字符串可能在 words 中出现多次，它们应该被计数多次。
```

 

**提示：**

- `1 <= words.length <= 1000`
- `1 <= words[i].length, s.length <= 10`
- `words[i]` 和 `s` **只** 包含小写英文字母。

C++版代码：（自己的代码）

```c++
class Solution {
public:
    int countPrefixes(vector<string>& words, string s) {
        unordered_map<string, int> hashMap;
        for (auto word : words) {
            hashMap[word]++;
        }
        int res = 0;
        for (int i = 0; i < s.size(); i++) {
            string str = s.substr(0, i + 1);
            if (hashMap.count(str)) res += hashMap[str];
        }
        return res;
    }
}; // 2022.4.30
```

C++版代码：（别人的代码）

```c++
class Solution {
public:
    int countPrefixes(vector<string>& words, string s) {
        int ans = 0;
        for(auto a : words){
            if(s.substr(0, a.size()) == a) ans++;
        }
        return ans;
    }
}; // 2022.5.2
```

#### [2256. 最小平均差](https://leetcode.cn/problems/minimum-average-difference/)(SE)

给你一个下标从 **0** 开始长度为 `n` 的整数数组 `nums` 。

下标 `i` 处的 **平均差** 指的是 `nums` 中 **前** `i + 1` 个元素平均值和 **后** `n - i - 1` 个元素平均值的 **绝对差** 。两个平均值都需要 **向下取整** 到最近的整数。

请你返回产生 **最小平均差** 的下标。如果有多个下标最小平均差相等，请你返回 **最小** 的一个下标。

**注意：**

- 两个数的 **绝对差** 是两者差的绝对值。
-  `n` 个元素的平均值是 `n` 个元素之 **和** 除以（整数除法） `n` 。
- `0` 个元素的平均值视为 `0` 。

 

**示例 1：**

```
输入：nums = [2,5,3,9,5,3]
输出：3
解释：
- 下标 0 处的平均差为：|2 / 1 - (5 + 3 + 9 + 5 + 3) / 5| = |2 / 1 - 25 / 5| = |2 - 5| = 3 。
- 下标 1 处的平均差为：|(2 + 5) / 2 - (3 + 9 + 5 + 3) / 4| = |7 / 2 - 20 / 4| = |3 - 5| = 2 。
- 下标 2 处的平均差为：|(2 + 5 + 3) / 3 - (9 + 5 + 3) / 3| = |10 / 3 - 17 / 3| = |3 - 5| = 2 。
- 下标 3 处的平均差为：|(2 + 5 + 3 + 9) / 4 - (5 + 3) / 2| = |19 / 4 - 8 / 2| = |4 - 4| = 0 。 
- 下标 4 处的平均差为：|(2 + 5 + 3 + 9 + 5) / 5 - 3 / 1| = |24 / 5 - 3 / 1| = |4 - 3| = 1 。
- 下标 5 处的平均差为：|(2 + 5 + 3 + 9 + 5 + 3) / 6 - 0| = |27 / 6 - 0| = |4 - 0| = 4 。
下标 3 处的平均差为最小平均差，所以返回 3 。
```

**示例 2：**

```
输入：nums = [0]
输出：0
解释：
唯一的下标是 0 ，所以我们返回 0 。
下标 0 处的平均差为：|0 / 1 - 0| = |0 - 0| = 0 。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `0 <= nums[i] <= 105`

C++版代码：（自己的代码）

思路：

​		前缀和数组，然后一遍遍历

```c++
class Solution {
public:
    int minimumAverageDifference(vector<int>& nums) {
        int n = nums.size();
        vector<long long> prefix(n + 1, 0);
        for (int i = 1; i <= n; i++) {
            prefix[i] = prefix[i - 1] + nums[i - 1];
        }

        int res = 0;
        int minGap = INT_MAX;
        for (int i = 0; i < n ; i++) {
            int left = prefix[i + 1] / (i + 1);
            int right = 0;
            if (i != n - 1) {
                right = (prefix[n] - prefix[i + 1]) / (n - i - 1);
            }
            int tmp = abs(left - right);
            if (tmp < minGap) {
                res = i;
                minGap = tmp;
            }
        }
        return res;
    }
}; // 2022.4.30
```

#### [2257. 统计网格图中没有被保卫的格子数](https://leetcode.cn/problems/count-unguarded-cells-in-the-grid/)（SE）

给你两个整数 `m` 和 `n` 表示一个下标从 **0** 开始的 `m x n` 网格图。同时给你两个二维整数数组 `guards` 和 `walls` ，其中 `guards[i] = [rowi, coli]` 且 `walls[j] = [rowj, colj]` ，分别表示第 `i` 个警卫和第 `j` 座墙所在的位置。

一个警卫能看到 4 个坐标轴方向（即东、南、西、北）的 **所有** 格子，除非他们被一座墙或者另外一个警卫 **挡住** 了视线。如果一个格子能被 **至少** 一个警卫看到，那么我们说这个格子被 **保卫** 了。

请你返回空格子中，有多少个格子是 **没被保卫** 的。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/10/example1drawio2.png)

```
输入：m = 4, n = 6, guards = [[0,0],[1,1],[2,3]], walls = [[0,1],[2,2],[1,4]]
输出：7
解释：上图中，被保卫和没有被保卫的格子分别用红色和绿色表示。
总共有 7 个没有被保卫的格子，所以我们返回 7 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/10/example2drawio.png)

```
输入：m = 3, n = 3, guards = [[1,1]], walls = [[0,1],[1,0],[2,1],[1,2]]
输出：4
解释：上图中，没有被保卫的格子用绿色表示。
总共有 4 个没有被保卫的格子，所以我们返回 4 。
```

 

**提示：**

- `1 <= m, n <= 105`
- `2 <= m * n <= 105`
- `1 <= guards.length, walls.length <= 5 * 104`
- `2 <= guards.length + walls.length <= m * n`
- `guards[i].length == walls[j].length == 2`
- `0 <= rowi, rowj < m`
- `0 <= coli, colj < n`
- `guards` 和 `walls` 中所有位置 **互不相同** 。

C++版代码：（自己的代码）写的好垃圾，看下面的位运算代码

思路：

​		记录所有警卫的位置，然后对上、下、左、右 四个方向遍历，修改空格子的值。最后统计未遍历到的空格子的个数。

```c++
class Solution {
private:
    static constexpr int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<bool>> vis(m, vector<bool>(n, false));
        vector<vector<int>> graph(m, vector<int>(n, 0)); // 1:警卫，-1：墙，0：路
        queue<pair<int, int>> que;
        
        
        for (auto guard : guards) {
            que.emplace(guard[0], guard[1]);
            graph[guard[0]][guard[1]] = 1;
        }
        for (auto wall : walls) {
            graph[wall[0]][wall[1]] = -1;
        }
        
        while (!que.empty()) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            for (int i = 0; i < 4; i++) {
                int xx = x + dirs[i][0];
                int yy = y + dirs[i][1];
                while (xx >= 0 and xx < m and yy >= 0 and yy < n) {
                    if (graph[xx][yy] == -1 or graph[xx][yy] == 1) break;
                    if (!vis[xx][yy] and graph[xx][yy] == 0) {
                        vis[xx][yy] = true;
                    }
                    xx += dirs[i][0]; 
                    yy += dirs[i][1];
                }
                
            }
        }
        int res = 0;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (graph[i][j] == 0 and !vis[i][j]) {
                    res++;
                }
            }
        }
        return res;
    }
}; // 2022.4.30
```

C++版代码：（别人的代码，位运算）**思路真的很巧妙**

```c++
class Solution {
public:
    int countUnguarded(int m, int n, vector<vector<int>>& guards, vector<vector<int>>& walls) {
        vector<vector<int>> grid(m, vector<int>(n, 0));
        for(auto guard : guards) {
            grid[guard[0]][guard[1]] = 15;
        }
        for(auto wall : walls) {
            grid[wall[0]][wall[1]] = 16;
        }

        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                if(grid[i][j] < 16){
                    if(i) grid[i][j] |= grid[i - 1][j] & 1; // 上边有警卫，或者被警卫监视的格子
                    if(j) grid[i][j] |= grid[i][j - 1] & 2; // 左边有警卫，或者被警卫监视的格子
                }
            }
        }

        for(int i = m - 1; ~i; --i) {
            for(int j = n - 1; ~j; --j) {
                if(grid[i][j] < 16){
                    if(i < m - 1) grid[i][j] |= grid[i + 1][j] & 4; // 下边有警卫，或者被警卫监视的格子
                    if(j < n - 1) grid[i][j] |= grid[i][j + 1] & 8; // 右边有警卫，或者被警卫监视的格子
                }
            }
        }
        
        int res = 0;
        for(int i = 0; i < m; ++i) {
            for(int j = 0; j < n; ++j) {
                res += !grid[i][j];
            }
        }
        return res;
    }
}; // 2022.5.2
```

#### [2258. 逃离火灾](https://leetcode.cn/problems/escape-the-spreading-fire/)（不会）

给你一个下标从 **0** 开始大小为 `m x n` 的二维整数数组 `grid` ，它表示一个网格图。每个格子为下面 3 个值之一：

- `0` 表示草地。
- `1` 表示着火的格子。
- `2` 表示一座墙，你跟火都不能通过这个格子。

一开始你在最左上角的格子 `(0, 0)` ，你想要到达最右下角的安全屋格子 `(m - 1, n - 1)` 。每一分钟，你可以移动到 **相邻** 的草地格子。每次你移动 **之后** ，着火的格子会扩散到所有不是墙的 **相邻** 格子。

请你返回你在初始位置可以停留的 **最多** 分钟数，且停留完这段时间后你还能安全到达安全屋。如果无法实现，请你返回 `-1` 。如果不管你在初始位置停留多久，你 **总是** 能到达安全屋，请你返回 `109` 。

注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。

如果两个格子有共同边，那么它们为 **相邻** 格子。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex1new.jpg)

```
输入：grid = [[0,2,0,0,0,0,0],[0,0,0,2,2,1,0],[0,2,0,0,1,2,0],[0,0,2,2,2,0,2],[0,0,0,0,0,0,0]]
输出：3
解释：上图展示了你在初始位置停留 3 分钟后的情形。
你仍然可以安全到达安全屋。
停留超过 3 分钟会让你无法安全到达安全屋。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex2new2.jpg)

```
输入：grid = [[0,0,0,0],[0,1,2,0],[0,2,0,0]]
输出：-1
解释：上图展示了你马上开始朝安全屋移动的情形。
火会蔓延到你可以移动的所有格子，所以无法安全到达安全屋。
所以返回 -1 。
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2022/03/10/ex3new.jpg)

```
输入：grid = [[0,0,0],[2,2,0],[1,2,0]]
输出：1000000000
解释：上图展示了初始网格图。
注意，由于火被墙围了起来，所以无论如何你都能安全到达安全屋。
所以返回 109 。
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `2 <= m, n <= 300`
- `4 <= m * n <= 2 * 104`
- `grid[i][j]` 是 `0` ，`1` 或者 `2` 。
- `grid[0][0] == grid[m - 1][n - 1] == 0`

**方法：** **BFS + 二分查找**

题意：

```c++
	返回你在初始位置可以停留的 最多 分钟数，且停留完这段时间后你还能安全到达安全屋。
    如果无法实现，请你返回 -1 。如果不管你在初始位置停留多久，你 总是 能到达安全屋，请你返回 109 。
	注意，如果你到达安全屋后，火马上到了安全屋，这视为你能够安全到达安全屋。
```

周赛中的思考：

1. 着火的格子会扩散到所有不是墙的 **相邻** 格子，可以想到一定用到 BFS，然后记录每个格子的最早着火时间。
2. 人也可以向相邻的空格子移动（上下左右），同样也是BFS。
3. 记录人移动的路径，将人到达路径的时间与空格子的着火时间进行对比，如果人到达的时候空格子已经着火或者正在着火（安全屋除外）那么该路径中断。
4. 最后加入人在初始位置停留的时间，人到达空格子的时间要加上停留的时间。

卡住的点：

1. **光想着记录人走的所有路径，没法处理路径中断的情况，再加入人在初始位置停留的时间，无法想到处理这两样的情况。**而且停留的时间的范围为`[0, m * n]` 一次一次进行枚举可能超时（此时一点没意识到可以使用二分查找）。
2. 没想到可以每次加入停留时间后都对人进行一次 BFS，在 BFS 中判断路径是否中断。
3. 没想到可以二分查找进行停留时间的枚举

思路：

​		人要能够安全的到达安全屋，说明在到达安全屋的路径上，**人到达该空格子的最早时间早于该空格子的最早着火时间**。如果不存在一条这样的路径，人就不能到达安全屋。并且，到达空格子的最早时间还要**加上人在初始位置停留的时间**。

​		因此，用数组 `fireTime` 记录空格子的最早着火时间，用数组 `arriveTime` 记录人达到空格子的最早到达时间。用二分查找的方法查找人能够在初始位置停留的最长时间。左端值为 0， 右端值为 grid 中格子的数量。

**记录空格子的最早着火时间**

​		从初始的火格子开始，BFS 遍历所有为 0 的格子，并记录每个格子的最早着火时间。火的格子的最早着火时间初始化为0，其他格子初始化为 INT_MAX。

**记录人在初始位置停留 `time` 分钟时间后，空格子的最早到达时间**

​		从初始位置 （0，0）开始，BFS 遍历所有为 0 的格子，并记录每个格子的最早到达时间。人的初始位置的最早到达时间为 `time`，其他格子初始化为 INT_MAX。

​		BFS 遍历的时间，如果最早到达时间大于等于格子的最早着火时间，就不能入队列；如果下一个格子为安全屋时，最早到达时间可以等于格子的最早着火时间。

​		更新最早到达时间的公式为：`arriveTime[nx][ny] = arriveTime[x][y] + 1`

​		最后就是二分查找人在初始位置可以停留的最长时间。

**为啥可以使用二分查找：**

​		如果可以停留 *t 分钟，那么肯定也可以停留少于 t* 分钟；如果不能停留 t 分钟，那么肯定也不能停留超过 t 分钟。

因此可以二分最长停留时间。

**C++版代码：**

```c++
class Solution {
private:
    static constexpr int dirs[4][2] = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};
public:
    int maximumMinutes(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> fireTime(m, vector<int>(n, INT_MAX)); // 保存每个格子着火的最早时间

        queue<pair<int, int>> que;
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == 1) { // 如果初始时为火格子，就入队列
                    que.emplace(i, j);
                    fireTime[i][j] = 0; // 最初就为火格子的着火时间为 0
                }
            }
        }
        // BFS 记录所有可以着火的草地的最早着火时间
        while (!que.empty()) {
            auto [x, y] = que.front();
            que.pop();
            for (auto dir : dirs) {
                int nx = x + dir[0];
                int ny = y + dir[1];
                if (nx < 0 or nx >= m or ny < 0 or ny >= n or grid[nx][ny] == 2) continue; // 边界或墙
                if (grid[nx][ny] == 0 and fireTime[nx][ny] == INT_MAX) { // 如果为草地
                    que.emplace(nx, ny);
                    fireTime[nx][ny] = fireTime[x][y] + 1; // 记录最早着火时间为 
                }
            }
        }
        auto check = [&](int time) {
            // 保存人到达每个草地的最早到达时间，初始化为 INT_MAX
            vector<vector<int>> arriveTime(m, vector<int>(n, INT_MAX));
            queue<pair<int, int>> q;
            q.emplace(0, 0);
            arriveTime[0][0] = time; // 人的初始点的最早到达时间为 time
            if (arriveTime[0][0] >= fireTime[0][0]) return false; // 初始点着火了，直接返回false
            while (!q.empty()) {
                auto [x, y] = q.front();
                q.pop();
                for (auto dir : dirs) {
                    int nx = x + dir[0];
                    int ny = y + dir[1];
                    if (nx < 0 or nx >= m or ny < 0 or ny >= n or grid[nx][ny] == 2) continue;// 边界或墙
                    if (grid[nx][ny] == 0 and arriveTime[nx][ny] == INT_MAX) { // 如果为草地且此前没到达过
                        arriveTime[nx][ny] = arriveTime[x][y] + 1; // 记录最到达火时间
                        // 判断是否在安全屋着火前到达安全屋
                        if (nx == m - 1 and ny == n - 1) return arriveTime[nx][ny] <= fireTime[nx][ny]; 
                        if (arriveTime[nx][ny] < fireTime[nx][ny]) { // 到达时没着火
                            q.emplace(nx, ny);
                        }
                    }
                }
            }
            return false; // 不能到达安全屋
        };
        int left = 0;
        int right = m * n; // grid 中有 m * n 个格子，人最多走 m * n 分钟的时间
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (check(mid)) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        int res = left; // 到达初始位置的时间，如果为 0 的话 说明不能在初始位置停留
        if (left == m * n) res = 1e9; // 不管停留多久都能到达安全屋
        else res = res - 1;
        return res;
    }
}; // 2022.5.2
```



## 第290场周赛-2022.4.24

### 6041. 多个数组求交集

[6041. 多个数组求交集](https://leetcode-cn.com/contest/weekly-contest-290/problems/intersection-of-multiple-arrays/)

给你一个二维整数数组 `nums` ，其中 `nums[i]` 是由 **不同** 正整数组成的一个非空数组，按 **升序排列** 返回一个数组，数组中的每个元素在 `nums` **所有数组** 中都出现过。

 

**示例 1：**

```
输入：nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]]
输出：[3,4]
解释：
nums[0] = [3,1,2,4,5]，nums[1] = [1,2,3,4]，nums[2] = [3,4,5,6]，在 nums 中每个数组中都出现的数字是 3 和 4 ，所以返回 [3,4] 。
```

**示例 2：**

```
输入：nums = [[1,2,3],[4,5,6]]
输出：[]
解释：
不存在同时出现在 nums[0] 和 nums[1] 的整数，所以返回一个空列表 [] 。
```

 

**提示：**

- `1 <= nums.length <= 1000`
- `1 <= sum(nums[i].length) <= 1000`
- `1 <= nums[i][j] <= 1000`
- `nums[i]` 中的所有值 **互不相同**

C++版代码：

```c++
class Solution {
public:
    vector<int> intersection(vector<vector<int>>& nums) {
        unordered_map<int, int> hashMap;
        for (int i = 0; i < nums.size(); i++) {
            for (auto num : nums[i]) {
                hashMap[num]++;
            }
        }
        vector<int> res;
        for (auto it = hashMap.begin(); it != hashMap.end(); it++) {
            if (it->second == nums.size()) {
                res.push_back(it->first);
            }
        }
        sort(res.begin(), res.end());
        return res;
    }
};
```

### 6042. 统计圆内格点数目

[6042. 统计圆内格点数目](https://leetcode-cn.com/contest/weekly-contest-290/problems/count-lattice-points-inside-a-circle/)

给你一个二维整数数组 `circles` ，其中 `circles[i] = [xi, yi, ri]` 表示网格上圆心为 `(xi, yi)` 且半径为 `ri` 的第 `i` 个圆，返回出现在 **至少一个** 圆内的 **格点数目** 。

**注意：**

- **格点** 是指整数坐标对应的点。
- **圆周上的点** 也被视为出现在圆内的点。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/02/exa-11.png)

```
输入：circles = [[2,2,1]]
输出：5
解释：
给定的圆如上图所示。
出现在圆内的格点为 (1, 2)、(2, 1)、(2, 2)、(2, 3) 和 (3, 2)，在图中用绿色标识。
像 (1, 1) 和 (1, 3) 这样用红色标识的点，并未出现在圆内。
因此，出现在至少一个圆内的格点数目是 5 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/02/exa-22.png)

```
输入：circles = [[2,2,2],[3,4,1]]
输出：16
解释：
给定的圆如上图所示。
共有 16 个格点出现在至少一个圆内。
其中部分点的坐标是 (0, 2)、(2, 0)、(2, 4)、(3, 2) 和 (4, 4) 。
```

 

**提示：**

- `1 <= circles.length <= 200`
- `circles[i].length == 3`
- `1 <= xi, yi <= 100`
- `1 <= ri <= min(xi, yi)`

思路：

去重：不能用set去重，会超时

C++版代码：

```c++
class Solution {
private:
    bool isValid(int x1, int y1, int x2, int y2, int r) {
        if (pow(x1 - x2, 2) + pow (y1 - y2, 2) <= r * r) {
            return true;
        }
        return false;
    }
public:
    int countLatticePoints(vector<vector<int>>& circles) {
        set<vector<int>> hashSet;
        vector<vector<bool>> hashVec(201, vector<bool>(201, false));
        int res = 0;
        for (int i = 0; i < circles.size(); i++) {
            int x = circles[i][0];
            int y = circles[i][1];
            int r = circles[i][2];
            for (int x1 = x - r; x1 <= x; x1++) {
                for (int y1 = y - r; y1 <= y; y1++) {
                    if (isValid(x, y, x1, y1, r)) {
                        if (!hashVec[x1][y1]) {
                            res++;
                            hashVec[x1][y1] = true;
                        }
                        if (!hashVec[abs(x1 - x) + x][y1]) {
                            res++;
                            hashVec[abs(x1 - x) + x][y1] = true;
                        }
                        if (!hashVec[x1][abs(y1 - y) + y]) {
                            res++;
                            hashVec[x1][abs(y1 - y) + y] = true;
                        }
                        if (!hashVec[abs(x1 - x) + x][abs(y1 - y) + y]) {
                            res++;
                            hashVec[abs(x1 - x) + x][abs(y1 - y) + y] = true;
                        }
                    }
                }
            }
        }
        return res;
    }
};
```

C++代码二（速度比代码一慢了十倍）：

```c++
class Solution {
private:
    bool isValid(int x1, int y1, int x2, int y2, int r) {
        if (pow(x1 - x2, 2) + pow (y1 - y2, 2) <= r * r) {
            return true;
        }
        return false;
    }
public:
    int countLatticePoints(vector<vector<int>>& circles) {
        set<int> hashSet;
        int res = 0;
        for (int i = 0; i < circles.size(); i++) {
            int x = circles[i][0];
            int y = circles[i][1];
            int r = circles[i][2];
            for (int x1 = x - r; x1 <= x + r; x1++) {
                for (int y1 = y - r; y1 <= y + r; y1++) {
                    if (isValid(x, y, x1, y1, r)) {
                        hashSet.insert(x1 * 1000 + y1);
                    }
                }
            }
        }
        res = hashSet.size();
        return res;
    }
};
```

### 6043. 统计包含每个点的矩形数目

[统计包含每个点的矩形数目](https://leetcode-cn.com/contest/weekly-contest-290/problems/count-number-of-rectangles-containing-each-point/)

给你一个二维整数数组 `rectangles` ，其中 `rectangles[i] = [li, hi]` 表示第 `i` 个矩形长为 `li` 高为 `hi` 。给你一个二维整数数组 `points` ，其中 `points[j] = [xj, yj]` 是坐标为 `(xj, yj)` 的一个点。

第 `i` 个矩形的 **左下角** 在 `(0, 0)` 处，**右上角** 在 `(li, hi)` 。

请你返回一个整数数组 `count` ，长度为 `points.length`，其中 `count[j]`是 **包含** 第 `j` 个点的矩形数目。

如果 `0 <= xj <= li` 且 `0 <= yj <= hi` ，那么我们说第 `i` 个矩形包含第 `j` 个点。如果一个点刚好在矩形的 **边上** ，这个点也被视为被矩形包含。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/02/example1.png)

```
输入：rectangles = [[1,2],[2,3],[2,5]], points = [[2,1],[1,4]]
输出：[2,1]
解释：
第一个矩形不包含任何点。
第二个矩形只包含一个点 (2, 1) 。
第三个矩形包含点 (2, 1) 和 (1, 4) 。
包含点 (2, 1) 的矩形数目为 2 。
包含点 (1, 4) 的矩形数目为 1 。
所以，我们返回 [2, 1] 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/02/example2.png)

```
输入：rectangles = [[1,1],[2,2],[3,3]], points = [[1,3],[1,1]]
输出：[1,3]
解释：
第一个矩形只包含点 (1, 1) 。
第二个矩形只包含点 (1, 1) 。
第三个矩形包含点 (1, 3) 和 (1, 1) 。
包含点 (1, 3) 的矩形数目为 1 。
包含点 (1, 1) 的矩形数目为 3 。
所以，我们返回 [1, 3] 。
```

 

**提示：**

- `1 <= rectangles.length, points.length <= 5 * 104`
- `rectangles[i].length == points[j].length == 2`
- `1 <= li, xj <= 109`
- `1 <= hi, yj <= 100`
- 所有 `rectangles` **互不相同** 。
- 所有 `points` **互不相同** 。

**方法一：按纵坐标排序**
基本思路就是对每个点 (x_i,y_i)，统计横坐标不小于 x_i 且纵坐标不小于 y_i 的矩形个数。

为了加快统计速度，我们可以将 `rectangles` 和 `points` 都按照纵坐标从大到小排序。

然后遍历每个点 (x_i,y_i)，将所有纵坐标不小于 y_i 的矩形的横坐标加入一个有序列表 xs。

由于纵坐标的范围只有 `[1,100]`我们可以暴力地在每次插入完横坐标后对 xs 排序，排序的次数不会超过 100次。

然后在 xs 中二分即可算出横坐标不小于 x_i 的矩形个数，由于我们是按纵坐标从大到小遍历的，因此这些矩形的纵坐标均不小于 y_i，因此这些矩形均包含点 (x_i,y_i)。

C++代码：

```c++
class Solution {
private:
    static bool cmp(const vector<int> a, const vector<int> b) {
        return a[1] > b[1]; 
    }
public:
    vector<int> countRectangles(vector<vector<int>>& rectangles, vector<vector<int>>& points) {
        sort(rectangles.begin(), rectangles.end(), cmp);  // 对 rectangles 按纵坐标从大到小排序
        
        vector<int> index(points.size());
        iota(index.begin(), index.end(), 0);
        // 对 points 按纵坐标从大到小排序
        sort(index.begin(), index.end(), [&] (int i, int j) { return points[i][1] > points[j][1]; });
        
        vector<int> xValVec;
        int i = 0;
        vector<int> ans(points.size(), 0);
        for (auto idx : index) {
            int start = i;
            while (i < rectangles.size() and rectangles[i][1] >= points[idx][1]) {
                xValVec.push_back(rectangles[i++][0]);
            }
            if (start < i) { // 说明有新的矩形 x 值插入 xValVec 中， 只有在 xValVec 插入了新元素时才排序
                sort(xValVec.begin(), xValVec.end(), [&] (int i, int j) { return i < j; });
            }
            ans[idx] = i - (lower_bound(xValVec.begin(), xValVec.end(), points[idx][0]) - xValVec.begin());
        }
        return ans;
    }
};
```

注：如果这题纵坐标的范围也是 10^9，我们还可以用名次树来做出此题（如 Python 的 SortedList）。

这种做法就与值域无关了，时间复杂度为 
$$
O(n\log n + m\log m+m\log n)O(nlogn+mlogm+mlogn)
$$
，其中 n 是 rectangles 的长度，m 是 points 的长度。

python版代码：

```python
from sortedcontainers import SortedList

class Solution:
    def countRectangles(self, rectangles: List[List[int]], points: List[List[int]]) -> List[int]:
        rectangles.sort(key=lambda r: -r[1])
        n = len(points)
        ans = [0] * n
        i, xs = 0, SortedList()
        for (x, y), id in sorted(zip(points, range(n)), key=lambda x: -x[0][1]):
            while i < len(rectangles) and rectangles[i][1] >= y:
                xs.add(rectangles[i][0])
                i += 1
            ans[id] = i - xs.bisect_left(x)
        return ans
```



### 6044. 花期内花的数目

[ 题6044. 花期内花的数目](https://leetcode-cn.com/contest/weekly-contest-290/problems/number-of-flowers-in-full-bloom/)

给你一个下标从 **0** 开始的二维整数数组 `flowers` ，其中 `flowers[i] = [starti, endi]` 表示第 `i` 朵花的 **花期** 从 `starti` 到 `endi` （都 **包含**）。同时给你一个下标从 **0** 开始大小为 `n` 的整数数组 `persons` ，`persons[i]` 是第 `i` 个人来看花的时间。

请你返回一个大小为 `n` 的整数数组 `answer` ，其中 `answer[i]`是第 `i` 个人到达时在花期内花的 **数目** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/02/ex1new.jpg)

```
输入：flowers = [[1,6],[3,7],[9,12],[4,13]], persons = [2,3,7,11]
输出：[1,2,2,2]
解释：上图展示了每朵花的花期时间，和每个人的到达时间。
对每个人，我们返回他们到达时在花期内花的数目。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/02/ex2new.jpg)

```
输入：flowers = [[1,10],[3,3]], persons = [3,3,2]
输出：[2,2,1]
解释：上图展示了每朵花的花期时间，和每个人的到达时间。
对每个人，我们返回他们到达时在花期内花的数目。
```

 

**提示：**

- `1 <= flowers.length <= 5 * 104`
- `flowers[i].length == 2`
- `1 <= starti <= endi <= 109`
- `1 <= persons.length <= 5 * 104`
- `1 <= persons[i] <= 109`

## 力扣杯22 组队赛-2022.4.23

### 1. 采集果实（SE)

https://leetcode-cn.com/contest/season/2022-spring/problems/PTXy4P/

欢迎各位勇者来到力扣新手村，本次训练内容为「采集果实」。

在新手村中，各位勇者需要采集一些果实来制作药剂。`time[i]` 表示勇者每次采集 `1～limit` 颗第 `i` 种类型的果实需要的时间（即每次最多可以采集 `limit` 颗果实）。

当前勇者需要完成「采集若干批果实」的任务， `fruits[j] = [type, num]` 表示第 `j` 批需要采集 `num` 颗 `type` 类型的果实。采集规则如下：

- 按 `fruits` 给定的顺序**依次**采集每一批次
- 采集完当前批次的果实才能开始采集下一批次
- 勇者完成当前批次的采集后将**清空背包**

请计算并返回勇者完成采集任务最少需要的时间。

**示例 1：**

> 输入：`time = [2,3,2], fruits = [[0,2],[1,4],[2,1]], limit = 3`
>
> 输出：`10`
>
> 解释：
> 由于单次最多采集 3 颗
> 第 0 批需要采集 2 颗第 0 类型果实，需要采集 1 次，耗时为 2*1=2
> 第 1 批需要采集 4 颗第 1 类型果实，需要采集 2 次，耗时为 3*2=6
> 第 2 批需要采集 1 颗第 2 类型果实，需要采集 1 次，耗时为 2*1=2
> 返回总耗时 2+6+2=10

**示例 2：**

> 输入：`time = [1], fruits = [[0,3],[0,5]], limit = 2`
>
> 输出：`5`
>
> 解释：
> 由于单次最多采集 2 颗
> 第 0 批需要采集 3 颗第 0 类型果实，需要采集 2 次，耗时为 1*2=2
> 第 1 批需要采集 5 颗第 0 类型果实，需要采集 3 次，耗时为 1*3=3
> 需按照顺序依次采集，返回 2+3=5

**提示：**

- `1 <= time.length <= 100`
- `1 <= time[i] <= 100`
- `1 <= fruits.length <= 10^3`
- `0 <= fruits[i][0] < time.length`
- `1 <= fruits[i][1] < 10^3`
- `1 <= limit <= 100`

C++代码：

```c++
class Solution {
public:
    int getMinimumTime(vector<int>& time, vector<vector<int>>& fruits, int limit) {
        int res = 0;
        for (auto fruit : fruits) {
            res += ((fruit[1] - 1) / limit + 1) * time[fruit[0]];
        }
        return res;
    }
};
```

### 2. 信物传送(有点难)

https://leetcode-cn.com/contest/season/2022-spring/problems/6UEx57/

欢迎各位勇者来到力扣城，本次试炼主题为「信物传送」。

本次试炼场地设有若干传送带，`matrix[i][j]` 表示第 `i` 行 `j` 列的传送带运作方向，`"^","v","<",">"` 这四种符号分别表示 **上、下、左、右** 四个方向。信物会随传送带的方向移动。勇者**每一次**施法操作，可**临时**变更一处传送带的方向，在物品经过后传送带恢复原方向。
![lcp (2).gif](https://pic.leetcode-cn.com/1649835246-vfupSL-lcp%20(2).gif)

通关信物初始位于坐标 `start`处，勇者需要将其移动到坐标 `end` 处，请返回勇者施法操作的最少次数。

**注意：**

- `start` 和 `end` 的格式均为 `[i,j]`

**示例 1:**

> 输入：`matrix = [">>v","v^<","<><"], start = [0,1], end = [2,0]`
>
> 输出：`1`
>
> 解释：
> 如上图所示
> 当信物移动到 `[1,1]` 时，勇者施法一次将 `[1,1]` 的传送方向 `^` 从变更为 `<`
> 从而信物移动到 `[1,0]`，后续到达 `end` 位置
> 因此勇者最少需要施法操作 1 次

**示例 2:**

> 输入：`matrix = [">>v",">>v","^<<"], start = [0,0], end = [1,1]`
>
> 输出：`0`
>
> 解释：勇者无需施法，信物将自动传送至 `end` 位置

**示例 3:**

> 输入：`matrix = [">^^>","<^v>","^v^<"], start = [0,0], end = [1,3]`
>
> 输出：`3`

**提示：**

- `matrix` 中仅包含 `'^'、'v'、'<'、'>'`
- `0 < matrix.length <= 100`
- `0 < matrix[i].length <= 100`
- `0 <= start[0],end[0] < matrix.length`
- `0 <= start[1],end[1] < matrix[i].length`

C++版代码：

```c++
class Solution {
private:
    static constexpr int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 和 mapping 对应
    vector<char> mapping = {'^', 'v', '<', '>'};
    vector<int> findDir(char str) {
        for (int i = 0; i < mapping.size(); i++) {
            if (mapping[i] == str) {
                return {dirs[i][0], dirs[i][1]};
            }
        }
        return {0, 0};
    }
public:
    int conveyorBelt(vector<string>& matrix, vector<int>& start, vector<int>& end) {
        int m = matrix.size();
        vector<vector<int>> res(m);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < matrix[i].size(); j++) {
                res[i].push_back(INT_MAX);
            }
        }
        res[end[0]][end[1]] = 0;
        queue<pair<int, int>> que;
        que.emplace(end[0], end[1]);
        while (!que.empty()) {
            int x = que.front().first;
            int y = que.front().second;
            que.pop();
            //cout << "(" << x << ", " << y << ")" << endl;
            for (int i = 0; i < 4; i++) {
                int xx = x + dirs[i][0];
                int yy = y + dirs[i][1];
                if (xx < 0 or xx >= m or yy < 0 or yy >= matrix[x].size()) continue; // 越界
                if (res[xx][yy] <= res[x][y]) continue;
                vector<int> dir = findDir(matrix[xx][yy]);
                if (xx + dir[0] == x and yy + dir[1] == y) {
                    res[xx][yy] = res[x][y];
                } else {
                    res[xx][yy] = min(res[xx][yy], res[x][y] + 1);
                }
                que.emplace(xx, yy);
                //cout << "(" << xx << ", " << yy << ")" << endl;
            }
        }
        return res[start[0]][start[1]];
    }
};
/*
[">>v","v^<","<><"]
[0,1]
[2,0]
[">>v",">>v","^<<"]
[0,0]
[1,1]
[">^^>","<^v>","^v^<"]
[0,0]
[1,3]
*/ // 2022.4.23
```

### 3. 打地鼠

[3. 打地鼠](https://leetcode-cn.com/contest/season/2022-spring/problems/ZbAuEH/)

欢迎各位勇者来到力扣城，本次试炼主题为「打地鼠」。
![middle_img_v2_d5d09656-0616-4a80-845e-ece461c5ba9g.png](https://pic.leetcode-cn.com/1650273183-nZIijm-middle_img_v2_d5d09656-0616-4a80-845e-ece461c5ba9g.png)
勇者面前有一个大小为 `3*3` 的打地鼠游戏机，地鼠将随机出现在各个位置，`moles[i] = [t,x,y]` 表示在第 `t` 秒会有地鼠出现在 `(x,y)` 位置上，并于第 `t+1` 秒该地鼠消失。

勇者有一把可敲打地鼠的锤子，初始时刻（即第 `0` 秒）锤子位于正中间的格子 `(1,1)`，锤子的使用规则如下：

- 锤子每经过 `1` 秒可以往上、下、左、右中的一个方向移动一格，也可以不移动
- 锤子只可敲击所在格子的地鼠，**敲击不耗时**

请返回勇者**最多**能够敲击多少只地鼠。

**注意：**

- 输入用例保证在相同时间相同位置最多仅有一只地鼠

**示例 1：**

> 输入： `moles = [[1,1,0],[2,0,1],[4,2,2]]`
>
> 输出： `2`
>
> 解释：
> 第 0 秒，锤子位于 (1,1)
> 第 1 秒，锤子移动至 (1,0) 并敲击地鼠
> 第 2 秒，锤子移动至 (2,0)
> 第 3 秒，锤子移动至 (2,1)
> 第 4 秒，锤子移动至 (2,2) 并敲击地鼠
> 因此勇者最多可敲击 2 只地鼠

**示例 2：**

> 输入：`moles = [[2,0,2],[5,2,0],[4,1,0],[1,2,1],[3,0,2]]`
>
> 输出：`3`
>
> 解释：
> 第 0 秒，锤子位于 (1,1)
> 第 1 秒，锤子移动至 (2,1) 并敲击地鼠
> 第 2 秒，锤子移动至 (1,1)
> 第 3 秒，锤子移动至 (1,0)
> 第 4 秒，锤子在 (1,0) 不移动并敲击地鼠
> 第 5 秒，锤子移动至 (2,0) 并敲击地鼠
> 因此勇者最多可敲击 3 只地鼠

**示例 3：**

> 输入：`moles = [[0,1,0],[0,0,1]]`
>
> 输出：`0`
>
> 解释：
> 第 0 秒，锤子初始位于 (1,1)，此时并不能敲击 (1,0)、(0,1) 位置处的地鼠

**提示：**

- `1 <= moles.length <= 10^5`
- `moles[i].length == 3`
- `0 <= moles[i][0] <= 10^9`
- `0 <= moles[i][1], moles[i][2] < 3`

### 4. 积木拼接

[4. 积木拼接](https://leetcode-cn.com/contest/season/2022-spring/problems/De4qBB/)

欢迎各位勇者来到力扣城，本次试炼主题为「积木拼接」。
勇者面前有 `6` 片积木（厚度均为 1），每片积木的形状记录于二维字符串数组 `shapes` 中，`shapes[i]` 表示第 `i` 片积木，其中 `1` 表示积木对应位置无空缺，`0` 表示积木对应位置有空缺。
例如 `["010","111","010"]` 对应积木形状为
![image.png](https://pic.leetcode-cn.com/1616125620-nXMCxX-image.png)

拼接积木的规则如下：

- 积木片可以旋转、翻面
- 积木片边缘必须完全吻合才能拼接在一起
- **每片积木片 `shapes[i]` 的中心点在拼接时必须处于正方体对应面的中心点**

例如 `3*3`、`4*4` 的积木片的中心点如图所示（红色点）：
![middle_img_v2_c2d91eb5-9beb-4c06-9726-f7dae149d86g.png](https://pic.leetcode-cn.com/1650509082-wObiEp-middle_img_v2_c2d91eb5-9beb-4c06-9726-f7dae149d86g.png)

请返回这 6 片积木能否拼接成一个**严丝合缝的正方体**且每片积木正好对应正方体的一个面。

**注意：**

- 输入确保每片积木均无空心情况（即输入数据保证对于大小 `N*N` 的 `shapes[i]`，内部的 `(N-2)*(N-2)` 的区域必然均为 1）
- 输入确保每片积木的所有 `1` 位置均连通

**示例 1：**

> 输入：`shapes = [["000","110","000"],["110","011","000"],["110","011","110"],["000","010","111"],["011","111","011"],["011","010","000"]]`
>
> 输出：`true`
>
> 解释：
> ![cube.gif](https://pic.leetcode-cn.com/1616125823-hkXAeN-cube.gif)

**示例 2：**

> 输入：`shapes = [["101","111","000"],["000","010","111"],["010","011","000"],["010","111","010"],["101","111","010"],["000","010","011"]]`
>
> 输出：`false`
>
> 解释：
> 由于每片积木片的中心点在拼接时必须处于正方体对应面的中心点，积木片 `["010","011","000"]` 不能作为 `["100","110","000"]` 使用，因此无法构成正方体

**提示：**

- `shapes.length == 6`
- `shapes[i].length == shapes[j].length`
- `shapes[i].length == shapes[i][j].length`
- `3 <= shapes[i].length <= 10`

### 5. 搭桥过河

[5. 搭桥过河](https://leetcode-cn.com/contest/season/2022-spring/problems/NfY1m5/)

欢迎各位勇者来到力扣城，本次试炼主题为「搭桥过河」。

勇者面前有一段长度为 `num` 的河流，河流可以划分为若干河道。每条河道上恰有一块浮木，`wood[i]` 记录了第 `i` 条河道上的浮木初始的覆盖范围。

- 当且仅当浮木与相邻河道的浮木覆盖范围有重叠时，勇者才可以在两条浮木间移动
- 勇者 **仅能在岸上** 通过花费一点「自然之力」，使任意一条浮木沿着河流移动一个单位距离

请问勇者跨越这条河流，最少需要花费多少「自然之力」。

**示例 1：**

> 输入： `num = 10, wood = [[1,2],[4,7],[8,9]]`
> 输出： `3`
> 解释：如下图所示，
> 将 [1,2] 浮木移动至 [3,4]，花费 2「自然之力」，
> 将 [8,9] 浮木移动至 [7,8]，花费 1「自然之力」，
> 此时勇者可以顺着 [3,4]->[4,7]->[7,8] 跨越河流，
> 因此，勇者最少需要花费 3 点「自然之力」跨越这条河流
> ![wood (2).gif](https://pic.leetcode-cn.com/1648196478-ophADL-wood%20(2).gif)

**示例 2：**

> 输入： `num = 10, wood = [[1,5],[1,1],[10,10],[6,7],[7,8]]`
> 输出： `10`
> 解释：
> 将 [1,5] 浮木移动至 [2,6]，花费 1「自然之力」，
> 将 [1,1] 浮木移动至 [6,6]，花费 5「自然之力」，
> 将 [10,10] 浮木移动至 [6,6]，花费 4「自然之力」，
> 此时勇者可以顺着 [2,6]->[6,6]->[6,6]->[6,7]->[7,8] 跨越河流，
> 因此，勇者最少需要花费 10 点「自然之力」跨越这条河流

**示例 3：**

> 输入： `num = 5, wood = [[1,2],[2,4]]`
> 输出： `0`
> 解释：勇者不需要移动浮木，仍可以跨越这条河流

**提示:**

- `1 <= num <= 10^9`
- `1 <= wood.length <= 10^5`
- `wood[i].length == 2`
- `1 <= wood[i][0] <= wood[i][1] <= num`

### 6. 力扣泡泡龙

[6. 力扣泡泡龙](https://leetcode-cn.com/contest/season/2022-spring/problems/WInSav/)

欢迎各位勇者来到力扣城，本次试炼主题为「力扣泡泡龙」。

游戏初始状态的泡泡形如二叉树 `root`，每个节点值对应了该泡泡的分值。勇者最多可以击破一个节点泡泡，要求满足：

- 被击破的节点泡泡 **至多** 只能有一个子节点泡泡

- 当被击破的节点泡泡有子节点泡泡时，则子节点泡泡将取代被击破泡泡的位置

  > 注：即整棵子树泡泡上移

请问在击破一个节点泡泡操作或无击破操作后，二叉泡泡树的最大「层和」是多少。

**注意：**

- 「层和」为同一高度的所有节点的分值之和

**示例 1：**

> 输入：`root = [6,0,3,null,8]`
>
> 输出：`11`
>
> 解释：勇者的最佳方案如图所示
> ![image.png](https://pic.leetcode-cn.com/1648180809-XSWPLu-image.png)

**示例 2：**

> 输入：`root = [5,6,2,4,null,null,1,3,5]`
>
> 输出：`9`
>
> 解释：勇者击破 6 节点，此时「层和」最大为 3+5+1 = 9
> ![image.png](https://pic.leetcode-cn.com/1648180769-TLpYop-image.png)

**示例 3：**

> 输入：`root = [-5,1,7]`
>
> 输出：`8`
>
> 解释：勇者不击破节点，「层和」最大为 1+7 = 8

**提示**：

- `2 <= 树中节点个数 <= 10^5`
- `-10000 <= 树中节点的值 <= 10000`

## 力扣杯22 个人赛-2022.4.23

https://leetcode.cn/contest/season/2022-spring/ranking/solo/

### 1. 宝石补给

[1. 宝石补给](https://leetcode.cn/contest/season/2022-spring/problems/WHnhjV/)

欢迎各位勇者来到力扣新手村，在开始试炼之前，请各位勇者先进行「宝石补给」。

每位勇者初始都拥有一些能量宝石， `gem[i]` 表示第 `i` 位勇者的宝石数量。现在这些勇者们进行了一系列的赠送，`operations[j] = [x, y]` 表示在第 `j` 次的赠送中 第 `x` 位勇者将自己一半的宝石（需向下取整）赠送给第 `y` 位勇者。

在完成所有的赠送后，请找到拥有**最多**宝石的勇者和拥有**最少**宝石的勇者，并返回他们二者的宝石数量**之差**。

**注意：**

- 赠送将按顺序逐步进行。

**示例 1：**

> 输入：`gem = [3,1,2], operations = [[0,2],[2,1],[2,0]]`
>
> 输出：`2`
>
> 解释：
> 第 1 次操作，勇者 `0` 将一半的宝石赠送给勇者 `2`， `gem = [2,1,3]`
> 第 2 次操作，勇者 `2` 将一半的宝石赠送给勇者 `1`， `gem = [2,2,2]`
> 第 3 次操作，勇者 `2` 将一半的宝石赠送给勇者 `0`， `gem = [3,2,1]`
> 返回 3 - 1 = 2

**示例 2：**

> 输入：`gem = [100,0,50,100], operations = [[0,2],[0,1],[3,0],[3,0]]`
>
> 输出：`75`
>
> 解释：
> 第 1 次操作，勇者 `0` 将一半的宝石赠送给勇者 `2`， `gem = [50,0,100,100]`
> 第 2 次操作，勇者 `0` 将一半的宝石赠送给勇者 `1`， `gem = [25,25,100,100]`
> 第 3 次操作，勇者 `3` 将一半的宝石赠送给勇者 `0`， `gem = [75,25,100,50]`
> 第 4 次操作，勇者 `3` 将一半的宝石赠送给勇者 `0`， `gem = [100,25,100,25]`
> 返回 100 - 25 = 75

**示例 3：**

> 输入：`gem = [0,0,0,0], operations = [[1,2],[3,1],[1,2]]`
>
> 输出：`0`

**提示：**

- `2 <= gem.length <= 10^3`
- `0 <= gem[i] <= 10^3`
- `0 <= operations.length <= 10^4`
- `operations[i].length == 2`
- `0 <= operations[i][0], operations[i][1] < gem.length`

### 2. 烹饪料理

[2. 烹饪料理](https://leetcode.cn/contest/season/2022-spring/problems/UEcfPD/)

欢迎各位勇者来到力扣城，城内设有烹饪锅供勇者制作料理，为自己恢复状态。

勇者背包内共有编号为 `0 ~ 4` 的五种食材，其中 `materials[j]` 表示第 `j` 种食材的数量。通过这些食材可以制作若干料理，`cookbooks[i][j]` 表示制作第 `i` 种料理需要第 `j` 种食材的数量，而 `attribute[i] = [x,y]` 表示第 `i` 道料理的美味度 `x` 和饱腹感 `y`。

在饱腹感不小于 `limit` 的情况下，请返回勇者可获得的最大美味度。如果无法满足饱腹感要求，则返回 `-1`。

**注意：**

- 每种料理只能制作一次。

**示例 1：**

> 输入：`materials = [3,2,4,1,2]`
> `cookbooks = [[1,1,0,1,2],[2,1,4,0,0],[3,2,4,1,0]]`
> `attribute = [[3,2],[2,4],[7,6]]`
> `limit = 5`
>
> 输出：`7`
>
> 解释：
> 食材数量可以满足以下两种方案：
> 方案一：制作料理 0 和料理 1，可获得饱腹感 2+4、美味度 3+2
> 方案二：仅制作料理 2， 可饱腹感为 6、美味度为 7
> 因此在满足饱腹感的要求下，可获得最高美味度 7

**示例 2：**

> 输入：`materials = [10,10,10,10,10]`
> `cookbooks = [[1,1,1,1,1],[3,3,3,3,3],[10,10,10,10,10]]`
> `attribute = [[5,5],[6,6],[10,10]]`
> `limit = 1`
>
> 输出：`11`
>
> 解释：通过制作料理 0 和 1，可满足饱腹感，并获得最高美味度 11

**提示：**

- `materials.length == 5`
- `1 <= cookbooks.length == attribute.length <= 8`
- `cookbooks[i].length == 5`
- `attribute[i].length == 2`
- `0 <= materials[i], cookbooks[i][j], attribute[i][j] <= 20`
- `1 <= limit <= 100`

方法：【回溯】

C++版代码：

```
class Solution {
private:
    int result = 0;
    vector<int> path; // [美味度， 饱腹感]
    bool isCanCook(vector<int>& materials, vector<vector<int>>& cookbooks, int index) {
        for (int i = 0; i < materials.size(); i++) {
            if (materials[i] < cookbooks[index][i]) {
                return false;
            }
        }
        return true;
    }
    void backTracking(vector<int>& materials, vector<vector<int>>& cookbooks, vector<vector<int>>& attribute, int limit, int startIndex) {
        if (path[1] >= limit) {
            result = max(result, path[0]);
        }
        if (startIndex >= attribute.size()) {
            return;
        }

        for (int i = startIndex; i < attribute.size(); i++) {
            if (isCanCook(materials, cookbooks, i)) {
                for (int j = 0; j < materials.size(); j++) {
                    materials[j] -= cookbooks[i][j];
                }
                path[0] += attribute[i][0]; // attribute[i] = [x,y] x : 美味度   y : 饱腹度
                path[1] += attribute[i][1];
                cout << "做第 " << i << " 个菜" << endl;
                cout << "美味度 = "<<path[0] << " 饱腹度 = " << path[1] << endl;
                backTracking(materials, cookbooks, attribute, limit, i + 1);
                path[0] -= attribute[i][0];
                path[1] -= attribute[i][1];
                for (int j = 0; j < materials.size(); j++) {
                    materials[j] += cookbooks[i][j];
                }
            }
        }
    }
public:
    int perfectMenu(vector<int>& materials, vector<vector<int>>& cookbooks, vector<vector<int>>& attribute, int limit) {
        path = vector<int>(2, 0);
        result = 0;
        backTracking(materials, cookbooks, attribute, limit, 0);
        if (result == 0) return -1;
        return result;
    }
}; // 2022.
```



### 3. 二叉搜索树染色

[3. 二叉搜索树染色](https://leetcode.cn/contest/season/2022-spring/problems/QO5KpG/)

欢迎各位勇者来到力扣城，本次试炼主题为「二叉搜索树染色」。

每位勇士面前设有一个**二叉搜索树**的模型，模型的根节点为 `root`，树上的各个节点值均不重复。初始时，所有节点均为蓝色。现在按顺序对这棵二叉树进行若干次操作， `ops[i] = [type, x, y]` 表示第 `i` 次操作为：

- `type` 等于 0 时，将节点值范围在 `[x, y]` 的节点均染蓝
- `type` 等于 1 时，将节点值范围在 `[x, y]` 的节点均染红

请返回完成所有染色后，该二叉树中红色节点的数量。

**注意：**

- 题目保证对于每个操作的 `x`、`y` 值定出现在二叉搜索树节点中

**示例 1：**

> 输入：`root = [1,null,2,null,3,null,4,null,5], ops = [[1,2,4],[1,1,3],[0,3,5]]`
>
> 输出：`2`
>
> 解释：
> 第 0 次操作，将值为 2、3、4 的节点染红；
> 第 1 次操作，将值为 1、2、3 的节点染红；
> 第 2 次操作，将值为 3、4、5 的节点染蓝；
> 因此，最终值为 1、2 的节点为红色节点，返回数量 2
> ![image.png](https://pic.leetcode-cn.com/1649833948-arSlXd-image.png)

**示例 2：**

> 输入：`root = [4,2,7,1,null,5,null,null,null,null,6]`
> `ops = [[0,2,2],[1,1,5],[0,4,5],[1,5,7]]`
>
> 输出：`5`
>
> 解释：
> 第 0 次操作，将值为 2 的节点染蓝；
> 第 1 次操作，将值为 1、2、4、5 的节点染红；
> 第 2 次操作，将值为 4、5 的节点染蓝；
> 第 3 次操作，将值为 5、6、7 的节点染红；
> 因此，最终值为 1、2、5、6、7 的节点为红色节点，返回数量 5
> ![image.png](https://pic.leetcode-cn.com/1649833763-BljEbP-image.png)

**提示：**

- `1 <= 二叉树节点数量 <= 10^5`
- `1 <= ops.length <= 10^5`
- `ops[i].length == 3`
- `ops[i][0]` 仅为 `0` or `1`
- `0 <= ops[i][1] <= ops[i][2] <= 10^9`
- `0 <= 节点值 <= 10^9`

```c++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
    int a[100005],n;
    void dfs(TreeNode* root)
    {
        if(root==nullptr)return;
        dfs(root->left);
        a[++n]=root->val;
        dfs(root->right);
    }
    int m[262144];
    void get(int R,int x)
    {
        m[R]=x;
    }
    void down(int R)
    {
        if(~m[R])
        {
            get(R<<1,m[R]);
            get(R<<1|1,m[R]);
            m[R]=-1;
        }
    }
    void fix(int R,int l,int r,int l1,int r1,int x)
    {
        if(l1<=l&&r<=r1)
        {
            get(R,x);
            return;
        }
        down(R);
        int mid=l+r>>1;
        if(l1<=mid)fix(R<<1,l,mid,l1,r1,x);
        if(r1>mid)fix(R<<1|1,mid+1,r,l1,r1,x);
    }
    int work(int R,int l,int r)
    {
        if(l==r)return m[R];
        down(R);
        int mid=l+r>>1;
        return work(R<<1,l,mid)+work(R<<1|1,mid+1,r);
    }
public:
    int getNumber(TreeNode* root, vector<vector<int>>& ops) {
        n=0;
        dfs(root);
        for(auto &o:ops)
        {
            int l=lower_bound(a+1,a+n+1,o[1])-a,r=upper_bound(a+1,a+n+1,o[2])-a-1;
            if(l<=r)fix(1,1,n,l,r,o[0]);
        }
        return work(1,1,n);
    }
};
```



### 4. 守护太空城

[4. 守护太空城](https://leetcode.cn/contest/season/2022-spring/problems/EJvmW4/)

各位勇者请注意，力扣太空城发布陨石雨红色预警。

太空城中的一些舱室将要受到陨石雨的冲击，这些舱室按照编号 `0 ~ N` 的顺序依次排列。为了阻挡陨石损毁舱室，太空城可以使用能量展开防护屏障，具体消耗如下：

- 选择一个舱室开启屏障，能量消耗为 `2`
- 选择相邻两个舱室开启联合屏障，能量消耗为 `3`
- 对于已开启的**一个**屏障，**多维持一时刻**，能量消耗为 `1`

已知陨石雨的影响范围和到达时刻，`time[i]` 和 `position[i]` 分别表示该陨石的到达时刻和冲击位置。请返回太空舱能够守护所有舱室所需要的最少能量。

**注意：**

- 同一时间，一个舱室不能被多个屏障覆盖
- 陨石雨仅在到达时刻对冲击位置处的舱室有影响

**示例 1：**

> 输入：`time = [1,2,1], position = [6,3,3]`
>
> 输出：`5`
>
> 解释：
> 时刻 1，分别开启编号 3、6 舱室的屏障，能量消耗 2*2 = 4
> 时刻 2，维持编号 3 舱室的屏障，能量消耗 1
> 因此，最少需要能量 5

**示例 2：**

> 输入：`time = [1,1,1,2,2,3,5], position = [1,2,3,1,2,1,3]`
>
> 输出：`9`
>
> 解释：
> 时刻 1，开启编号 1、2 舱室的联合屏障，能量消耗 3
> 时刻 1，开启编号 3 舱室的屏障，能量消耗 2
> 时刻 2，维持编号 1、2 舱室的联合屏障，能量消耗 1
> 时刻 3，维持编号 1、2 舱室的联合屏障，能量消耗 1
> 时刻 5，重新开启编号 3 舱室的联合屏障，能量消耗 2
> 因此，最少需要能量 9

**提示：**

- `1 <= time.length == position.length <= 500`
- `1 <= time[i] <= 5`
- `0 <= position[i] <= 100`

汪乐平的代码

```c++
class Solution {
    int a[105],f[105][32];
public:
    int defendSpaceCity(vector<int>& time, vector<int>& position) {
        memset(a,0,sizeof(a));
        int n=100,m=time.size(),i,j,k,l,o,s,t;
        for(i=0;i<m;i++)a[position[i]+1]|=1<<time[i]-1;
        memset(f,127,sizeof(f));
        memset(f[0],0,sizeof(f[0]));
        for(i=1;i<=n+1;i++)for(j=0;j<32;j++)
        {
            for(k=0;k<32;k++)
            {
                for(l=0,o=-1,s=0,t=0;l<5;l++)if(j>>l&1)
                {
                    o=-1;
                }
                else if(a[i]>>l&1)
                {
                    t|=k&1<<l;
                    if(o==(k>>l&1))s++;
                    else s+=(k>>l&1)+2;
                    o=k>>l&1;
                }
                else if(k>>l&1)
                {
                    t|=1<<l;
                    if(o==1)s++;
                    else s+=3;
                    o=1;
                }
                else o=-1;
                f[i][j]=min(f[i][j],f[i-1][t]+s);
            }
        }
        return f[n+1][0];
    }
};
```



### 5. 夺回据点

[5. 夺回据点](https://leetcode.cn/contest/season/2022-spring/problems/s5kipK/)

欢迎各位勇者来到力扣城，本次试炼主题为「夺回据点」。

魔物了占领若干据点，这些据点被若干条道路相连接，`roads[i] = [x, y]` 表示编号 `x`、`y` 的两个据点通过一条道路连接。

现在勇者要将按照以下原则将这些据点逐一夺回：

- 在开始的时候，勇者可以花费资源先夺回一些据点，初始夺回第 `j` 个据点所需消耗的资源数量为 `cost[j]`
- 接下来，勇者在不消耗资源情况下，每次可以夺回**一个**和「已夺回据点」相连接的魔物据点，并对其进行夺回

> 注：为了防止魔物暴动，勇者在每一次夺回据点后（包括花费资源夺回据点后），需要保证剩余的所有魔物据点之间是相连通的（不经过「已夺回据点」）。

请返回勇者夺回所有据点需要消耗的最少资源数量。

**注意：**

- 输入保证初始所有据点都是连通的，且不存在重边和自环

**示例 1：**

> 输入：
> `cost = [1,2,3,4,5,6]`
> `roads = [[0,1],[0,2],[1,3],[2,3],[1,2],[2,4],[2,5]]`
>
> 输出：`6`
>
> 解释：
> 勇者消耗资源 `6` 夺回据点 `0` 和 `4`，魔物据点 `1、2、3、5` 相连通；
> 第一次夺回据点 `1`，魔物据点 `2、3、5` 相连通；
> 第二次夺回据点 `3`，魔物据点 `2、5` 相连通；
> 第三次夺回据点 `2`，剩余魔物据点 `5`；
> 第四次夺回据点 `5`，无剩余魔物据点；
> 因此最少需要消耗资源为 `6`，可占领所有据点。
> ![image.png](https://pic.leetcode-cn.com/1648706944-KJstUN-image.png)

**示例 2：**

> 输入：
> `cost = [3,2,1,4]`
> `roads = [[0,2],[2,3],[3,1]]`
>
> 输出：`2`
>
> 解释：
> 勇者消耗资源 `2` 夺回据点 `1`，魔物据点 `0、2、3` 相连通；
> 第一次夺回据点 `3`，魔物据点 `2、0` 相连通；
> 第二次夺回据点 `2`，剩余魔物据点 `0`；
> 第三次夺回据点 `0`，无剩余魔物据点；
> 因此最少需要消耗资源为 `2`，可占领所有据点。
> ![image.png](https://pic.leetcode-cn.com/1648707186-LJRwzU-image.png)

**提示：**

- `1 <= roads.length, cost.length <= 10^5`
- `0 <= roads[i][0], roads[i][1] < cost.length`
- `1 <= cost[i] <= 10^9`

## 第289场周赛-2022.4.17

### 第一题 计算字符串的数字和

[6070. 计算字符串的数字和](https://leetcode-cn.com/problems/calculate-digit-sum-of-a-string/)

https://leetcode-cn.com/contest/weekly-contest-289/problems/calculate-digit-sum-of-a-string/

给你一个由若干数字（`0` - `9`）组成的字符串 `s` ，和一个整数。

如果 `s` 的长度大于 `k` ，则可以执行一轮操作。在一轮操作中，需要完成以下工作：

1. 将 `s` **拆分** 成长度为 `k` 的若干 **连续数字组** ，使得前 `k` 个字符都分在第一组，接下来的 `k` 个字符都分在第二组，依此类推。**注意**，最后一个数字组的长度可以小于 `k` 。
2. 用表示每个数字组中所有数字之和的字符串来 **替换** 对应的数字组。例如，`"346"` 会替换为 `"13"` ，因为 `3 + 4 + 6 = 13` 。
3. **合并** 所有组以形成一个新字符串。如果新字符串的长度大于 `k` 则重复第一步。

返回在完成所有轮操作后的 `s` 。

 

**示例 1：**

```
输入：s = "11111222223", k = 3
输出："135"
解释：
- 第一轮，将 s 分成："111"、"112"、"222" 和 "23" 。
  接着，计算每一组的数字和：1 + 1 + 1 = 3、1 + 1 + 2 = 4、2 + 2 + 2 = 6 和 2 + 3 = 5 。 
  这样，s 在第一轮之后变成 "3" + "4" + "6" + "5" = "3465" 。
- 第二轮，将 s 分成："346" 和 "5" 。
  接着，计算每一组的数字和：3 + 4 + 6 = 13 、5 = 5 。
  这样，s 在第二轮之后变成 "13" + "5" = "135" 。 
现在，s.length <= k ，所以返回 "135" 作为答案。
```

**示例 2：**

```
输入：s = "00000000", k = 3
输出："000"
解释：
将 "000", "000", and "00".
接着，计算每一组的数字和：0 + 0 + 0 = 0 、0 + 0 + 0 = 0 和 0 + 0 = 0 。 
s 变为 "0" + "0" + "0" = "000" ，其长度等于 k ，所以返回 "000" 。
```

 

**提示：**

- `1 <= s.length <= 100`
- `2 <= k <= 100`
- `s` 仅由数字（`0` - `9`）组成。

代码部分：

```c++
class Solution {
public:
    string digitSum(string s, int k) {
        while (s.size() > k) {
            string str = "";
            for (int i = 0; i < s.size(); i += k) {
                string subS = s.substr(i, k);
                int num = 0;
                for (auto c : subS) {
                    num += c - '0';
                }
                str += to_string(num);
            }
            s = str;
        }
        return s;
    }
};
```



### 第二题 完成所有任务需要的最少轮数

[6071. 完成所有任务需要的最少轮数](https://leetcode-cn.com/problems/minimum-rounds-to-complete-all-tasks/)

https://leetcode-cn.com/contest/weekly-contest-289/problems/minimum-rounds-to-complete-all-tasks/

给你一个下标从 **0** 开始的整数数组 `tasks` ，其中 `tasks[i]` 表示任务的难度级别。在每一轮中，你可以完成 2 个或者 3 个 **相同难度级别** 的任务。

返回完成所有任务需要的 **最少** 轮数，如果无法完成所有任务，返回 `-1` 。

 

**示例 1：**

```
输入：tasks = [2,2,3,3,2,4,4,4,4,4]
输出：4
解释：要想完成所有任务，一个可能的计划是：
- 第一轮，完成难度级别为 2 的 3 个任务。 
- 第二轮，完成难度级别为 3 的 2 个任务。 
- 第三轮，完成难度级别为 4 的 3 个任务。 
- 第四轮，完成难度级别为 4 的 2 个任务。 
可以证明，无法在少于 4 轮的情况下完成所有任务，所以答案为 4 。
```

**示例 2：**

```
输入：tasks = [2,3,3]
输出：-1
解释：难度级别为 2 的任务只有 1 个，但每一轮执行中，只能选择完成 2 个或者 3 个相同难度级别的任务。因此，无法完成所有任务，答案为 -1 。
```

 

**提示：**

- `1 <= tasks.length <= 105`
- `1 <= tasks[i] <= 109`

思路：

​		任何大于1的正整数 n 都可由 2 和 3 相加组成,  并且 2 和 3 的个数 cnt **最少**为：`cnt = (n - 1) / 3 + 1`

代码部分：

```c++
class Solution {
public:
    int minimumRounds(vector<int>& tasks) {
        map<int, int> cnt;
        for (int i : tasks) ++cnt[i];
        int ans = 0;
        for (auto i : cnt) {
            if (i.second == 1) return -1;
            ans += (i.second - 1) / 3 + 1;
        }
        return ans;
    }
};
```



### 第三题 转角路径的乘积中最多能有几个尾随零（不会）

[6072. 转角路径的乘积中最多能有几个尾随零](https://leetcode-cn.com/problems/maximum-trailing-zeros-in-a-cornered-path/)

https://leetcode-cn.com/contest/weekly-contest-289/problems/maximum-trailing-zeros-in-a-cornered-path/

给你一个二维整数数组 `grid` ，大小为 `m x n`，其中每个单元格都含一个正整数。

**转角路径** 定义为：包含至多一个弯的一组相邻单元。具体而言，路径应该完全 **向水平方向** 或者 **向竖直方向** 移动过弯（如果存在弯），而不能访问之前访问过的单元格。在过弯之后，路径应当完全朝 **另一个** 方向行进：如果之前是向水平方向，那么就应该变为向竖直方向；反之亦然。当然，同样不能访问之前已经访问过的单元格。

一条路径的 **乘积** 定义为：路径上所有值的乘积。

请你从 `grid` 中找出一条乘积中尾随零数目最多的转角路径，并返回该路径中尾随零的数目。

注意：

- **水平** 移动是指向左或右移动。
- **竖直** 移动是指向上或下移动。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/23/ex1new2.jpg)

```
输入：grid = [[23,17,15,3,20],[8,1,20,27,11],[9,4,6,2,21],[40,9,1,10,6],[22,7,4,5,3]]
输出：3
解释：左侧的图展示了一条有效的转角路径。
其乘积为 15 * 20 * 6 * 1 * 10 = 18000 ，共计 3 个尾随零。
可以证明在这条转角路径的乘积中尾随零数目最多。

中间的图不是一条有效的转角路径，因为它有不止一个弯。
右侧的图也不是一条有效的转角路径，因为它需要重复访问已经访问过的单元格。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/25/ex2.jpg)

```
输入：grid = [[4,3,2],[7,6,1],[8,8,8]]
输出：0
解释：网格如上图所示。
不存在乘积含尾随零的转角路径。
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 105`
- `1 <= m * n <= 105`
- `1 <= grid[i][j] <= 1000`

解题思路
题目需要我们求至多有一个拐点的路径尾随零数目最多的路径，返回尾随零的数目。
从题目可以了解到以下2个重点信息：

1. 只需要求尾随零数目，我们不必真的去做累乘计算，事实上连乘运算非常容易超时（很少会有前缀乘积），乘积需要出0是由数字2和5来保证的，0的数目就是2个相乘数2和5的个数和的最小值，所以我们二维数组记录的都不是原来的数字，而是这个数字包含的2和5因子的个数。

2. 最多只会有1个拐点，数据规模太大我们肯定不能通过DFS、BFS去枚举所有的路径，所以我们退而求其次去枚举这个唯一的拐点，没有拐点的情况其实就是前缀和情况，不用单独计算。
3. 有了以上思路后，这道题只完成了一半，这道题困难的是模拟这个过程比较难写，我这边是建立了left, right, up, down 四个二维前缀和数组，分别表示在[i, j]节点上 左边、右边、上边、下边前缀和的个数（这里的前缀和指的是分别统计的2和5的个数），注意**不包含当前节点**。对于某一个拐点，只会有左上、左下、右上、右下四种情况（可以画图模拟一下）
4. 模拟的过程如下：
5. 记录下每个节点的 2 和 5 的数目，记录到一个二维pair数组中
6. 预处理四个方向前缀和数组，注意判断边界，因为我们前缀和数组不包含自己，所以四个边界（i = 0, j = 0, i = m - 1, j = n - 1）我们不需要特殊处理，让相应的方向自然为0就行
7. 枚举每一个数作为拐点，按照四种可能性计算这条路径上2和5分别的总数目，两者取min就是这条路径的尾随零个数，所有合法路径的最大值就是答案。

代码部分：

```c++
class Solution {
private:
    typedef pair<int, int> pii;
public:
    int maxTrailingZeros(vector<vector<int>>& grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<pii>> g(m, vector<pii>(n)); // 记录下每个节点的2和5的数目，记录到一个二维pair数组中
        vector<vector<pii>> l(m, vector<pii>(n)); // 左边方向的前缀和数组（不包含自己）
        vector<vector<pii>> r(m, vector<pii>(n)); // 右边方向的前缀和数组（不包含自己）
        vector<vector<pii>> u(m, vector<pii>(n)); // 上边方向的前缀和数组（不包含自己）
        vector<vector<pii>> d(m, vector<pii>(n)); // 下边方向的前缀和数组（不包含自己）
        int ans = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int num = grid[i][j];
                int cnt2 = 0;
                int cnt5 = 0;
                while (num % 5 == 0) {
                    num /= 5;
                    ++cnt5;
                }
                while (num % 2 == 0) {
                    num /= 2;
                    ++cnt2;
                }
                g[i][j] = {cnt2, cnt5}; // 记录每个数的2和5因子的个数
            }
        }

        // 预处理四个方向的前缀和数组，前缀和数组不包含本单元格的值
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (i >= 1) {
                    u[i][j] = {u[i - 1][j].first + g[i - 1][j].first, u[i - 1][j].second + g[i - 1][j].second};
                }
                if (j >= 1) {
                    l[i][j] = {l[i][j - 1].first + g[i][j - 1].first, l[i][j - 1].second + g[i][j - 1].second};
                }
            }
        }
        
        for (int i = m - 1; i >= 0; --i) {
            for (int j = n - 1; j >= 0; --j) {
                if (i < m - 1) {
                    d[i][j] = {d[i + 1][j].first + g[i + 1][j].first, d[i + 1][j].second + g[i + 1][j].second};
                }
                if (j < n - 1) {
                    r[i][j] = {r[i][j + 1].first + g[i][j + 1].first, r[i][j + 1].second + g[i][j + 1].second};
                }
            }
        }
        
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                int cnt2 = g[i][j].first;
                int cnt5 = g[i][j].second;
                int res = 0;
                // 左上
                int now2 = l[i][j].first + u[i][j].first + cnt2;
                int now5 = l[i][j].second + u[i][j].second + cnt5;
                res = max(res, min(now2, now5));
                // 左下
                now2 = l[i][j].first + d[i][j].first + cnt2;
                now5 = l[i][j].second + d[i][j].second + cnt5;
                res = max(res, min(now2, now5));
                // 右上
                now2 = r[i][j].first + u[i][j].first + cnt2;
                now5 = r[i][j].second + u[i][j].second + cnt5;
                res = max(res, min(now2, now5));
                // 右下
                now2 = r[i][j].first + d[i][j].first + cnt2;
                now5 = r[i][j].second + d[i][j].second + cnt5;
                res = max(res, min(now2, now5));
                ans = max(ans, res);
            }
        }
        return ans;
    }
};
```



### 第四题 相邻字符不同的最长路径（不会）（微软2022.2.12笔试第3题）

[6073. 相邻字符不同的最长路径](https://leetcode-cn.com/problems/longest-path-with-different-adjacent-characters/)

https://leetcode-cn.com/contest/weekly-contest-289/problems/longest-path-with-different-adjacent-characters/

给你一棵 **树**（即一个连通、无向、无环图），根节点是节点 `0` ，这棵树由编号从 `0` 到 `n - 1` 的 `n` 个节点组成。用下标从 **0** 开始、长度为 `n` 的数组 `parent` 来表示这棵树，其中 `parent[i]` 是节点 `i` 的父节点，由于节点 `0` 是根节点，所以 `parent[0] == -1` 。

另给你一个字符串 `s` ，长度也是 `n` ，其中 `s[i]` 表示分配给节点 `i` 的字符。

请你找出路径上任意一对相邻节点都没有分配到相同字符的 **最长路径** ，并返回该路径的长度。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/03/25/testingdrawio.png)

```
输入：parent = [-1,0,0,1,1,2], s = "abacbe"
输出：3
解释：任意一对相邻节点字符都不同的最长路径是：0 -> 1 -> 3 。该路径的长度是 3 ，所以返回 3 。
可以证明不存在满足上述条件且比 3 更长的路径。 
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/25/graph2drawio.png)

```
输入：parent = [-1,0,0,0], s = "aabc"
输出：3
解释：任意一对相邻节点字符都不同的最长路径是：2 -> 0 -> 3 。该路径的长度为 3 ，所以返回 3 。
```

 

**提示：**

- `n == parent.length == s.length`
- `1 <= n <= 105`
- 对所有 `i >= 1` ，`0 <= parent[i] <= n - 1` 均成立
- `parent[0] == -1`
- `parent` 表示一棵有效的树
- `s` 仅由小写英文字母组成

思路：

采用拓扑排序的思路，用数组 degree 记录当前节点的入度（即子节点个数）。
从叶子节点开始，自底向上更新两个一维数组u和t。
length[i]表示以 i 为根的子树上，能够形成满足条件的最长路径长度；
tree[i]表示在当前已拓展过的节点中以i为根的子树的最大深度；
因此有公式：（parV 为parent[i]，即 i 为新拓展完毕的子树，parV 为当前正在拓展的子树）
length[parV] = max(length[parV], tree[i]+tree[parV]);（表示新拓展一棵子树之后，与已拓展过的子树形成的最长路径）
tree[parV] = max(tree[parV], tree[i]+1);（以新拓展的子树更新最大深度）
(两条公式的前后关系不能搞反，否则在更新了 tree 之后，length 就没法判断了)
注意：判断一下相邻节点是否相等，如果相等就舍弃掉这条路径，以1为深度继续拓展即可。
最后返回u中的最大值即为全局最长路径。

代码部分：

```c++
class Solution {
public:
    int longestPath(vector<int>& parent, string s) {
        int n = parent.size();
        vector<int> degree(n, 0);
        vector<int> tree(n, 1); // 以 i 为根节点的相邻字符不同的树的最大深度
        vector<int> length(n, 1); // 表示以i为根的子树上，能够形成满足条件的最长路径长度
        for (int i = 1; i < n; i++) {
            degree[parent[i]]++;
        }
        queue<int> que;
        for (int i = 0; i < n; i++) {
            if (!degree[i]) {
                que.push(i);
                tree[i] = 1;
            }
        }
        while (!que.empty()) {
            int v = que.front();
            que.pop();
            if (v == 0) {
                break;
            }
            int parV = parent[v];
            if (s[parV] != s[v]) {
                length[parV] = max(length[parV], tree[v] + tree[parV]);
                tree[parV] = max(tree[parV], tree[v] + 1);
            }
            degree[parV]--;
            if (!degree[parV]) {
                que.push(parV);
            }
        }
        int result = 0;
        for (int i = 0; i < n; i++) {
            result = max(result, length[i]);
        }
        return result;
    }
};
/*
用拓扑排序的方法从叶子节点开始，自底向上更新两个一维数组 tree 和 length。
*///2022。4.19
```

树状DP

代码部分：

```c++
class Solution {
private:
    int result = 0;
    vector<int> dp;
    vector<int> tree; // tree[i] 表示以节点 i 为根节点且相邻节点字符不相等的树的最大深度
    vector<vector<int>> son;
    void dfs(int rootIndex, string& s) {
        for (auto v : son[rootIndex]) {
            dfs(v, s);
            if (s[rootIndex] != s[v]) {
                dp[rootIndex] = max(dp[rootIndex], tree[rootIndex] + tree[v]);
                tree[rootIndex] = max(tree[rootIndex], tree[v] + 1);
            }
        }
        result = max(result, dp[rootIndex]);
    }
public:
    int longestPath(vector<int>& parent, string s) {
        int n = parent.size();
        son = vector<vector<int>>(n);
        dp = vector<int>(n, 1);
        tree = vector<int>(n, 1);
        for (int i = 1; i < n; i++) son[parent[i]].push_back(i);
        dfs(0, s);
        return result;
    }
};
// 2022.4.20
```

## 第 76 场双周赛-2022.4.16

[第 76 场双周赛](https://leetcode-cn.com/contest/biweekly-contest-76/)

### 2239. 找到最接近 0 的数字（SE）

[找到最接近 0 的数字](https://leetcode-cn.com/problems/find-closest-number-to-zero/)

给你一个长度为 `n` 的整数数组 `nums` ，请你返回 `nums` 中最 **接近** `0` 的数字。如果有多个答案，请你返回它们中的 **最大值** 。

 

**示例 1：**

```
输入：nums = [-4,-2,1,4,8]
输出：1
解释：
-4 到 0 的距离为 |-4| = 4 。
-2 到 0 的距离为 |-2| = 2 。
1 到 0 的距离为 |1| = 1 。
4 到 0 的距离为 |4| = 4 。
8 到 0 的距离为 |8| = 8 。
所以，数组中距离 0 最近的数字为 1 。
```

**示例 2：**

```
输入：nums = [2,-1,1]
输出：1
解释：1 和 -1 都是距离 0 最近的数字，所以返回较大值 1 。
```

 

**提示：**

- `1 <= n <= 1000`
- `-105 <= nums[i] <= 105`

代码部分：

```c++
class Solution {
private:
    static bool cmp(const int a, const int b) {
        return abs(a) == abs(b) ? a > b : abs(a) < abs(b);
    }
public:
    int findClosestNumber(vector<int>& nums) {
        sort(nums.begin(), nums.end(), cmp);
        return nums[0];
    }
};
```

### 2240.买钢笔和铅笔的方案数（SE)

[买钢笔和铅笔的方案数](https://leetcode-cn.com/problems/number-of-ways-to-buy-pens-and-pencils/)

给你一个整数 `total` ，表示你拥有的总钱数。同时给你两个整数 `cost1` 和 `cost2` ，分别表示一支钢笔和一支铅笔的价格。你可以花费你部分或者全部的钱，去买任意数目的两种笔。

请你返回购买钢笔和铅笔的 **不同方案数目** 。

 

**示例 1：**

```
输入：total = 20, cost1 = 10, cost2 = 5
输出：9
解释：一支钢笔的价格为 10 ，一支铅笔的价格为 5 。
- 如果你买 0 支钢笔，那么你可以买 0 ，1 ，2 ，3 或者 4 支铅笔。
- 如果你买 1 支钢笔，那么你可以买 0 ，1 或者 2 支铅笔。
- 如果你买 2 支钢笔，那么你没法买任何铅笔。
所以买钢笔和铅笔的总方案数为 5 + 3 + 1 = 9 种。
```

**示例 2：**

```
输入：total = 5, cost1 = 10, cost2 = 10
输出：1
解释：钢笔和铅笔的价格都为 10 ，都比拥有的钱数多，所以你没法购买任何文具。所以只有 1 种方案：买 0 支钢笔和 0 支铅笔。
```

 

**提示：**

- `1 <= total, cost1, cost2 <= 106`

代码部分：

```c++
class Solution {
public:
    long long waysToBuyPensPencils(int total, int cost1, int cost2) {
        long long result = 0;
        int cntPen = total / cost1;
        for (int i = 0; i <= cntPen; i++) {
            result += (total - i * cost1) / cost2 + 1;
        }
        return result;
    }
};
```

### 2241. 设计一个 ATM 机器（Debug很久）

[设计一个 ATM 机器](https://leetcode-cn.com/problems/design-an-atm-machine/)

一个 ATM 机器，存有 `5` 种面值的钞票：`20` ，`50` ，`100` ，`200` 和 `500` 美元。初始时，ATM 机是空的。用户可以用它存或者取任意数目的钱。

取款时，机器会优先取 **较大** 数额的钱。

- 比方说，你想取 `$300` ，并且机器里有 `2` 张 `$50` 的钞票，`1` 张 `$100` 的钞票和`1` 张 `$200` 的钞票，那么机器会取出 `$100` 和 `$200` 的钞票。
- 但是，如果你想取 `$600` ，机器里有 `3` 张 `$200` 的钞票和`1` 张 `$500` 的钞票，那么取款请求会被拒绝，因为机器会先取出 `$500` 的钞票，然后无法取出剩余的 `$100` 。注意，因为有 `$500` 钞票的存在，机器 **不能** 取 `$200` 的钞票。

请你实现 ATM 类：

- `ATM()` 初始化 ATM 对象。
- `void deposit(int[] banknotesCount)` 分别存入 `$20` ，`$50`，`$100`，`$200` 和 `$500` 钞票的数目。
- `int[] withdraw(int amount)` 返回一个长度为 `5` 的数组，分别表示 `$20` ，`$50`，`$100` ，`$200` 和 `$500` 钞票的数目，并且更新 ATM 机里取款后钞票的剩余数量。如果无法取出指定数额的钱，请返回 `[-1]` （这种情况下 **不** 取出任何钞票）。

 

**示例 1：**

```
输入：
["ATM", "deposit", "withdraw", "deposit", "withdraw", "withdraw"]
[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]
输出：
[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]

解释：
ATM atm = new ATM();
atm.deposit([0,0,1,2,1]); // 存入 1 张 $100 ，2 张 $200 和 1 张 $500 的钞票。
atm.withdraw(600);        // 返回 [0,0,1,0,1] 。机器返回 1 张 $100 和 1 张 $500 的钞票。机器里剩余钞票的数量为 [0,0,0,2,0] 。
atm.deposit([0,1,0,1,1]); // 存入 1 张 $50 ，1 张 $200 和 1 张 $500 的钞票。
                          // 机器中剩余钞票数量为 [0,1,0,3,1] 。
atm.withdraw(600);        // 返回 [-1] 。机器会尝试取出 $500 的钞票，然后无法得到剩余的 $100 ，所以取款请求会被拒绝。
                          // 由于请求被拒绝，机器中钞票的数量不会发生改变。
atm.withdraw(550);        // 返回 [0,1,0,0,1] ，机器会返回 1 张 $50 的钞票和 1 张 $500 的钞票。
```

 

**提示：**

- `banknotesCount.length == 5`
- `0 <= banknotesCount[i] <= 109`
- `1 <= amount <= 109`
- **总共** 最多有 `5000` 次 `withdraw` 和 `deposit` 的调用。
- 函数 `withdraw` 和 `deposit` 至少各有 **一次** 调用。

代码部分 ：

```c++
class ATM {
private:
    vector<pair<int, long long>> money;
public:
    ATM() {
        money = vector<pair<int, long long>>(5);
        money[0] = { 20, 0 };
        money[1] = { 50, 0 };
        money[2] = { 100, 0 };
        money[3] = { 200, 0 };
        money[4] = { 500, 0 };
    }

    void deposit(vector<int> banknotesCount) {
        for (int i = 0; i < banknotesCount.size(); i++) {
            money[i].second += banknotesCount[i];
            //cout << money[i].second << " ";
        }
        //cout << endl;
    }

    vector<int> withdraw(int amount) {
        vector<int> result(5, 0);
        //cout << "应该取 ：" << endl;
        for (int i = 4; i >= 0; i--) {
            result[i] = amount / money[i].first;
            if (result[i] > money[i].second) result[i] = (int)money[i].second;
            //cout << "result[" << i << "] = " << result[i] << " ";
            amount = amount - result[i] * money[i].first;
        }
        //cout << endl;
        //cout << "取完后: " << endl;
        if (amount != 0) return { -1 };
        for (int i = 0; i < result.size(); i++) {
            money[i].second -= result[i];
            //cout << "money[" << i << "].second = " << money[i].second << " ";
        }
        //cout << endl;
        return result;
    }
};
```

### 2242. 节点序列的最大得分（不会）

[节点序列的最大得分](https://leetcode-cn.com/problems/maximum-score-of-a-node-sequence/)

给你一个 `n` 个节点的 **无向图** ，节点编号为 `0` 到 `n - 1` 。

给你一个下标从 **0** 开始的整数数组 `scores` ，其中 `scores[i]` 是第 `i` 个节点的分数。同时给你一个二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` ，表示节点 `ai` 和 `bi` 之间有一条 **无向** 边。

一个合法的节点序列如果满足以下条件，我们称它是 **合法的** ：

- 序列中每 **相邻** 节点之间有边相连。
- 序列中没有节点出现超过一次。

节点序列的分数定义为序列中节点分数之 **和** 。

请你返回一个长度为 `4` 的合法节点序列的最大分数。如果不存在这样的序列，请你返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/04/15/ex1new3.png)

```
输入：scores = [5,2,9,8,4], edges = [[0,1],[1,2],[2,3],[0,2],[1,3],[2,4]]
输出：24
解释：上图为输入的图，节点序列为 [0,1,2,3] 。
节点序列的分数为 5 + 2 + 9 + 8 = 24 。
观察可知，没有其他节点序列得分和超过 24 。
注意节点序列 [3,1,2,0] 和 [1,0,2,3] 也是合法的，且分数为 24 。
序列 [0,3,2,4] 不是合法的，因为没有边连接节点 0 和 3 。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/03/17/ex2.png)

```
输入：scores = [9,20,6,4,11,12], edges = [[0,3],[5,3],[2,4],[1,3]]
输出：-1
解释：上图为输入的图。
没有长度为 4 的合法序列，所以我们返回 -1 。
```

 

**提示：**

- `n == scores.length`
- `4 <= n <= 5 * 104`
- `1 <= scores[i] <= 108`
- `0 <= edges.length <= 5 * 104`
- `edges[i].length == 2`
- `0 <= ai, bi <= n - 1`
- `ai != bi`
- 不会有重边。

思路：（别人的作题思路）

**提示 1-1**
试试枚举可不可以。（做题时优先考虑最简单的算法）

**提示 1-2**
枚举谁呢？可以枚举点，也可以枚举边。

**提示 2-1**
简化问题可以帮助我们找到思路。

如果序列只要求 33 个点，要如何枚举？

**提示 2-2**
只要求 33 个点的话，可以枚举端点，也可以枚举中间的点。

**提示 2-3**
枚举中间的点是最方便的，算出与其相邻的分数最大的两个点即可。

另外相比枚举端点，枚举中间的效率也要更高。

顺着这个思路去思考原问题。

**提示 3-1**
设序列为 a-x-y-b（− 表示边），枚举 edges 中的每条边，作为序列正中间的那条边，即 x-y。

**提示 3-2**
我们需要把与 x 相邻的点中，分数最大且不同于 y 和 b 的点作为 a；把与 y 相邻的点中，分数最大且不同于 x 和 a 的点作为 b。

**提示 3-3**
与 x 相邻的点中，由于只需要与 y 和 b 不一样，我们仅需要保留分数最大的三个点，a 必定在这三个点中。

**提示 3-4**
剩下要做的，就是在枚举edges 前，预处理出这三个点。

代码实现时，可以用排序（见 Go 和 Java）、堆（见 Python nlargest）、分治（见 C++ nth_element）或者手动维护求前三大。最优的时间复杂度为 O(n+m)。
**C++版代码：**

```c++
class Solution {
public:
    int maximumScore(vector<int> &scores, vector<vector<int>> &edges) {
        int n = scores.size();
        vector<vector<pair<int, int>>> graph(n);
        for (auto &e : edges) {
            int x = e[0], y = e[1];
            graph[x].emplace_back(-scores[y], y);
            graph[y].emplace_back(-scores[x], x);
        }
        for (auto &vs : graph)
            if (vs.size() > 3) { // 排序取前三
                nth_element(vs.begin(), vs.begin() + 3, vs.end());
                vs.resize(3);
            }

        int ans = -1;
        // a - x - y - b
        // a — x — y — b,其中枚举的是x——y这条边,那么要想和的值最大,那么就需要找出a与b的最大值
        // 找出a中不与y和b重合的最大值(肯定不与x重合,因为a是x相邻的边)
        // 同理找出b中不与x和a重合的最大值(肯定不与y重合,因为b是y相邻的边)
        // 因此找出a相邻边的最大的那三条,那么a必定会取到其中一条是符合要求的最长边(利用排序)
        // 因为与 a 相邻的边最多与 y 和 b 相同，那么只要与 a 相邻的有 3 条边，必定有一条边的节点不等于 x，y，b
        for (auto &e : edges) {
            int x = e[0], y = e[1]; // 枚举的当前这条边是 u->v
            for (auto &[score_a, a] : graph[x]) // /枚举 x 前三个最大的分数点
                for (auto &[score_b, b] : graph[y])
                    if (a != y && b != x && a != b) // 这几个点互不相同，就更新答案
                        ans = max(ans, -score_a + scores[x] + scores[y] - score_b);
        }
        return ans;
    }
}; // 2022.4.22
```

**Python版代码：**

```python
class Solution:
    def maximumScore(self, scores: List[int], edges: List[List[int]]) -> int:
        g = [[] for _ in range(len(scores))]
        for x, y in edges:
            g[x].append((scores[y], y))
            g[y].append((scores[x], x))
        for i, vs in enumerate(g):
            g[i] = nlargest(3, vs)

        # 下面这一段可以简写成一行，为了可读性这里就不写了
        ans = -1
        for x, y in edges:
            for (score_a, a), (score_b, b) in product(g[x], g[y]):
                if y != a != b != x:
                    ans = max(ans, score_a + scores[x] + scores[y] + score_b)
        return ans
```



## 第288场周赛-2022.4.10

### 2231. 按奇偶性交换后的最大数字（SE)

[2231. 按奇偶性交换后的最大数字](https://leetcode-cn.com/contest/weekly-contest-288/problems/largest-number-after-digit-swaps-by-parity/)

给你一个正整数 `num` 。你可以交换 `num` 中 **奇偶性** 相同的任意两位数字（即，都是奇数或者偶数）。

返回交换 **任意** 次之后 `num` 的 **最大** 可能值*。*

 

**示例 1：**

```
输入：num = 1234
输出：3412
解释：交换数字 3 和数字 1 ，结果得到 3214 。
交换数字 2 和数字 4 ，结果得到 3412 。
注意，可能存在其他交换序列，但是可以证明 3412 是最大可能值。
注意，不能交换数字 4 和数字 1 ，因为它们奇偶性不同。
```

**示例 2：**

```
输入：num = 65875
输出：87655
解释：交换数字 8 和数字 6 ，结果得到 85675 。
交换数字 5 和数字 7 ，结果得到 87655 。
注意，可能存在其他交换序列，但是可以证明 87655 是最大可能值。
```

 

**提示：**

- `1 <= num <= 109`

思路：

创建两个数组，一个存放所有奇数，一个存放所有偶数，排序后按递减排列。

代码部分：

```c++
class Solution {
private:
    static bool cmp(const int a, const int b){
        return a > b;
    }
public:
    int largestInteger(int num) {
        vector<char> odd;
        vector<char> even;
        string str = to_string(num);
        for (auto c : str) {
            if ((c - '0') % 2 == 0) {
                even.push_back(c);
            }
            else {
                odd.push_back(c);
            }
        }
        sort(odd.begin(), odd.end(), cmp);
        sort(even.begin(), even.end(), cmp);
        string res = "";
        int i = 0, j = 0;
        for (auto c : str) {
            if ((c - '0') % 2 == 0) {
                res += even[i++];
            } else {
                res += odd[j++];
            }
        }
        cout<<res<<endl;
        return stoi(res);
    }
};
```

### 2232. 向表达式添加括号后的最小结果（字符串分割题）

[2232. 向表达式添加括号后的最小结果](https://leetcode-cn.com/contest/weekly-contest-288/problems/minimize-result-by-adding-parentheses-to-expression/)

给你一个下标从 **0** 开始的字符串 `expression` ，格式为 `"<num1>+<num2>"` ，其中 `<num1>` 和 `<num2>` 表示正整数。

请你向 `expression` 中添加一对括号，使得在添加之后， `expression` 仍然是一个有效的数学表达式，并且计算后可以得到 **最小** 可能值。左括号 **必须** 添加在 `'+'` 的左侧，而右括号必须添加在 `'+'` 的右侧。

返回添加一对括号后形成的表达式 `expression` ，且满足 `expression` 计算得到 **最小** 可能值*。*如果存在多个答案都能产生相同结果，返回任意一个答案。

生成的输入满足：`expression` 的原始值和添加满足要求的任一对括号之后 `expression` 的值，都符合 32-bit 带符号整数范围。

 

**示例 1：**

```
输入：expression = "247+38"
输出："2(47+38)"
解释：表达式计算得到 2 * (47 + 38) = 2 * 85 = 170 。
注意 "2(4)7+38" 不是有效的结果，因为右括号必须添加在 '+' 的右侧。
可以证明 170 是最小可能值。
```

**示例 2：**

```
输入：expression = "12+34"
输出："1(2+3)4"
解释：表达式计算得到 1 * (2 + 3) * 4 = 1 * 5 * 4 = 20 。
```

**示例 3：**

```
输入：expression = "999+999"
输出："(999+999)"
解释：表达式计算得到 999 + 999 = 1998 。
```

 

**提示：**

- `3 <= expression.length <= 10`
- `expression` 仅由数字 `'1'` 到 `'9'` 和 `'+'` 组成
- `expression` 由数字开始和结束
- `expression` 恰好仅含有一个 `'+'`.
- `expression` 的原始值和添加满足要求的任一对括号之后 `expression` 的值，都符合 32-bit 带符号整数范围

代码部分：

```c++
class Solution {
public:
    string minimizeResult(string expression) {
        int len = expression.size();
        int pos = expression.find("+");
        int resNum = INT_MAX;
        string res = "";
        for (int left = 0; left < pos; left++) {
            for (int right = pos + 1; right < len; right++) {
                string s1 = expression.substr(0, left);
                string s21 = expression.substr(left, pos - left);
                string s22 = expression.substr(pos + 1, right - pos);
                string s3 = expression.substr(right + 1, len - right - 1);
                //cout << "s1 = " << s1 << " s21 = " << s21 << " s22 = " << s22 << " s3 = " << s3 << endl;
                
                int num1 = (s1 == "") ? 1 : stoi(s1);
                int num2 = stoi(s21) + stoi(s22);
                int num3 = (s3 == "") ? 1 : stoi(s3);

                int tmpNum = num1 * num2 * num3;

                if (tmpNum < resNum) {
                    resNum = tmpNum;
                    res = s1 + '(' + s21 + '+' + s22 + ')' + s3;
                }
            }
        }
        return res;
    }
};
```



### 2233. K 次增加后的最大乘积

[K 次增加后的最大乘积](https://leetcode-cn.com/contest/weekly-contest-288/problems/maximum-product-after-k-increments/)

给你一个非负整数数组 `nums` 和一个整数 `k` 。每次操作，你可以选择 `nums` 中 **任一** 元素并将它 **增加** `1` 。

请你返回 **至多** `k` 次操作后，能得到的 `nums`的 **最大乘积** 。由于答案可能很大，请你将答案对 `109 + 7` 取余后返回。

 

**示例 1：**

```
输入：nums = [0,4], k = 5
输出：20
解释：将第一个数增加 5 次。
得到 nums = [5, 4] ，乘积为 5 * 4 = 20 。
可以证明 20 是能得到的最大乘积，所以我们返回 20 。
存在其他增加 nums 的方法，也能得到最大乘积。
```

**示例 2：**

```
输入：nums = [6,3,3,2], k = 2
输出：216
解释：将第二个数增加 1 次，将第四个数增加 1 次。
得到 nums = [6, 4, 3, 3] ，乘积为 6 * 4 * 3 * 3 = 216 。
可以证明 216 是能得到的最大乘积，所以我们返回 216 。
存在其他增加 nums 的方法，也能得到最大乘积。
```

 

**提示：**

- `1 <= nums.length, k <= 105`
- `0 <= nums[i] <= 106`

思路：

​	刚开始想用DP写，思路是对的，但一定会超时。用优先级队列就非常简单了。

**结论：**

- **对于n个整数之和为m，求其n个整数之积的最大值**
- **由均值不等式可以得知，当 m 均分时，其乘积有最大值**

代码部分：

```c++
class Solution {
private:
    long long MOD = 1e9 + 7;
public:
    int maximumProduct(vector<int>& nums, int k) {
        priority_queue<int, vector<int>, greater<int>> pque;
        for (auto num : nums) {
            pque.push(num);
        }
        while (k > 0) {
            int val = pque.top() + 1;
            pque.pop();
            pque.push(val);
            k--;
        }
        int res = 1;
        while (!pque.empty()) {
            res = res % MOD * pque.top() % MOD;
            pque.pop();
        }
        return res;
    }
};
```

### 2234. 花园的最大总美丽值（不会）

[2234. 花园的最大总美丽值](https://leetcode-cn.com/contest/weekly-contest-288/problems/maximum-total-beauty-of-the-gardens/)

Alice 是 `n` 个花园的园丁，她想通过种花，最大化她所有花园的总美丽值。

给你一个下标从 **0** 开始大小为 `n` 的整数数组 `flowers` ，其中 `flowers[i]` 是第 `i` 个花园里已经种的花的数目。已经种了的花 **不能** 移走。同时给你 `newFlowers` ，表示 Alice 额外可以种花的 **最大数目** 。同时给你的还有整数 `target` ，`full` 和 `partial` 。

如果一个花园有 **至少** `target` 朵花，那么这个花园称为 **完善的** ，花园的 **总美丽值** 为以下分数之 **和** ：

- **完善** 花园数目乘以 `full`.
- 剩余 **不完善** 花园里，花的 **最少数目** 乘以 `partial` 。如果没有不完善花园，那么这一部分的值为 `0` 。

请你返回 Alice 种最多 `newFlowers` 朵花以后，能得到的 **最大** 总美丽值。

 

**示例 1：**

```
输入：flowers = [1,3,1,1], newFlowers = 7, target = 6, full = 12, partial = 1
输出：14
解释：Alice 可以按以下方案种花
- 在第 0 个花园种 2 朵花
- 在第 1 个花园种 3 朵花
- 在第 2 个花园种 1 朵花
- 在第 3 个花园种 1 朵花
花园里花的数目为 [3,6,2,2] 。总共种了 2 + 3 + 1 + 1 = 7 朵花。
只有 1 个花园是完善的。
不完善花园里花的最少数目是 2 。
所以总美丽值为 1 * 12 + 2 * 1 = 12 + 2 = 14 。
没有其他方案可以让花园总美丽值超过 14 。
```

**示例 2：**

```
输入：flowers = [2,4,5,3], newFlowers = 10, target = 5, full = 2, partial = 6
输出：30
解释：Alice 可以按以下方案种花
- 在第 0 个花园种 3 朵花
- 在第 1 个花园种 0 朵花
- 在第 2 个花园种 0 朵花
- 在第 3 个花园种 2 朵花
花园里花的数目为 [5,4,5,5] 。总共种了 3 + 0 + 0 + 2 = 5 朵花。
有 3 个花园是完善的。
不完善花园里花的最少数目为 4 。
所以总美丽值为 3 * 2 + 4 * 6 = 6 + 24 = 30 。
没有其他方案可以让花园总美丽值超过 30 。
注意，Alice可以让所有花园都变成完善的，但这样她的总美丽值反而更小。
```

 

**提示：**

- `1 <= flowers.length <= 105`
- `1 <= flowers[i], target <= 105`
- `1 <= newFlowers <= 1010`
- `1 <= full, partial <= 105`

方法：贪心

**选择数组 `flowers` 中最大的若干个元素，将它们加到至少 `target` 朵花，成为「完善」的花园；对于剩余的花朵，我们将它们加入 `flowers` 剩余的元素中，使得最终最小的元素尽可能大。**

证明：

​		假设数组 `flowers` 中有两个元素 x, y 满足 `x > y`，我们一定是优先将 x 加到 `target` 的。这里可以使用反正 + 构造法，如果我们优先将 y 加到 `target`，那么添加的花朵数 `target − y` 可以拆分成 `target − x` 以及 `x - y` 这两部分之和，我们将前者添加到 x 中，后者添加到 y 中，这样最终同样得到了 `target` 和 x。因此优先将更大的元素加到 `target` 一定是优的。

因此我们可以将 `flowers` 首先进行降序排序。记其长度为 n，这样一来，我们可以枚举「完善」和「不完善」的分界线 i，表示将 [0,  i)变成完善的花园，[i,  n) 为不完善的花园。

思路：

提示 1
枚举种花后，完善的花园的数目。

提示 2
为了留下更多的花去填充不完善的花园，我们应当选择那些花朵更多的花园去变成完善的。

提示 3
将 `flowers` 从小到大排序，从而方便枚举哪些是完善的花园。

那么剩下要解决的问题就是，怎么最大化其余花园的花的最小数目。

提示 4
枚举 `flowers` 的后缀，让这些花园的花增加至 `target`，同时我们需要求出 `flowers` 的最长前缀（设其长为 xx），满足前缀中的花园的花都能填充至至少 `flowers[x−1]` 朵。（这可以用二分或双指针来实现，下面代码用的双指针）

设在填充后缀之后，剩余 `leftFlowers` 朵花可以种植，且长为 xx 的前缀一共有 `sumFlowers` 朵花（这里的 x 需要满足上面填充的要求）。那么在填充后，这 x 个花园一共有 `leftFlowers + sumFlowers` 朵花。由于最小值不会超过平均值，在均匀分配的情况下，最小值的最大值可以为平均值的下取整，即

$$
\Big\lfloor\dfrac{\textit{leftFlowers}+\textit{sumFlowers}}{x}\Big\rfloor
$$
注意这个值不能超过 `target−1`，否则不满足题目「不完善」的要求。

按照上述方法，枚举后缀的同时计算出对应的最长前缀，及其最小值的最大值，进而计算出对应的总美丽值。所有总美丽值的最大值即为答案。

**复杂度分析：**
时间复杂度：O(nlogn)，其中 n 为 `flowers` 的长度。瓶颈在排序上。
空间复杂度：O(1)，仅用到若干变量。如果考虑快排时的栈开销，则空间复杂度为 O(logn)。

x 个花园，范围为`[0，x）`一共有 `leftFlowers + sumFlowers` 朵花。**由于最小值不会超过平均值，在均匀分配的情况下，最小值的最大值可以为平均值的下取整**

这个原理可太精髓了，直接把填充不完善花园中最小数目的操作简化了很多很多！！

**核心思路：**

1. 如果要填充完善花园，一定是优先填种花数最多的花园，因此容易想到排序数组，然后逆序遍历进行填充
2. 如果不填充为完善花园，那就要使得所有**不完善花园中花数的最小值最大**
3. 但是，填还是不填我们并不知道，需要根据 `full` 和 `partial` 的值确定，不过这个分类讨论就太细了没法做。因此！填和不填两种情况的美丽值我们都算出来，取最大值就行了！
4. 根据上述三点，我们可以逆序遍历数组，对于每个花园，我们分别计算不填充为完善花园（当前花园和之前花园都不填充）的美丽值，以及当前花园填充为完善花园，然后继续循环，在下一个花园上走相同逻辑！

C++版代码：

```c++
class Solution {
public:
    long long maximumBeauty(vector<int> &flowers, long long newFlowers, int target, int full, int partial) {
        sort(flowers.begin(), flowers.end());
        long n = flowers.size();
        if (flowers[0] >= target) return n * full; // 剪枝，此时所有花园都是完善的

        long leftFlowers = newFlowers - target * n; // leftFlowers 用来记录填充后缀后，剩余可以种植的花
        for (int i = 0; i < n; ++i) {
            flowers[i] = min(flowers[i], target);
            leftFlowers += flowers[i]; // 此时为负数，表示：填充所有花园到 target 差了 leftFlowers 朵花
        }
        //cout << "leftFlowers = " << leftFlowers << endl; 
        long ans = 0L;
        long sumFlowers = 0L; // 长为 x，区间为[0, x) 的前缀一共有 sumFlowers 朵花
        for (int i = 0, x = 0; i <= n; ++i) { // 枚举后缀长度 n - i，后缀花园都被填充为完善花园
            if (leftFlowers >= 0) {
                cout << leftFlowers << endl;
                // 计算最长前缀的长度
                // flowers[x] * x - sumFlowers 表示：将[0, x] 的花园填充为 flowers[x] 朵花 还需要的花的数量
                // flowers[x] * x - sumFlowers <= leftFlowers 保证了计算平均值时，为均匀分配的情况
                while (x < i && (long) flowers[x] * x - sumFlowers <= leftFlowers) {
                    sumFlowers += flowers[x++]; // 注意 x 只增不减，二重循环的时间复杂度为 O(n)
                }
                long beauty = (n - i) * full; // 计算总美丽值
                // x 个花园一共有 leftFlowers + sumFlowers 朵花。
                // 由于最小值不会超过平均值，在均匀分配的情况下，最小值的最大值可以为平均值的下取整
                if (x > 0) {
                    beauty += min((leftFlowers + sumFlowers) / x, (long) target - 1) * partial;
                }
                ans = max(ans, beauty);
            }
            if (i < n) leftFlowers += target - flowers[i]; // 不填充第 i 个花园的花
        }
        return ans;
    }
}; // 2022.4.23
```

Python版代码：

```python
class Solution:
    def maximumBeauty(self, flowers: List[int], newFlowers: int, target: int, full: int, partial: int) -> int:
        flowers.sort()
        n = len(flowers)
        if flowers[0] >= target:  # 剪枝，此时所有花园都是完善的
            return n * full

        leftFlowers = newFlowers - target * n  # 填充后缀后，剩余可以种植的花
        for i in range(n):
            flowers[i] = min(flowers[i], target)
            leftFlowers += flowers[i]

        ans, x, sumFlowers = 0, 0, 0
        for i in range(n + 1):  # 枚举后缀长度 n-i
            if leftFlowers >= 0:
                # 计算最长前缀的长度
                while x < i and flowers[x] * x - sumFlowers <= leftFlowers:
                    sumFlowers += flowers[x]
                    x += 1  # 注意 x 只增不减，二重循环的时间复杂度为 O(n)
                beauty = (n - i) * full  # 计算总美丽值
                if x:
                    beauty += min((leftFlowers + sumFlowers) // x, target - 1) * partial
                ans = max(ans, beauty)
            if i < n:
                leftFlowers += target - flowers[i]
        return ans
```

## 第 74 场双周赛-2022.3.19

#### [2207. 字符串中最多数目的子字符串](https://leetcode.cn/problems/maximize-number-of-subsequences-in-a-string/)

难度中等12

给你一个下标从 **0** 开始的字符串 `text` 和另一个下标从 **0** 开始且长度为 `2` 的字符串 `pattern` ，两者都只包含小写英文字母。

你可以在 `text` 中任意位置插入 **一个** 字符，这个插入的字符必须是 `pattern[0]` **或者** `pattern[1]` 。注意，这个字符可以插入在 `text` 开头或者结尾的位置。

请你返回插入一个字符后，`text` 中最多包含多少个等于 `pattern` 的 **子序列** 。

**子序列** 指的是将一个字符串删除若干个字符后（也可以不删除），剩余字符保持原本顺序得到的字符串。

 

**示例 1：**

```
输入：text = "abdcdbc", pattern = "ac"
输出：4
解释：
如果我们在 text[1] 和 text[2] 之间添加 pattern[0] = 'a' ，那么我们得到 "abadcdbc" 。那么 "ac" 作为子序列出现 4 次。
其他得到 4 个 "ac" 子序列的方案还有 "aabdcdbc" 和 "abdacdbc" 。
但是，"abdcadbc" ，"abdccdbc" 和 "abdcdbcc" 这些字符串虽然是可行的插入方案，但是只出现了 3 次 "ac" 子序列，所以不是最优解。
可以证明插入一个字符后，无法得到超过 4 个 "ac" 子序列。
```

**示例 2：**

```
输入：text = "aabb", pattern = "ab"
输出：6
解释：
可以得到 6 个 "ab" 子序列的部分方案为 "aaabb" ，"aaabb" 和 "aabbb" 。
```

 

**提示：**

- `1 <= text.length <= 105`
- `pattern.length == 2`
- `text` 和 `pattern` 都只包含小写英文字母。

方法：贪心

C++版代码：自己的代码

```c++
class Solution {
public:
    long long maximumSubsequenceCount(string text, string pattern) {
        vector<int> left(text.size(), -1); // 记录下标 i 的左侧有几个 pattern[0]
        vector<int> right(text.size(), -1); // 记录下标 i 的右侧有几个 pattern[1]
        int count0 = 0;
        int count1 = 0;
        long long resultLeft = 0;
        long long resultRight = 0;
        for (int i = 0; i < text.size(); i++) {
            if (text[i] == pattern[0] && pattern[0] == pattern[1]) {
                left[i] = count0;
                resultLeft += left[i];
                count0++;
            } else if (text[i] == pattern[0]) {
                count0++;
            } else if (text[i] == pattern[1]) {
                left[i] = count0;
                resultLeft += left[i];
            }
        }
        for (int i = text.size() - 1; i >= 0; i--) {
            if (text[i] == pattern[1] && pattern[0] == pattern[1]) {
                right[i] = count1;
                resultRight += right[i];
                count1++;
            } else if (text[i] == pattern[1]) {
                count1++;
            } else if (text[i] == pattern[0]) {
                right[i] = count1;
                resultRight += right[i];
            }
        }
        for (int i = 0; i < text.size(); i++) {
            if (text[i] == pattern[0]) {
                resultLeft++;
            }
            if (text[i] == pattern[1]) {
                resultRight++;
            }
        }
        return max(resultLeft, resultRight);
    }
}; // 2022.3.19
```

C++版代码：精简代码

```c++
class Solution {
public:
    long long maximumSubsequenceCount(string text, string pattern) {
        int cnt[2] = {0,0};long long ans=0;
        for(int i = 0; i < text.size(); i++)
        {
            if(text[i] == pattern[1])
            {
                ans += cnt[0];
                cnt[1]++;
            }
            if(text[i] == pattern[0]) cnt[0]++;
        }
        return ans + max(cnt[0], cnt[1]);
    }
}; // 2022.3.21
```



#### [2208. 将数组和减半的最少操作次数](https://leetcode.cn/problems/minimum-operations-to-halve-array-sum/)（SE）

难度中等6

给你一个正整数数组 `nums` 。每一次操作中，你可以从 `nums` 中选择 **任意** 一个数并将它减小到 **恰好** 一半。（注意，在后续操作中你可以对减半过的数继续执行操作）

请你返回将 `nums` 数组和 **至少** 减少一半的 **最少** 操作数。

 

**示例 1：**

```
输入：nums = [5,19,8,1]
输出：3
解释：初始 nums 的和为 5 + 19 + 8 + 1 = 33 。
以下是将数组和减少至少一半的一种方法：
选择数字 19 并减小为 9.5 。
选择数字 9.5 并减小为 4.75 。
选择数字 8 并减小为 4 。
最终数组为 [5, 4.75, 4, 1] ，和为 5 + 4.75 + 4 + 1 = 14.75 。
nums 的和减小了 33 - 14.75 = 18.25 ，减小的部分超过了初始数组和的一半，18.25 >= 33/2 = 16.5 。
我们需要 3 个操作实现题目要求，所以返回 3 。
可以证明，无法通过少于 3 个操作使数组和减少至少一半。
```

**示例 2：**

```
输入：nums = [3,8,20]
输出：3
解释：初始 nums 的和为 3 + 8 + 20 = 31 。
以下是将数组和减少至少一半的一种方法：
选择数字 20 并减小为 10 。
选择数字 10 并减小为 5 。
选择数字 3 并减小为 1.5 。
最终数组为 [1.5, 8, 5] ，和为 1.5 + 8 + 5 = 14.5 。
nums 的和减小了 31 - 14.5 = 16.5 ，减小的部分超过了初始数组和的一半， 16.5 >= 31/2 = 16.5 。
我们需要 3 个操作实现题目要求，所以返回 3 。
可以证明，无法通过少于 3 个操作使数组和减少至少一半。
```

 

**提示：**

- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 107`

方法：优先级队列

C++版代码：

```C++
class Solution {
public:
    int halveArray(vector<int>& nums) {
        priority_queue<double> que;
        double sum = 0;
        int result = 0;
        for (int i = 0; i < nums.size(); i++) {
            que.push(nums[i]);
            sum += nums[i];
        }
        double num = sum;
        while (num > sum / 2) {
            double val = que.top();
            que.pop();
            num -= val / 2;
            result++;
            que.push(val / 2);
            cout<<num<<" ";
        }
        return result;
    }
}; // 2022.3.19
```

#### [2209. 用地毯覆盖后的最少白色砖块](https://leetcode.cn/problems/minimum-white-tiles-after-covering-with-carpets/)（赛后复盘写出来了）

难度困难23

给你一个下标从 **0** 开始的 **二进制** 字符串 `floor` ，它表示地板上砖块的颜色。

- `floor[i] = '0'` 表示地板上第 `i` 块砖块的颜色是 **黑色** 。
- `floor[i] = '1'` 表示地板上第 `i` 块砖块的颜色是 **白色** 。

同时给你 `numCarpets` 和 `carpetLen` 。你有 `numCarpets` 条 **黑色** 的地毯，每一条 **黑色** 的地毯长度都为 `carpetLen` 块砖块。请你使用这些地毯去覆盖砖块，使得未被覆盖的剩余 **白色** 砖块的数目 **最小** 。地毯相互之间可以覆盖。

请你返回没被覆盖的白色砖块的 **最少** 数目。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/02/10/ex1-1.png)

```
输入：floor = "10110101", numCarpets = 2, carpetLen = 2
输出：2
解释：
上图展示了剩余 2 块白色砖块的方案。
没有其他方案可以使未被覆盖的白色砖块少于 2 块。
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/02/10/ex2.png)

```
输入：floor = "11111", numCarpets = 2, carpetLen = 3
输出：0
解释：
上图展示了所有白色砖块都被覆盖的一种方案。
注意，地毯相互之间可以覆盖。
```

 

**提示：**

- `1 <= carpetLen <= floor.length <= 1000`
- `floor[i]` 要么是 `'0'` ，要么是 `'1'` 。
- `1 <= numCarpets <= 1000`

方法：动态规划

C++版代码：

```c++
class Solution {
public:
    int minimumWhiteTiles(string floor, int numCarpets, int carpetLen) {
        int n = floor.size();
        int result = 0;
        vector<vector<int>> dp(numCarpets + 1, vector<int>(n, 0));
        for (int j = 0; j < n; j++) {
            result += floor[j] - '0';
            dp[0][j] = result;
        }
        for (int i = 1; i <= numCarpets; i++) {
            for (int j = i * carpetLen; j < n; j++) {
                if (floor[j] == '0') {
                    dp[i][j] = dp[i][j - 1];
                } else {
                    dp[i][j] = min(dp[i][j - 1] + 1, dp[i - 1][j - carpetLen]);
                }
            }
        }
        return dp[numCarpets][n - 1];
    }
};
/*
1. 确定dp数组（dp table）以及下标的含义
    dp[i][j] 表示用 i 条长度为 carpetlen 的黑色地毯覆盖下标从 0 到 j 的地板，
    使得未被覆盖的剩余白色砖块的最小数目为 dp[i][j]。
2. 确定递推公式
    主要就是两⼤情况： 要不要用黑色毛毯覆盖 floor[j] 的地板，即：floor[j] == '0' 与 floor[j] == '1'
    (1).floor[j] == '0', 不需要覆盖 floor[j] 的地板, 则：dp[i][j] = dp[i][j - 1]。
    (2). floor[j] == '1'，需不需要覆盖 floor[j] 的地板，那就看 [j - carpetLen + 1, j] 覆盖后白色地板是否减少:
    即:
        if (floor[j] == '1') {
            dp[i][j] = min(dp[i][j - 1], dp[i - 1][j - carpetLen]);
        }  
3. dp数组如何初始化
    当 i = 0 时：
        dp[0][j] 为 0 条长度为 carpetLen 的黑色毛毯覆盖 0 到 j 的地板，使得未被覆盖的剩余白色砖块的最小数目为 dp[i][j]。
        所以 dp[0][j] 为下标从 0 到 j 的白色砖块的个数。
    当 i != 0 时：
        当 j <= i * carpetLen, dp[i][j] = 0;
4. 确定遍历顺序
   从前向后，从上到下来遍历这个矩阵
*/ // 2022.3.22
```

